// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package pio provides access to the registers of the PIO peripheral.
//
// Instances:
//
//	PIO0  PIO0_BASE  -  PIO0_0,PIO0_1  Programmable IO block
//	PIO1  PIO1_BASE  -  PIO1_0,PIO1_1  Programmable IO block
//	PIO2  PIO2_BASE  -  PIO2_0,PIO2_1  Programmable IO block
//
// Registers:
//
//	0x000 32  CTRL               PIO control register
//	0x004 32  FSTAT              FIFO status register
//	0x008 32  FDEBUG             FIFO debug register
//	0x00C 32  FLEVEL             FIFO levels
//	0x010 32  TXF0               Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
//	0x014 32  TXF1               Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
//	0x018 32  TXF2               Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
//	0x01C 32  TXF3               Direct write access to the TX FIFO for this state machine. Each write pushes one word to the FIFO. Attempting to write to a full FIFO has no effect on the FIFO state or contents, and sets the sticky FDEBUG_TXOVER error flag for this FIFO.
//	0x020 32  RXF0               Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
//	0x024 32  RXF1               Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
//	0x028 32  RXF2               Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
//	0x02C 32  RXF3               Direct read access to the RX FIFO for this state machine. Each read pops one word from the FIFO. Attempting to read from an empty FIFO has no effect on the FIFO state, and sets the sticky FDEBUG_RXUNDER error flag for this FIFO. The data returned to the system on a read from an empty FIFO is undefined.
//	0x030 32  IRQ                State machine IRQ flags register. Write 1 to clear. There are eight state machine IRQ flags, which can be set, cleared, and waited on by the state machines. There's no fixed association between flags and state machines -- any state machine can use any flag. Any of the eight flags can be used for timing synchronisation between state machines, using IRQ and WAIT instructions. Any combination of the eight flags can also routed out to either of the two system-level interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE.
//	0x034 32  IRQ_FORCE          Writing a 1 to each of these bits will forcibly assert the corresponding IRQ. Note this is different to the INTF register: writing here affects PIO internal state. INTF just asserts the processor-facing IRQ signal for testing ISRs, and is not visible to the state machines.
//	0x038 32  INPUT_SYNC_BYPASS  There is a 2-flipflop synchronizer on each GPIO input, which protects PIO logic from metastabilities. This increases input delay, and for fast synchronous IO (e.g. SPI) these synchronizers may need to be bypassed. Each bit in this register corresponds to one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If in doubt, leave this register as all zeroes.
//	0x03C 32  DBG_PADOUT         Read to sample the pad output values PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
//	0x040 32  DBG_PADOE          Read to sample the pad output enables (direction) PIO is currently driving to the GPIOs. On RP2040 there are 30 GPIOs, so the two most significant bits are hardwired to 0.
//	0x044 32  DBG_CFGINFO        The PIO hardware has some free parameters that may vary between chip products. These should be provided in the chip datasheet, but are also exposed here.
//	0x048 32  INSTR_MEM0         Write-only access to instruction memory location 0
//	0x04C 32  INSTR_MEM1         Write-only access to instruction memory location 1
//	0x050 32  INSTR_MEM2         Write-only access to instruction memory location 2
//	0x054 32  INSTR_MEM3         Write-only access to instruction memory location 3
//	0x058 32  INSTR_MEM4         Write-only access to instruction memory location 4
//	0x05C 32  INSTR_MEM5         Write-only access to instruction memory location 5
//	0x060 32  INSTR_MEM6         Write-only access to instruction memory location 6
//	0x064 32  INSTR_MEM7         Write-only access to instruction memory location 7
//	0x068 32  INSTR_MEM8         Write-only access to instruction memory location 8
//	0x06C 32  INSTR_MEM9         Write-only access to instruction memory location 9
//	0x070 32  INSTR_MEM10        Write-only access to instruction memory location 10
//	0x074 32  INSTR_MEM11        Write-only access to instruction memory location 11
//	0x078 32  INSTR_MEM12        Write-only access to instruction memory location 12
//	0x07C 32  INSTR_MEM13        Write-only access to instruction memory location 13
//	0x080 32  INSTR_MEM14        Write-only access to instruction memory location 14
//	0x084 32  INSTR_MEM15        Write-only access to instruction memory location 15
//	0x088 32  INSTR_MEM16        Write-only access to instruction memory location 16
//	0x08C 32  INSTR_MEM17        Write-only access to instruction memory location 17
//	0x090 32  INSTR_MEM18        Write-only access to instruction memory location 18
//	0x094 32  INSTR_MEM19        Write-only access to instruction memory location 19
//	0x098 32  INSTR_MEM20        Write-only access to instruction memory location 20
//	0x09C 32  INSTR_MEM21        Write-only access to instruction memory location 21
//	0x0A0 32  INSTR_MEM22        Write-only access to instruction memory location 22
//	0x0A4 32  INSTR_MEM23        Write-only access to instruction memory location 23
//	0x0A8 32  INSTR_MEM24        Write-only access to instruction memory location 24
//	0x0AC 32  INSTR_MEM25        Write-only access to instruction memory location 25
//	0x0B0 32  INSTR_MEM26        Write-only access to instruction memory location 26
//	0x0B4 32  INSTR_MEM27        Write-only access to instruction memory location 27
//	0x0B8 32  INSTR_MEM28        Write-only access to instruction memory location 28
//	0x0BC 32  INSTR_MEM29        Write-only access to instruction memory location 29
//	0x0C0 32  INSTR_MEM30        Write-only access to instruction memory location 30
//	0x0C4 32  INSTR_MEM31        Write-only access to instruction memory location 31
//	0x0C8 32  SM0_CLKDIV         Clock divisor register for state machine 0 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
//	0x0CC 32  SM0_EXECCTRL       Execution/behavioural settings for state machine 0
//	0x0D0 32  SM0_SHIFTCTRL      Control behaviour of the input/output shift registers for state machine 0
//	0x0D4 32  SM0_ADDR           Current instruction address of state machine 0
//	0x0D8 32  SM0_INSTR          Read to see the instruction currently addressed by state machine 0's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
//	0x0DC 32  SM0_PINCTRL        State machine pin control
//	0x0E0 32  SM1_CLKDIV         Clock divisor register for state machine 1 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
//	0x0E4 32  SM1_EXECCTRL       Execution/behavioural settings for state machine 1
//	0x0E8 32  SM1_SHIFTCTRL      Control behaviour of the input/output shift registers for state machine 1
//	0x0EC 32  SM1_ADDR           Current instruction address of state machine 1
//	0x0F0 32  SM1_INSTR          Read to see the instruction currently addressed by state machine 1's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
//	0x0F4 32  SM1_PINCTRL        State machine pin control
//	0x0F8 32  SM2_CLKDIV         Clock divisor register for state machine 2 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
//	0x0FC 32  SM2_EXECCTRL       Execution/behavioural settings for state machine 2
//	0x100 32  SM2_SHIFTCTRL      Control behaviour of the input/output shift registers for state machine 2
//	0x104 32  SM2_ADDR           Current instruction address of state machine 2
//	0x108 32  SM2_INSTR          Read to see the instruction currently addressed by state machine 2's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
//	0x10C 32  SM2_PINCTRL        State machine pin control
//	0x110 32  SM3_CLKDIV         Clock divisor register for state machine 3 Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
//	0x114 32  SM3_EXECCTRL       Execution/behavioural settings for state machine 3
//	0x118 32  SM3_SHIFTCTRL      Control behaviour of the input/output shift registers for state machine 3
//	0x11C 32  SM3_ADDR           Current instruction address of state machine 3
//	0x120 32  SM3_INSTR          Read to see the instruction currently addressed by state machine 3's program counter Write to execute an instruction immediately (including jumps) and then resume execution.
//	0x124 32  SM3_PINCTRL        State machine pin control
//	0x128 32  RXF0_PUTGET0       Direct read/write access to entry 0 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x12C 32  RXF0_PUTGET1       Direct read/write access to entry 1 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x130 32  RXF0_PUTGET2       Direct read/write access to entry 2 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x134 32  RXF0_PUTGET3       Direct read/write access to entry 3 of SM0's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x138 32  RXF1_PUTGET0       Direct read/write access to entry 0 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x13C 32  RXF1_PUTGET1       Direct read/write access to entry 1 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x140 32  RXF1_PUTGET2       Direct read/write access to entry 2 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x144 32  RXF1_PUTGET3       Direct read/write access to entry 3 of SM1's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x148 32  RXF2_PUTGET0       Direct read/write access to entry 0 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x14C 32  RXF2_PUTGET1       Direct read/write access to entry 1 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x150 32  RXF2_PUTGET2       Direct read/write access to entry 2 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x154 32  RXF2_PUTGET3       Direct read/write access to entry 3 of SM2's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x158 32  RXF3_PUTGET0       Direct read/write access to entry 0 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x15C 32  RXF3_PUTGET1       Direct read/write access to entry 1 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x160 32  RXF3_PUTGET2       Direct read/write access to entry 2 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x164 32  RXF3_PUTGET3       Direct read/write access to entry 3 of SM3's RX FIFO, if SHIFTCTRL_FJOIN_RX_PUT xor SHIFTCTRL_FJOIN_RX_GET is set.
//	0x168 32  GPIOBASE           Relocate GPIO 0 (from PIO's point of view) in the system GPIO numbering, to access more than 32 GPIOs from PIO. Only the values 0 and 16 are supported (only bit 4 is writable).
//	0x16C 32  INTR               Raw Interrupts
//	0x170 32  IRQ0_INTE          Interrupt Enable for irq0
//	0x174 32  IRQ0_INTF          Interrupt Force for irq0
//	0x178 32  IRQ0_INTS          Interrupt status after masking & forcing for irq0
//	0x17C 32  IRQ1_INTE          Interrupt Enable for irq1
//	0x180 32  IRQ1_INTF          Interrupt Force for irq1
//	0x184 32  IRQ1_INTS          Interrupt status after masking & forcing for irq1
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package pio

const (
	SM_ENABLE               CTRL = 0x0F << 0  //+ Enable/disable each of the four state machines by writing 1/0 to each of these four bits. When disabled, a state machine will cease executing instructions, except those written directly to SMx_INSTR by the system. Multiple bits can be set/cleared at once to run/halt multiple state machines simultaneously.
	SM_RESTART              CTRL = 0x0F << 4  //+ Write 1 to instantly clear internal SM state which may be otherwise difficult to access and will affect future execution. Specifically, the following are cleared: input and output shift counters; the contents of the input shift register; the delay counter; the waiting-on-IRQ state; any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any pin write left asserted due to OUT_STICKY. The contents of the output shift register and the X/Y scratch registers are not affected.
	CLKDIV_RESTART          CTRL = 0x0F << 8  //+ Restart a state machine's clock divider from an initial phase of 0. Clock dividers are free-running, so once started, their output (including fractional jitter) is completely determined by the integer/fractional divisor configured in SMx_CLKDIV. This means that, if multiple clock dividers with the same divisor are restarted simultaneously, by writing multiple 1 bits to this field, the execution clocks of those state machines will run in precise lockstep. Note that setting/clearing SM_ENABLE does not stop the clock divider from running, so once multiple state machines' clocks are synchronised, it is safe to disable/reenable a state machine, whilst keeping the clock dividers in sync. Note also that CLKDIV_RESTART can be written to whilst the state machine is running, and this is useful to resynchronise clock dividers after the divisors (SMx_CLKDIV) have been changed on-the-fly.
	PREV_PIO_MASK           CTRL = 0x0F << 16 //+ A mask of state machines in the neighbouring lower-numbered PIO block in the system (or the highest-numbered PIO block if this is PIO block 0) to which to apply the operations specified by OP_CLKDIV_RESTART, OP_ENABLE, OP_DISABLE in the same write. This allows state machines in a neighbouring PIO block to be started/stopped/clock-synced exactly simultaneously with a write to this PIO block's CTRL register. Neighbouring PIO blocks are disconnected (status signals tied to 0 and control signals ignored) if one block is accessible to NonSecure code, and one is not.
	NEXT_PIO_MASK           CTRL = 0x0F << 20 //+ A mask of state machines in the neighbouring higher-numbered PIO block in the system (or PIO block 0 if this is the highest-numbered PIO block) to which to apply the operations specified by NEXTPREV_CLKDIV_RESTART, NEXTPREV_SM_ENABLE, and NEXTPREV_SM_DISABLE in the same write. This allows state machines in a neighbouring PIO block to be started/stopped/clock-synced exactly simultaneously with a write to this PIO block's CTRL register. Note that in a system with two PIOs, NEXT_PIO_MASK and PREV_PIO_MASK actually indicate the same PIO block. In this case the effects are applied cumulatively (as though the masks were OR'd together). Neighbouring PIO blocks are disconnected (status signals tied to 0 and control signals ignored) if one block is accessible to NonSecure code, and one is not.
	NEXTPREV_SM_ENABLE      CTRL = 0x01 << 24 //+ Write 1 to enable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write. This is equivalent to setting the corresponding SM_ENABLE bits in those PIOs' CTRL registers. If both OTHERS_SM_ENABLE and OTHERS_SM_DISABLE are set, the disable takes precedence.
	NEXTPREV_SM_DISABLE     CTRL = 0x01 << 25 //+ Write 1 to disable state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write. This is equivalent to clearing the corresponding SM_ENABLE bits in those PIOs' CTRL registers.
	NEXTPREV_CLKDIV_RESTART CTRL = 0x01 << 26 //+ Write 1 to restart the clock dividers of state machines in neighbouring PIO blocks, as specified by NEXT_PIO_MASK and PREV_PIO_MASK in the same write. This is equivalent to writing 1 to the corresponding CLKDIV_RESTART bits in those PIOs' CTRL registers.
)

const (
	SM_ENABLEn               = 0
	SM_RESTARTn              = 4
	CLKDIV_RESTARTn          = 8
	PREV_PIO_MASKn           = 16
	NEXT_PIO_MASKn           = 20
	NEXTPREV_SM_ENABLEn      = 24
	NEXTPREV_SM_DISABLEn     = 25
	NEXTPREV_CLKDIV_RESTARTn = 26
)

const (
	RXFULL  FSTAT = 0x0F << 0  //+ State machine RX FIFO is full
	RXEMPTY FSTAT = 0x0F << 8  //+ State machine RX FIFO is empty
	TXFULL  FSTAT = 0x0F << 16 //+ State machine TX FIFO is full
	TXEMPTY FSTAT = 0x0F << 24 //+ State machine TX FIFO is empty
)

const (
	RXFULLn  = 0
	RXEMPTYn = 8
	TXFULLn  = 16
	TXEMPTYn = 24
)

const (
	RXSTALL FDEBUG = 0x0F << 0  //+ State machine has stalled on full RX FIFO during a blocking PUSH, or an IN with autopush enabled. This flag is also set when a nonblocking PUSH to a full FIFO took place, in which case the state machine has dropped data. Write 1 to clear.
	RXUNDER FDEBUG = 0x0F << 8  //+ RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write 1 to clear. Note that read-on-empty does not perturb the state of the FIFO in any way, but the data returned by reading from an empty FIFO is undefined, so this flag generally only becomes set due to some kind of software error.
	TXOVER  FDEBUG = 0x0F << 16 //+ TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write 1 to clear. Note that write-on-full does not alter the state or contents of the FIFO in any way, but the data that the system attempted to write is dropped, so if this flag is set, your software has quite likely dropped some data on the floor.
	TXSTALL FDEBUG = 0x0F << 24 //+ State machine has stalled on empty TX FIFO during a blocking PULL, or an OUT with autopull enabled. Write 1 to clear.
)

const (
	RXSTALLn = 0
	RXUNDERn = 8
	TXOVERn  = 16
	TXSTALLn = 24
)

const (
	TX0 FLEVEL = 0x0F << 0  //+
	RX0 FLEVEL = 0x0F << 4  //+
	TX1 FLEVEL = 0x0F << 8  //+
	RX1 FLEVEL = 0x0F << 12 //+
	TX2 FLEVEL = 0x0F << 16 //+
	RX2 FLEVEL = 0x0F << 20 //+
	TX3 FLEVEL = 0x0F << 24 //+
	RX3 FLEVEL = 0x0F << 28 //+
)

const (
	TX0n = 0
	RX0n = 4
	TX1n = 8
	RX1n = 12
	TX2n = 16
	RX2n = 20
	TX3n = 24
	RX3n = 28
)

const (
	FIFO_DEPTH DBG_CFGINFO = 0x3F << 0  //+ The depth of the state machine TX/RX FIFOs, measured in words. Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double this depth.
	SM_COUNT   DBG_CFGINFO = 0x0F << 8  //+ The number of state machines this PIO instance is equipped with.
	IMEM_SIZE  DBG_CFGINFO = 0x3F << 16 //+ The size of the instruction memory, measured in units of one instruction
	VERSION    DBG_CFGINFO = 0x0F << 28 //+ Version of the core PIO hardware.
	V0         DBG_CFGINFO = 0x00 << 28 //  Version 0 (RP2040)
	V1         DBG_CFGINFO = 0x01 << 28 //  Version 1 (RP2350)
)

const (
	FIFO_DEPTHn = 0
	SM_COUNTn   = 8
	IMEM_SIZEn  = 16
	VERSIONn    = 28
)

const (
	FRAC SM0_CLKDIV = 0xFF << 8    //+ Fractional part of clock divisor
	INT  SM0_CLKDIV = 0xFFFF << 16 //+ Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
)

const (
	FRACn = 8
	INTn  = 16
)

const (
	STATUS_N      SM0_EXECCTRL = 0x1F << 0  //+ Comparison level or IRQ index for the MOV x, STATUS instruction. If STATUS_SEL is TXLEVEL or RXLEVEL, then values of STATUS_N greater than the current FIFO depth are reserved, and have undefined behaviour.
	IRQ           SM0_EXECCTRL = 0x00 << 0  //  Index 0-7 of an IRQ flag in this PIO block
	IRQ_PREVPIO   SM0_EXECCTRL = 0x08 << 0  //  Index 0-7 of an IRQ flag in the next lower-numbered PIO block
	IRQ_NEXTPIO   SM0_EXECCTRL = 0x10 << 0  //  Index 0-7 of an IRQ flag in the next higher-numbered PIO block
	STATUS_SEL    SM0_EXECCTRL = 0x03 << 5  //+ Comparison used for the MOV x, STATUS instruction.
	TXLEVEL       SM0_EXECCTRL = 0x00 << 5  //  All-ones if TX FIFO level < N, otherwise all-zeroes
	RXLEVEL       SM0_EXECCTRL = 0x01 << 5  //  All-ones if RX FIFO level < N, otherwise all-zeroes
	IRQ           SM0_EXECCTRL = 0x02 << 5  //  All-ones if the indexed IRQ flag is raised, otherwise all-zeroes
	WRAP_BOTTOM   SM0_EXECCTRL = 0x1F << 7  //+ After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      SM0_EXECCTRL = 0x1F << 12 //+ After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    SM0_EXECCTRL = 0x01 << 17 //+ Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN SM0_EXECCTRL = 0x01 << 18 //+ If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    SM0_EXECCTRL = 0x1F << 19 //+ Which data bit to use for inline OUT enable
	JMP_PIN       SM0_EXECCTRL = 0x1F << 24 //+ The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   SM0_EXECCTRL = 0x01 << 29 //+ If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       SM0_EXECCTRL = 0x01 << 30 //+ If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  SM0_EXECCTRL = 0x01 << 31 //+ If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
)

const (
	STATUS_Nn      = 0
	STATUS_SELn    = 5
	WRAP_BOTTOMn   = 7
	WRAP_TOPn      = 12
	OUT_STICKYn    = 17
	INLINE_OUT_ENn = 18
	OUT_EN_SELn    = 19
	JMP_PINn       = 24
	SIDE_PINDIRn   = 29
	SIDE_ENn       = 30
	EXEC_STALLEDn  = 31
)

const (
	IN_COUNT     SM0_SHIFTCTRL = 0x1F << 0  //+ Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction. For example, an IN_COUNT of 5 means that the 5 LSBs of the IN pin group are visible (bits 4:0), but the remaining 27 MSBs are masked to 0. A count of 32 is encoded with a field value of 0, so the default behaviour is to not perform any masking. Note this masking is applied in addition to the masking usually performed by the IN instruction. This is mainly useful for the MOV x, PINS instruction, which otherwise has no way of masking pins.
	FJOIN_RX_GET SM0_SHIFTCTRL = 0x01 << 14 //+ If 1, disable this state machine's RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	FJOIN_RX_PUT SM0_SHIFTCTRL = 0x01 << 15 //+ If 1, disable this state machine's RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	AUTOPUSH     SM0_SHIFTCTRL = 0x01 << 16 //+ Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     SM0_SHIFTCTRL = 0x01 << 17 //+ Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  SM0_SHIFTCTRL = 0x01 << 18 //+ 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR SM0_SHIFTCTRL = 0x01 << 19 //+ 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  SM0_SHIFTCTRL = 0x1F << 20 //+ Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  SM0_SHIFTCTRL = 0x1F << 25 //+ Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     SM0_SHIFTCTRL = 0x01 << 30 //+ When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     SM0_SHIFTCTRL = 0x01 << 31 //+ When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
)

const (
	IN_COUNTn     = 0
	FJOIN_RX_GETn = 14
	FJOIN_RX_PUTn = 15
	AUTOPUSHn     = 16
	AUTOPULLn     = 17
	IN_SHIFTDIRn  = 18
	OUT_SHIFTDIRn = 19
	PUSH_THRESHn  = 20
	PULL_THRESHn  = 25
	FJOIN_TXn     = 30
	FJOIN_RXn     = 31
)

const (
	OUT_BASE      SM0_PINCTRL = 0x1F << 0  //+ The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      SM0_PINCTRL = 0x1F << 5  //+ The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  SM0_PINCTRL = 0x1F << 10 //+ The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       SM0_PINCTRL = 0x1F << 15 //+ The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     SM0_PINCTRL = 0x3F << 20 //+ The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     SM0_PINCTRL = 0x07 << 26 //+ The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT SM0_PINCTRL = 0x07 << 29 //+ The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
)

const (
	OUT_BASEn      = 0
	SET_BASEn      = 5
	SIDESET_BASEn  = 10
	IN_BASEn       = 15
	OUT_COUNTn     = 20
	SET_COUNTn     = 26
	SIDESET_COUNTn = 29
)

const (
	FRAC SM1_CLKDIV = 0xFF << 8    //+ Fractional part of clock divisor
	INT  SM1_CLKDIV = 0xFFFF << 16 //+ Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
)

const (
	FRACn = 8
	INTn  = 16
)

const (
	STATUS_N      SM1_EXECCTRL = 0x1F << 0  //+ Comparison level or IRQ index for the MOV x, STATUS instruction. If STATUS_SEL is TXLEVEL or RXLEVEL, then values of STATUS_N greater than the current FIFO depth are reserved, and have undefined behaviour.
	IRQ           SM1_EXECCTRL = 0x00 << 0  //  Index 0-7 of an IRQ flag in this PIO block
	IRQ_PREVPIO   SM1_EXECCTRL = 0x08 << 0  //  Index 0-7 of an IRQ flag in the next lower-numbered PIO block
	IRQ_NEXTPIO   SM1_EXECCTRL = 0x10 << 0  //  Index 0-7 of an IRQ flag in the next higher-numbered PIO block
	STATUS_SEL    SM1_EXECCTRL = 0x03 << 5  //+ Comparison used for the MOV x, STATUS instruction.
	TXLEVEL       SM1_EXECCTRL = 0x00 << 5  //  All-ones if TX FIFO level < N, otherwise all-zeroes
	RXLEVEL       SM1_EXECCTRL = 0x01 << 5  //  All-ones if RX FIFO level < N, otherwise all-zeroes
	IRQ           SM1_EXECCTRL = 0x02 << 5  //  All-ones if the indexed IRQ flag is raised, otherwise all-zeroes
	WRAP_BOTTOM   SM1_EXECCTRL = 0x1F << 7  //+ After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      SM1_EXECCTRL = 0x1F << 12 //+ After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    SM1_EXECCTRL = 0x01 << 17 //+ Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN SM1_EXECCTRL = 0x01 << 18 //+ If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    SM1_EXECCTRL = 0x1F << 19 //+ Which data bit to use for inline OUT enable
	JMP_PIN       SM1_EXECCTRL = 0x1F << 24 //+ The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   SM1_EXECCTRL = 0x01 << 29 //+ If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       SM1_EXECCTRL = 0x01 << 30 //+ If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  SM1_EXECCTRL = 0x01 << 31 //+ If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
)

const (
	STATUS_Nn      = 0
	STATUS_SELn    = 5
	WRAP_BOTTOMn   = 7
	WRAP_TOPn      = 12
	OUT_STICKYn    = 17
	INLINE_OUT_ENn = 18
	OUT_EN_SELn    = 19
	JMP_PINn       = 24
	SIDE_PINDIRn   = 29
	SIDE_ENn       = 30
	EXEC_STALLEDn  = 31
)

const (
	IN_COUNT     SM1_SHIFTCTRL = 0x1F << 0  //+ Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction. For example, an IN_COUNT of 5 means that the 5 LSBs of the IN pin group are visible (bits 4:0), but the remaining 27 MSBs are masked to 0. A count of 32 is encoded with a field value of 0, so the default behaviour is to not perform any masking. Note this masking is applied in addition to the masking usually performed by the IN instruction. This is mainly useful for the MOV x, PINS instruction, which otherwise has no way of masking pins.
	FJOIN_RX_GET SM1_SHIFTCTRL = 0x01 << 14 //+ If 1, disable this state machine's RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	FJOIN_RX_PUT SM1_SHIFTCTRL = 0x01 << 15 //+ If 1, disable this state machine's RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	AUTOPUSH     SM1_SHIFTCTRL = 0x01 << 16 //+ Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     SM1_SHIFTCTRL = 0x01 << 17 //+ Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  SM1_SHIFTCTRL = 0x01 << 18 //+ 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR SM1_SHIFTCTRL = 0x01 << 19 //+ 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  SM1_SHIFTCTRL = 0x1F << 20 //+ Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  SM1_SHIFTCTRL = 0x1F << 25 //+ Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     SM1_SHIFTCTRL = 0x01 << 30 //+ When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     SM1_SHIFTCTRL = 0x01 << 31 //+ When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
)

const (
	IN_COUNTn     = 0
	FJOIN_RX_GETn = 14
	FJOIN_RX_PUTn = 15
	AUTOPUSHn     = 16
	AUTOPULLn     = 17
	IN_SHIFTDIRn  = 18
	OUT_SHIFTDIRn = 19
	PUSH_THRESHn  = 20
	PULL_THRESHn  = 25
	FJOIN_TXn     = 30
	FJOIN_RXn     = 31
)

const (
	OUT_BASE      SM1_PINCTRL = 0x1F << 0  //+ The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      SM1_PINCTRL = 0x1F << 5  //+ The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  SM1_PINCTRL = 0x1F << 10 //+ The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       SM1_PINCTRL = 0x1F << 15 //+ The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     SM1_PINCTRL = 0x3F << 20 //+ The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     SM1_PINCTRL = 0x07 << 26 //+ The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT SM1_PINCTRL = 0x07 << 29 //+ The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
)

const (
	OUT_BASEn      = 0
	SET_BASEn      = 5
	SIDESET_BASEn  = 10
	IN_BASEn       = 15
	OUT_COUNTn     = 20
	SET_COUNTn     = 26
	SIDESET_COUNTn = 29
)

const (
	FRAC SM2_CLKDIV = 0xFF << 8    //+ Fractional part of clock divisor
	INT  SM2_CLKDIV = 0xFFFF << 16 //+ Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
)

const (
	FRACn = 8
	INTn  = 16
)

const (
	STATUS_N      SM2_EXECCTRL = 0x1F << 0  //+ Comparison level or IRQ index for the MOV x, STATUS instruction. If STATUS_SEL is TXLEVEL or RXLEVEL, then values of STATUS_N greater than the current FIFO depth are reserved, and have undefined behaviour.
	IRQ           SM2_EXECCTRL = 0x00 << 0  //  Index 0-7 of an IRQ flag in this PIO block
	IRQ_PREVPIO   SM2_EXECCTRL = 0x08 << 0  //  Index 0-7 of an IRQ flag in the next lower-numbered PIO block
	IRQ_NEXTPIO   SM2_EXECCTRL = 0x10 << 0  //  Index 0-7 of an IRQ flag in the next higher-numbered PIO block
	STATUS_SEL    SM2_EXECCTRL = 0x03 << 5  //+ Comparison used for the MOV x, STATUS instruction.
	TXLEVEL       SM2_EXECCTRL = 0x00 << 5  //  All-ones if TX FIFO level < N, otherwise all-zeroes
	RXLEVEL       SM2_EXECCTRL = 0x01 << 5  //  All-ones if RX FIFO level < N, otherwise all-zeroes
	IRQ           SM2_EXECCTRL = 0x02 << 5  //  All-ones if the indexed IRQ flag is raised, otherwise all-zeroes
	WRAP_BOTTOM   SM2_EXECCTRL = 0x1F << 7  //+ After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      SM2_EXECCTRL = 0x1F << 12 //+ After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    SM2_EXECCTRL = 0x01 << 17 //+ Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN SM2_EXECCTRL = 0x01 << 18 //+ If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    SM2_EXECCTRL = 0x1F << 19 //+ Which data bit to use for inline OUT enable
	JMP_PIN       SM2_EXECCTRL = 0x1F << 24 //+ The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   SM2_EXECCTRL = 0x01 << 29 //+ If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       SM2_EXECCTRL = 0x01 << 30 //+ If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  SM2_EXECCTRL = 0x01 << 31 //+ If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
)

const (
	STATUS_Nn      = 0
	STATUS_SELn    = 5
	WRAP_BOTTOMn   = 7
	WRAP_TOPn      = 12
	OUT_STICKYn    = 17
	INLINE_OUT_ENn = 18
	OUT_EN_SELn    = 19
	JMP_PINn       = 24
	SIDE_PINDIRn   = 29
	SIDE_ENn       = 30
	EXEC_STALLEDn  = 31
)

const (
	IN_COUNT     SM2_SHIFTCTRL = 0x1F << 0  //+ Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction. For example, an IN_COUNT of 5 means that the 5 LSBs of the IN pin group are visible (bits 4:0), but the remaining 27 MSBs are masked to 0. A count of 32 is encoded with a field value of 0, so the default behaviour is to not perform any masking. Note this masking is applied in addition to the masking usually performed by the IN instruction. This is mainly useful for the MOV x, PINS instruction, which otherwise has no way of masking pins.
	FJOIN_RX_GET SM2_SHIFTCTRL = 0x01 << 14 //+ If 1, disable this state machine's RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	FJOIN_RX_PUT SM2_SHIFTCTRL = 0x01 << 15 //+ If 1, disable this state machine's RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	AUTOPUSH     SM2_SHIFTCTRL = 0x01 << 16 //+ Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     SM2_SHIFTCTRL = 0x01 << 17 //+ Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  SM2_SHIFTCTRL = 0x01 << 18 //+ 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR SM2_SHIFTCTRL = 0x01 << 19 //+ 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  SM2_SHIFTCTRL = 0x1F << 20 //+ Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  SM2_SHIFTCTRL = 0x1F << 25 //+ Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     SM2_SHIFTCTRL = 0x01 << 30 //+ When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     SM2_SHIFTCTRL = 0x01 << 31 //+ When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
)

const (
	IN_COUNTn     = 0
	FJOIN_RX_GETn = 14
	FJOIN_RX_PUTn = 15
	AUTOPUSHn     = 16
	AUTOPULLn     = 17
	IN_SHIFTDIRn  = 18
	OUT_SHIFTDIRn = 19
	PUSH_THRESHn  = 20
	PULL_THRESHn  = 25
	FJOIN_TXn     = 30
	FJOIN_RXn     = 31
)

const (
	OUT_BASE      SM2_PINCTRL = 0x1F << 0  //+ The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      SM2_PINCTRL = 0x1F << 5  //+ The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  SM2_PINCTRL = 0x1F << 10 //+ The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       SM2_PINCTRL = 0x1F << 15 //+ The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     SM2_PINCTRL = 0x3F << 20 //+ The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     SM2_PINCTRL = 0x07 << 26 //+ The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT SM2_PINCTRL = 0x07 << 29 //+ The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
)

const (
	OUT_BASEn      = 0
	SET_BASEn      = 5
	SIDESET_BASEn  = 10
	IN_BASEn       = 15
	OUT_COUNTn     = 20
	SET_COUNTn     = 26
	SIDESET_COUNTn = 29
)

const (
	FRAC SM3_CLKDIV = 0xFF << 8    //+ Fractional part of clock divisor
	INT  SM3_CLKDIV = 0xFFFF << 16 //+ Effective frequency is sysclk/(int + frac/256). Value of 0 is interpreted as 65536. If INT is 0, FRAC must also be 0.
)

const (
	FRACn = 8
	INTn  = 16
)

const (
	STATUS_N      SM3_EXECCTRL = 0x1F << 0  //+ Comparison level or IRQ index for the MOV x, STATUS instruction. If STATUS_SEL is TXLEVEL or RXLEVEL, then values of STATUS_N greater than the current FIFO depth are reserved, and have undefined behaviour.
	IRQ           SM3_EXECCTRL = 0x00 << 0  //  Index 0-7 of an IRQ flag in this PIO block
	IRQ_PREVPIO   SM3_EXECCTRL = 0x08 << 0  //  Index 0-7 of an IRQ flag in the next lower-numbered PIO block
	IRQ_NEXTPIO   SM3_EXECCTRL = 0x10 << 0  //  Index 0-7 of an IRQ flag in the next higher-numbered PIO block
	STATUS_SEL    SM3_EXECCTRL = 0x03 << 5  //+ Comparison used for the MOV x, STATUS instruction.
	TXLEVEL       SM3_EXECCTRL = 0x00 << 5  //  All-ones if TX FIFO level < N, otherwise all-zeroes
	RXLEVEL       SM3_EXECCTRL = 0x01 << 5  //  All-ones if RX FIFO level < N, otherwise all-zeroes
	IRQ           SM3_EXECCTRL = 0x02 << 5  //  All-ones if the indexed IRQ flag is raised, otherwise all-zeroes
	WRAP_BOTTOM   SM3_EXECCTRL = 0x1F << 7  //+ After reaching wrap_top, execution is wrapped to this address.
	WRAP_TOP      SM3_EXECCTRL = 0x1F << 12 //+ After reaching this address, execution is wrapped to wrap_bottom. If the instruction is a jump, and the jump condition is true, the jump takes priority.
	OUT_STICKY    SM3_EXECCTRL = 0x01 << 17 //+ Continuously assert the most recent OUT/SET to the pins
	INLINE_OUT_EN SM3_EXECCTRL = 0x01 << 18 //+ If 1, use a bit of OUT data as an auxiliary write enable When used in conjunction with OUT_STICKY, writes with an enable of 0 will deassert the latest pin write. This can create useful masking/override behaviour due to the priority ordering of state machine pin writes (SM0 < SM1 < ...)
	OUT_EN_SEL    SM3_EXECCTRL = 0x1F << 19 //+ Which data bit to use for inline OUT enable
	JMP_PIN       SM3_EXECCTRL = 0x1F << 24 //+ The GPIO number to use as condition for JMP PIN. Unaffected by input mapping.
	SIDE_PINDIR   SM3_EXECCTRL = 0x01 << 29 //+ If 1, side-set data is asserted to pin directions, instead of pin values
	SIDE_EN       SM3_EXECCTRL = 0x01 << 30 //+ If 1, the MSB of the Delay/Side-set instruction field is used as side-set enable, rather than a side-set data bit. This allows instructions to perform side-set optionally, rather than on every instruction, but the maximum possible side-set width is reduced from 5 to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this enable bit.
	EXEC_STALLED  SM3_EXECCTRL = 0x01 << 31 //+ If 1, an instruction written to SMx_INSTR is stalled, and latched by the state machine. Will clear to 0 once this instruction completes.
)

const (
	STATUS_Nn      = 0
	STATUS_SELn    = 5
	WRAP_BOTTOMn   = 7
	WRAP_TOPn      = 12
	OUT_STICKYn    = 17
	INLINE_OUT_ENn = 18
	OUT_EN_SELn    = 19
	JMP_PINn       = 24
	SIDE_PINDIRn   = 29
	SIDE_ENn       = 30
	EXEC_STALLEDn  = 31
)

const (
	IN_COUNT     SM3_SHIFTCTRL = 0x1F << 0  //+ Set the number of pins which are not masked to 0 when read by an IN PINS, WAIT PIN or MOV x, PINS instruction. For example, an IN_COUNT of 5 means that the 5 LSBs of the IN pin group are visible (bits 4:0), but the remaining 27 MSBs are masked to 0. A count of 32 is encoded with a field value of 0, so the default behaviour is to not perform any masking. Note this masking is applied in addition to the masking usually performed by the IN instruction. This is mainly useful for the MOV x, PINS instruction, which otherwise has no way of masking pins.
	FJOIN_RX_GET SM3_SHIFTCTRL = 0x01 << 14 //+ If 1, disable this state machine's RX FIFO, make its storage available for random read access by the state machine (using the `get` instruction) and, unless FJOIN_RX_PUT is also set, random write access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	FJOIN_RX_PUT SM3_SHIFTCTRL = 0x01 << 15 //+ If 1, disable this state machine's RX FIFO, make its storage available for random write access by the state machine (using the `put` instruction) and, unless FJOIN_RX_GET is also set, random read access by the processor (through the RXFx_PUTGETy registers). If FJOIN_RX_PUT and FJOIN_RX_GET are both set, then the RX FIFO's registers can be randomly read/written by the state machine, but are completely inaccessible to the processor. Setting this bit will clear the FJOIN_TX and FJOIN_RX bits.
	AUTOPUSH     SM3_SHIFTCTRL = 0x01 << 16 //+ Push automatically when the input shift register is filled, i.e. on an IN instruction which causes the input shift counter to reach or exceed PUSH_THRESH.
	AUTOPULL     SM3_SHIFTCTRL = 0x01 << 17 //+ Pull automatically when the output shift register is emptied, i.e. on or following an OUT instruction which causes the output shift counter to reach or exceed PULL_THRESH.
	IN_SHIFTDIR  SM3_SHIFTCTRL = 0x01 << 18 //+ 1 = shift input shift register to right (data enters from left). 0 = to left.
	OUT_SHIFTDIR SM3_SHIFTCTRL = 0x01 << 19 //+ 1 = shift out of output shift register to right. 0 = to left.
	PUSH_THRESH  SM3_SHIFTCTRL = 0x1F << 20 //+ Number of bits shifted into ISR before autopush, or conditional push (PUSH IFFULL), will take place. Write 0 for value of 32.
	PULL_THRESH  SM3_SHIFTCTRL = 0x1F << 25 //+ Number of bits shifted out of OSR before autopull, or conditional pull (PULL IFEMPTY), will take place. Write 0 for value of 32.
	FJOIN_TX     SM3_SHIFTCTRL = 0x01 << 30 //+ When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep. RX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
	FJOIN_RX     SM3_SHIFTCTRL = 0x01 << 31 //+ When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep. TX FIFO is disabled as a result (always reads as both full and empty). FIFOs are flushed when this bit is changed.
)

const (
	IN_COUNTn     = 0
	FJOIN_RX_GETn = 14
	FJOIN_RX_PUTn = 15
	AUTOPUSHn     = 16
	AUTOPULLn     = 17
	IN_SHIFTDIRn  = 18
	OUT_SHIFTDIRn = 19
	PUSH_THRESHn  = 20
	PULL_THRESHn  = 25
	FJOIN_TXn     = 30
	FJOIN_RXn     = 31
)

const (
	OUT_BASE      SM3_PINCTRL = 0x1F << 0  //+ The lowest-numbered pin that will be affected by an OUT PINS, OUT PINDIRS or MOV PINS instruction. The data written to this pin will always be the least-significant bit of the OUT or MOV data.
	SET_BASE      SM3_PINCTRL = 0x1F << 5  //+ The lowest-numbered pin that will be affected by a SET PINS or SET PINDIRS instruction. The data written to this pin is the least-significant bit of the SET data.
	SIDESET_BASE  SM3_PINCTRL = 0x1F << 10 //+ The lowest-numbered pin that will be affected by a side-set operation. The MSBs of an instruction's side-set/delay field (up to 5, determined by SIDESET_COUNT) are used for side-set data, with the remaining LSBs used for delay. The least-significant bit of the side-set portion is the bit written to this pin, with more-significant bits written to higher-numbered pins.
	IN_BASE       SM3_PINCTRL = 0x1F << 15 //+ The pin which is mapped to the least-significant bit of a state machine's IN data bus. Higher-numbered pins are mapped to consecutively more-significant data bits, with a modulo of 32 applied to pin number.
	OUT_COUNT     SM3_PINCTRL = 0x3F << 20 //+ The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS instruction. In the range 0 to 32 inclusive.
	SET_COUNT     SM3_PINCTRL = 0x07 << 26 //+ The number of pins asserted by a SET. In the range 0 to 5 inclusive.
	SIDESET_COUNT SM3_PINCTRL = 0x07 << 29 //+ The number of MSBs of the Delay/Side-set instruction field which are used for side-set. Inclusive of the enable bit, if present. Minimum of 0 (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
)

const (
	OUT_BASEn      = 0
	SET_BASEn      = 5
	SIDESET_BASEn  = 10
	IN_BASEn       = 15
	OUT_COUNTn     = 20
	SET_COUNTn     = 26
	SIDESET_COUNTn = 29
)

const (
	GPIOBASE GPIOBASE = 0x01 << 4 //+
)

const (
	GPIOBASEn = 4
)

const (
	SM0_RXNEMPTY INTR = 0x01 << 0  //+
	SM1_RXNEMPTY INTR = 0x01 << 1  //+
	SM2_RXNEMPTY INTR = 0x01 << 2  //+
	SM3_RXNEMPTY INTR = 0x01 << 3  //+
	SM0_TXNFULL  INTR = 0x01 << 4  //+
	SM1_TXNFULL  INTR = 0x01 << 5  //+
	SM2_TXNFULL  INTR = 0x01 << 6  //+
	SM3_TXNFULL  INTR = 0x01 << 7  //+
	SM0          INTR = 0x01 << 8  //+
	SM1          INTR = 0x01 << 9  //+
	SM2          INTR = 0x01 << 10 //+
	SM3          INTR = 0x01 << 11 //+
	SM4          INTR = 0x01 << 12 //+
	SM5          INTR = 0x01 << 13 //+
	SM6          INTR = 0x01 << 14 //+
	SM7          INTR = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)

const (
	SM0_RXNEMPTY IRQ0_INTE = 0x01 << 0  //+
	SM1_RXNEMPTY IRQ0_INTE = 0x01 << 1  //+
	SM2_RXNEMPTY IRQ0_INTE = 0x01 << 2  //+
	SM3_RXNEMPTY IRQ0_INTE = 0x01 << 3  //+
	SM0_TXNFULL  IRQ0_INTE = 0x01 << 4  //+
	SM1_TXNFULL  IRQ0_INTE = 0x01 << 5  //+
	SM2_TXNFULL  IRQ0_INTE = 0x01 << 6  //+
	SM3_TXNFULL  IRQ0_INTE = 0x01 << 7  //+
	SM0          IRQ0_INTE = 0x01 << 8  //+
	SM1          IRQ0_INTE = 0x01 << 9  //+
	SM2          IRQ0_INTE = 0x01 << 10 //+
	SM3          IRQ0_INTE = 0x01 << 11 //+
	SM4          IRQ0_INTE = 0x01 << 12 //+
	SM5          IRQ0_INTE = 0x01 << 13 //+
	SM6          IRQ0_INTE = 0x01 << 14 //+
	SM7          IRQ0_INTE = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)

const (
	SM0_RXNEMPTY IRQ0_INTF = 0x01 << 0  //+
	SM1_RXNEMPTY IRQ0_INTF = 0x01 << 1  //+
	SM2_RXNEMPTY IRQ0_INTF = 0x01 << 2  //+
	SM3_RXNEMPTY IRQ0_INTF = 0x01 << 3  //+
	SM0_TXNFULL  IRQ0_INTF = 0x01 << 4  //+
	SM1_TXNFULL  IRQ0_INTF = 0x01 << 5  //+
	SM2_TXNFULL  IRQ0_INTF = 0x01 << 6  //+
	SM3_TXNFULL  IRQ0_INTF = 0x01 << 7  //+
	SM0          IRQ0_INTF = 0x01 << 8  //+
	SM1          IRQ0_INTF = 0x01 << 9  //+
	SM2          IRQ0_INTF = 0x01 << 10 //+
	SM3          IRQ0_INTF = 0x01 << 11 //+
	SM4          IRQ0_INTF = 0x01 << 12 //+
	SM5          IRQ0_INTF = 0x01 << 13 //+
	SM6          IRQ0_INTF = 0x01 << 14 //+
	SM7          IRQ0_INTF = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)

const (
	SM0_RXNEMPTY IRQ0_INTS = 0x01 << 0  //+
	SM1_RXNEMPTY IRQ0_INTS = 0x01 << 1  //+
	SM2_RXNEMPTY IRQ0_INTS = 0x01 << 2  //+
	SM3_RXNEMPTY IRQ0_INTS = 0x01 << 3  //+
	SM0_TXNFULL  IRQ0_INTS = 0x01 << 4  //+
	SM1_TXNFULL  IRQ0_INTS = 0x01 << 5  //+
	SM2_TXNFULL  IRQ0_INTS = 0x01 << 6  //+
	SM3_TXNFULL  IRQ0_INTS = 0x01 << 7  //+
	SM0          IRQ0_INTS = 0x01 << 8  //+
	SM1          IRQ0_INTS = 0x01 << 9  //+
	SM2          IRQ0_INTS = 0x01 << 10 //+
	SM3          IRQ0_INTS = 0x01 << 11 //+
	SM4          IRQ0_INTS = 0x01 << 12 //+
	SM5          IRQ0_INTS = 0x01 << 13 //+
	SM6          IRQ0_INTS = 0x01 << 14 //+
	SM7          IRQ0_INTS = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)

const (
	SM0_RXNEMPTY IRQ1_INTE = 0x01 << 0  //+
	SM1_RXNEMPTY IRQ1_INTE = 0x01 << 1  //+
	SM2_RXNEMPTY IRQ1_INTE = 0x01 << 2  //+
	SM3_RXNEMPTY IRQ1_INTE = 0x01 << 3  //+
	SM0_TXNFULL  IRQ1_INTE = 0x01 << 4  //+
	SM1_TXNFULL  IRQ1_INTE = 0x01 << 5  //+
	SM2_TXNFULL  IRQ1_INTE = 0x01 << 6  //+
	SM3_TXNFULL  IRQ1_INTE = 0x01 << 7  //+
	SM0          IRQ1_INTE = 0x01 << 8  //+
	SM1          IRQ1_INTE = 0x01 << 9  //+
	SM2          IRQ1_INTE = 0x01 << 10 //+
	SM3          IRQ1_INTE = 0x01 << 11 //+
	SM4          IRQ1_INTE = 0x01 << 12 //+
	SM5          IRQ1_INTE = 0x01 << 13 //+
	SM6          IRQ1_INTE = 0x01 << 14 //+
	SM7          IRQ1_INTE = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)

const (
	SM0_RXNEMPTY IRQ1_INTF = 0x01 << 0  //+
	SM1_RXNEMPTY IRQ1_INTF = 0x01 << 1  //+
	SM2_RXNEMPTY IRQ1_INTF = 0x01 << 2  //+
	SM3_RXNEMPTY IRQ1_INTF = 0x01 << 3  //+
	SM0_TXNFULL  IRQ1_INTF = 0x01 << 4  //+
	SM1_TXNFULL  IRQ1_INTF = 0x01 << 5  //+
	SM2_TXNFULL  IRQ1_INTF = 0x01 << 6  //+
	SM3_TXNFULL  IRQ1_INTF = 0x01 << 7  //+
	SM0          IRQ1_INTF = 0x01 << 8  //+
	SM1          IRQ1_INTF = 0x01 << 9  //+
	SM2          IRQ1_INTF = 0x01 << 10 //+
	SM3          IRQ1_INTF = 0x01 << 11 //+
	SM4          IRQ1_INTF = 0x01 << 12 //+
	SM5          IRQ1_INTF = 0x01 << 13 //+
	SM6          IRQ1_INTF = 0x01 << 14 //+
	SM7          IRQ1_INTF = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)

const (
	SM0_RXNEMPTY IRQ1_INTS = 0x01 << 0  //+
	SM1_RXNEMPTY IRQ1_INTS = 0x01 << 1  //+
	SM2_RXNEMPTY IRQ1_INTS = 0x01 << 2  //+
	SM3_RXNEMPTY IRQ1_INTS = 0x01 << 3  //+
	SM0_TXNFULL  IRQ1_INTS = 0x01 << 4  //+
	SM1_TXNFULL  IRQ1_INTS = 0x01 << 5  //+
	SM2_TXNFULL  IRQ1_INTS = 0x01 << 6  //+
	SM3_TXNFULL  IRQ1_INTS = 0x01 << 7  //+
	SM0          IRQ1_INTS = 0x01 << 8  //+
	SM1          IRQ1_INTS = 0x01 << 9  //+
	SM2          IRQ1_INTS = 0x01 << 10 //+
	SM3          IRQ1_INTS = 0x01 << 11 //+
	SM4          IRQ1_INTS = 0x01 << 12 //+
	SM5          IRQ1_INTS = 0x01 << 13 //+
	SM6          IRQ1_INTS = 0x01 << 14 //+
	SM7          IRQ1_INTS = 0x01 << 15 //+
)

const (
	SM0_RXNEMPTYn = 0
	SM1_RXNEMPTYn = 1
	SM2_RXNEMPTYn = 2
	SM3_RXNEMPTYn = 3
	SM0_TXNFULLn  = 4
	SM1_TXNFULLn  = 5
	SM2_TXNFULLn  = 6
	SM3_TXNFULLn  = 7
	SM0n          = 8
	SM1n          = 9
	SM2n          = 10
	SM3n          = 11
	SM4n          = 12
	SM5n          = 13
	SM6n          = 14
	SM7n          = 15
)
