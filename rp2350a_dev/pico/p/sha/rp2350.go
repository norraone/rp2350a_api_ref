// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package sha provides access to the registers of the SHA peripheral.
//
// Instances:
//
//	SHA256  SHA256_BASE  -  -  SHA-256 hash function implementation
//
// Registers:
//
//	0x000 32  CSR    Control and status register
//	0x004 32  WDATA  Write data register
//	0x008 32  SUM0   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x00C 32  SUM1   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x010 32  SUM2   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x014 32  SUM3   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x018 32  SUM4   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x01C 32  SUM5   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x020 32  SUM6   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//	0x024 32  SUM7   256-bit checksum result. Contents are undefined when CSR_SUM_VLD is 0.
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package sha

const (
	START             CSR = 0x01 << 0  //+ Write 1 to prepare the SHA-256 core for a new checksum. The SUMx registers are initialised to the proper values (fractional bits of square roots of first 8 primes) and internal counters are cleared. This immediately forces WDATA_RDY and SUM_VLD high. START must be written before initiating a DMA transfer to the SHA-256 core, because the core will always request 16 transfers at a time (1 512-bit block). Additionally, the DMA channel should be configured for a multiple of 16 32-bit transfers.
	WDATA_RDY         CSR = 0x01 << 1  //+ If 1, the SHA-256 core is ready to accept more data through the WDATA register. After writing 16 words, this flag will go low for 57 cycles whilst the core completes its digest.
	SUM_VLD           CSR = 0x01 << 2  //+ If 1, the SHA-256 checksum presented in registers SUM0 through SUM7 is currently valid. Goes low when WDATA is first written, then returns high once 16 words have been written and the digest of the current 512-bit block has subsequently completed.
	ERR_WDATA_NOT_RDY CSR = 0x01 << 4  //+ Set when a write occurs whilst the SHA-256 core is not ready for data (WDATA_RDY is low). Write one to clear.
	DMA_SIZE          CSR = 0x03 << 8  //+ Configure DREQ logic for the correct DMA data size. Must be configured before the DMA channel is triggered. The SHA-256 core's DREQ logic requests one entire block of data at once, since there is no FIFO, and data goes straight into the core's message schedule and digest hardware. Therefore, when transferring data with DMA, CSR_DMA_SIZE must be configured in advance so that the correct number of transfers can be requested per block.
	BSWAP             CSR = 0x01 << 12 //+ Enable byte swapping of 32-bit values at the point they are committed to the SHA message scheduler. This block's bus interface assembles byte/halfword data into message words in little-endian order, so that DMAing the same buffer with different transfer sizes always gives the same result on a little-endian system like RP2350. However, when marshalling bytes into blocks, SHA expects that the first byte is the *most significant* in each message word. To resolve this, once the bus interface has accumulated 32 bits of data (either a word write, two halfword writes in little-endian order, or four byte writes in little-endian order) the final value can be byte-swapped before passing to the actual SHA core. This feature is enabled by default because using the SHA core to checksum byte buffers is expected to be more common than having preformatted SHA message words lying around.
)

const (
	STARTn             = 0
	WDATA_RDYn         = 1
	SUM_VLDn           = 2
	ERR_WDATA_NOT_RDYn = 4
	DMA_SIZEn          = 8
	BSWAPn             = 12
)
