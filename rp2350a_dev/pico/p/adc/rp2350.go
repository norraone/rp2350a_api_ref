// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package adc provides access to the registers of the ADC peripheral.
//
// Instances:
//
//	ADC  ADC_BASE  -  ADC_FIFO  Control and data interface to SAR ADC
//
// Registers:
//
//	0x000 32  CS      ADC Control and Status
//	0x004 32  RESULT  Result of most recent ADC conversion
//	0x008 32  FCS     FIFO control and status
//	0x00C 32  FIFO    Conversion result FIFO
//	0x010 32  DIV     Clock divider. If non-zero, CS_START_MANY will start conversions at regular intervals rather than back-to-back. The divider is reset when either of these fields are written. Total period is 1 + INT + FRAC / 256
//	0x014 32  INTR    Raw Interrupts
//	0x018 32  INTE    Interrupt Enable
//	0x01C 32  INTF    Interrupt Force
//	0x020 32  INTS    Interrupt status after masking & forcing
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package adc

const (
	EN         CS = 0x01 << 0   //+ Power on ADC and enable its clock. 1 - enabled. 0 - disabled.
	TS_EN      CS = 0x01 << 1   //+ Power on temperature sensor. 1 - enabled. 0 - disabled.
	START_ONCE CS = 0x01 << 2   //+ Start a single conversion. Self-clearing. Ignored if start_many is asserted.
	START_MANY CS = 0x01 << 3   //+ Continuously perform conversions whilst this bit is 1. A new conversion will start immediately after the previous finishes.
	READY      CS = 0x01 << 8   //+ 1 if the ADC is ready to start a new conversion. Implies any previous conversion has completed. 0 whilst conversion in progress.
	ERR        CS = 0x01 << 9   //+ The most recent ADC conversion encountered an error; result is undefined or noisy.
	ERR_STICKY CS = 0x01 << 10  //+ Some past ADC conversion encountered an error. Write 1 to clear.
	AINSEL     CS = 0x0F << 12  //+ Select analog mux input. Updated automatically in round-robin mode. This is corrected for the package option so only ADC channels which are bonded are available, and in the correct order
	RROBIN     CS = 0x1FF << 16 //+ Round-robin sampling. 1 bit per channel. Set all bits to 0 to disable. Otherwise, the ADC will cycle through each enabled channel in a round-robin fashion. The first channel to be sampled will be the one currently indicated by AINSEL. AINSEL will be updated after each conversion with the newly-selected channel.
)

const (
	ENn         = 0
	TS_ENn      = 1
	START_ONCEn = 2
	START_MANYn = 3
	READYn      = 8
	ERRn        = 9
	ERR_STICKYn = 10
	AINSELn     = 12
	RROBINn     = 16
)

const (
	EN      FCS = 0x01 << 0  //+ If 1: write result to the FIFO after each conversion.
	SHIFT   FCS = 0x01 << 1  //+ If 1: FIFO results are right-shifted to be one byte in size. Enables DMA to byte buffers.
	ERR     FCS = 0x01 << 2  //+ If 1: conversion error bit appears in the FIFO alongside the result
	DREQ_EN FCS = 0x01 << 3  //+ If 1: assert DMA requests when FIFO contains data
	EMPTY   FCS = 0x01 << 8  //+
	FULL    FCS = 0x01 << 9  //+
	UNDER   FCS = 0x01 << 10 //+ 1 if the FIFO has been underflowed. Write 1 to clear.
	OVER    FCS = 0x01 << 11 //+ 1 if the FIFO has been overflowed. Write 1 to clear.
	LEVEL   FCS = 0x0F << 16 //+ The number of conversion results currently waiting in the FIFO
	THRESH  FCS = 0x0F << 24 //+ DREQ/IRQ asserted when level >= threshold
)

const (
	ENn      = 0
	SHIFTn   = 1
	ERRn     = 2
	DREQ_ENn = 3
	EMPTYn   = 8
	FULLn    = 9
	UNDERn   = 10
	OVERn    = 11
	LEVELn   = 16
	THRESHn  = 24
)

const (
	VAL FIFO = 0xFFF << 0 //+
	ERR FIFO = 0x01 << 15 //+ 1 if this particular sample experienced a conversion error. Remains in the same location if the sample is shifted.
)

const (
	VALn = 0
	ERRn = 15
)

const (
	FRAC DIV = 0xFF << 0   //+ Fractional part of clock divisor. First-order delta-sigma.
	INT  DIV = 0xFFFF << 8 //+ Integer part of clock divisor.
)

const (
	FRACn = 0
	INTn  = 8
)
