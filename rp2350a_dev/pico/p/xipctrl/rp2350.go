// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package xipctrl provides access to the registers of the XIP_CTRL peripheral.
//
// Instances:
//
//	XIP_CTRL  XIP_CTRL_BASE  -  -  QSPI flash execute-in-place block
//
// Registers:
//
//	0x000 32  CTRL         Cache control register. Read-only from a Non-secure context.
//	0x008 32  STAT
//	0x00C 32  CTR_HIT      Cache Hit counter
//	0x010 32  CTR_ACC      Cache Access counter
//	0x014 32  STREAM_ADDR  FIFO stream address
//	0x018 32  STREAM_CTR   FIFO stream control
//	0x01C 32  STREAM_FIFO  FIFO stream data
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package xipctrl

const (
	EN_SECURE              CTRL = 0x01 << 0  //+ When 1, enable the cache for Secure accesses. When enabled, Secure XIP accesses to the cached (addr[26] == 0) window will query the cache, and QSPI accesses are performed only if the requested data is not present. When disabled, Secure access ignore the cache contents, and always access the QSPI interface. Accesses to the uncached (addr[26] == 1) window will never query the cache, irrespective of this bit. There is no cache-as-SRAM address window. Cache lines are allocated for SRAM-like use by individually pinning them, and keeping the cache enabled.
	EN_NONSECURE           CTRL = 0x01 << 1  //+ When 1, enable the cache for Non-secure accesses. When enabled, Non-secure XIP accesses to the cached (addr[26] == 0) window will query the cache, and QSPI accesses are performed only if the requested data is not present. When disabled, Secure access ignore the cache contents, and always access the QSPI interface. Accesses to the uncached (addr[26] == 1) window will never query the cache, irrespective of this bit.
	POWER_DOWN             CTRL = 0x01 << 3  //+ When 1, the cache memories are powered down. They retain state, but can not be accessed. This reduces static power dissipation. Writing 1 to this bit forces CTRL_EN_SECURE and CTRL_EN_NONSECURE to 0, i.e. the cache cannot be enabled when powered down.
	NO_UNCACHED_SEC        CTRL = 0x01 << 4  //+ When 1, Secure accesses to the uncached window (addr[27:26] == 1) will generate a bus error. This may reduce the number of SAU/MPU/PMP regions required to protect flash contents. Note this does not disable access to the uncached, untranslated window -- see NO_UNTRANSLATED_SEC.
	NO_UNCACHED_NONSEC     CTRL = 0x01 << 5  //+ When 1, Non-secure accesses to the uncached window (addr[27:26] == 1) will generate a bus error. This may reduce the number of SAU/MPU/PMP regions required to protect flash contents. Note this does not disable access to the uncached, untranslated window -- see NO_UNTRANSLATED_SEC.
	NO_UNTRANSLATED_SEC    CTRL = 0x01 << 6  //+ When 1, Secure accesses to the uncached, untranslated window (addr[27:26] == 3) will generate a bus error.
	NO_UNTRANSLATED_NONSEC CTRL = 0x01 << 7  //+ When 1, Non-secure accesses to the uncached, untranslated window (addr[27:26] == 3) will generate a bus error.
	MAINT_NONSEC           CTRL = 0x01 << 8  //+ When 0, Non-secure accesses to the cache maintenance address window (addr[27] == 1, addr[26] == 0) will generate a bus error. When 1, Non-secure accesses can perform cache maintenance operations by writing to the cache maintenance address window. Cache maintenance operations may be used to corrupt Secure data by invalidating cache lines inappropriately, or map Secure content into a Non-secure region by pinning cache lines. Therefore this bit should generally be set to 0, unless Secure code is not using the cache. Care should also be taken to clear the cache data memory and tag memory before granting maintenance operations to Non-secure code.
	SPLIT_WAYS             CTRL = 0x01 << 9  //+ When 1, route all cached+Secure accesses to way 0 of the cache, and route all cached+Non-secure accesses to way 1 of the cache. This partitions the cache into two half-sized direct-mapped regions, such that Non-secure code can not observe cache line state changes caused by Secure execution. A full cache flush is required when changing the value of SPLIT_WAYS. The flush should be performed whilst SPLIT_WAYS is 0, so that both cache ways are accessible for invalidation.
	WRITABLE_M0            CTRL = 0x01 << 10 //+ If 1, enable writes to XIP memory window 0 (addresses 0x10000000 through 0x10ffffff, and their uncached mirrors). If 0, this region is read-only. XIP memory is *read-only by default*. This bit must be set to enable writes if a RAM device is attached on QSPI chip select 0. The default read-only behaviour avoids two issues with writing to a read-only QSPI device (e.g. flash). First, a write will initially appear to succeed due to caching, but the data will eventually be lost when the written line is evicted, causing unpredictable behaviour. Second, when a written line is evicted, it will cause a write command to be issued to the flash, which can break the flash out of its continuous read mode. After this point, flash reads will return garbage. This is a security concern, as it allows Non-secure software to break Secure flash reads if it has permission to write to any flash address. Note the read-only behaviour is implemented by downgrading writes to reads, so writes will still cause allocation of an address, but have no other effect.
	WRITABLE_M1            CTRL = 0x01 << 11 //+ If 1, enable writes to XIP memory window 1 (addresses 0x11000000 through 0x11ffffff, and their uncached mirrors). If 0, this region is read-only. XIP memory is *read-only by default*. This bit must be set to enable writes if a RAM device is attached on QSPI chip select 1. The default read-only behaviour avoids two issues with writing to a read-only QSPI device (e.g. flash). First, a write will initially appear to succeed due to caching, but the data will eventually be lost when the written line is evicted, causing unpredictable behaviour. Second, when a written line is evicted, it will cause a write command to be issued to the flash, which can break the flash out of its continuous read mode. After this point, flash reads will return garbage. This is a security concern, as it allows Non-secure software to break Secure flash reads if it has permission to write to any flash address. Note the read-only behaviour is implemented by downgrading writes to reads, so writes will still cause allocation of an address, but have no other effect.
)

const (
	EN_SECUREn              = 0
	EN_NONSECUREn           = 1
	POWER_DOWNn             = 3
	NO_UNCACHED_SECn        = 4
	NO_UNCACHED_NONSECn     = 5
	NO_UNTRANSLATED_SECn    = 6
	NO_UNTRANSLATED_NONSECn = 7
	MAINT_NONSECn           = 8
	SPLIT_WAYSn             = 9
	WRITABLE_M0n            = 10
	WRITABLE_M1n            = 11
)

const (
	FIFO_EMPTY STAT = 0x01 << 1 //+ When 1, indicates the XIP streaming FIFO is completely empty.
	FIFO_FULL  STAT = 0x01 << 2 //+ When 1, indicates the XIP streaming FIFO is completely full. The streaming FIFO is 2 entries deep, so the full and empty flag allow its level to be ascertained.
)

const (
	FIFO_EMPTYn = 1
	FIFO_FULLn  = 2
)

const (
	STREAM_ADDR STREAM_ADDR = 0x3FFFFFFF << 2 //+ The address of the next word to be streamed from flash to the streaming FIFO. Increments automatically after each flash access. Write the initial access address here before starting a streaming read.
)

const (
	STREAM_ADDRn = 2
)
