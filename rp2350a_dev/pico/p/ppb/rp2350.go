// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package ppb provides access to the registers of the PPB peripheral.
//
// Instances:
//
//	PPB     PPB_BASE     -  -  TEAL registers accessible through the debug interface
//	PPB_NS  PPB_NS_BASE  -  -  TEAL registers accessible through the debug interface
//
// Registers:
//
//	0x000   32  ITM_STIM0         Provides the interface for generating Instrumentation packets
//	0x004   32  ITM_STIM1         Provides the interface for generating Instrumentation packets
//	0x008   32  ITM_STIM2         Provides the interface for generating Instrumentation packets
//	0x00C   32  ITM_STIM3         Provides the interface for generating Instrumentation packets
//	0x010   32  ITM_STIM4         Provides the interface for generating Instrumentation packets
//	0x014   32  ITM_STIM5         Provides the interface for generating Instrumentation packets
//	0x018   32  ITM_STIM6         Provides the interface for generating Instrumentation packets
//	0x01C   32  ITM_STIM7         Provides the interface for generating Instrumentation packets
//	0x020   32  ITM_STIM8         Provides the interface for generating Instrumentation packets
//	0x024   32  ITM_STIM9         Provides the interface for generating Instrumentation packets
//	0x028   32  ITM_STIM10        Provides the interface for generating Instrumentation packets
//	0x02C   32  ITM_STIM11        Provides the interface for generating Instrumentation packets
//	0x030   32  ITM_STIM12        Provides the interface for generating Instrumentation packets
//	0x034   32  ITM_STIM13        Provides the interface for generating Instrumentation packets
//	0x038   32  ITM_STIM14        Provides the interface for generating Instrumentation packets
//	0x03C   32  ITM_STIM15        Provides the interface for generating Instrumentation packets
//	0x040   32  ITM_STIM16        Provides the interface for generating Instrumentation packets
//	0x044   32  ITM_STIM17        Provides the interface for generating Instrumentation packets
//	0x048   32  ITM_STIM18        Provides the interface for generating Instrumentation packets
//	0x04C   32  ITM_STIM19        Provides the interface for generating Instrumentation packets
//	0x050   32  ITM_STIM20        Provides the interface for generating Instrumentation packets
//	0x054   32  ITM_STIM21        Provides the interface for generating Instrumentation packets
//	0x058   32  ITM_STIM22        Provides the interface for generating Instrumentation packets
//	0x05C   32  ITM_STIM23        Provides the interface for generating Instrumentation packets
//	0x060   32  ITM_STIM24        Provides the interface for generating Instrumentation packets
//	0x064   32  ITM_STIM25        Provides the interface for generating Instrumentation packets
//	0x068   32  ITM_STIM26        Provides the interface for generating Instrumentation packets
//	0x06C   32  ITM_STIM27        Provides the interface for generating Instrumentation packets
//	0x070   32  ITM_STIM28        Provides the interface for generating Instrumentation packets
//	0x074   32  ITM_STIM29        Provides the interface for generating Instrumentation packets
//	0x078   32  ITM_STIM30        Provides the interface for generating Instrumentation packets
//	0x07C   32  ITM_STIM31        Provides the interface for generating Instrumentation packets
//	0xE00   32  ITM_TER0          Provide an individual enable bit for each ITM_STIM register
//	0xE40   32  ITM_TPR           Controls which stimulus ports can be accessed by unprivileged code
//	0xE80   32  ITM_TCR           Configures and controls transfers through the ITM interface
//	0xEF0   32  INT_ATREADY       Integration Mode: Read ATB Ready
//	0xEF8   32  INT_ATVALID       Integration Mode: Write ATB Valid
//	0xF00   32  ITM_ITCTRL        Integration Mode Control Register
//	0xFBC   32  ITM_DEVARCH       Provides CoreSight discovery information for the ITM
//	0xFCC   32  ITM_DEVTYPE       Provides CoreSight discovery information for the ITM
//	0xFD0   32  ITM_PIDR4         Provides CoreSight discovery information for the ITM
//	0xFD4   32  ITM_PIDR5         Provides CoreSight discovery information for the ITM
//	0xFD8   32  ITM_PIDR6         Provides CoreSight discovery information for the ITM
//	0xFDC   32  ITM_PIDR7         Provides CoreSight discovery information for the ITM
//	0xFE0   32  ITM_PIDR0         Provides CoreSight discovery information for the ITM
//	0xFE4   32  ITM_PIDR1         Provides CoreSight discovery information for the ITM
//	0xFE8   32  ITM_PIDR2         Provides CoreSight discovery information for the ITM
//	0xFEC   32  ITM_PIDR3         Provides CoreSight discovery information for the ITM
//	0xFF0   32  ITM_CIDR0         Provides CoreSight discovery information for the ITM
//	0xFF4   32  ITM_CIDR1         Provides CoreSight discovery information for the ITM
//	0xFF8   32  ITM_CIDR2         Provides CoreSight discovery information for the ITM
//	0xFFC   32  ITM_CIDR3         Provides CoreSight discovery information for the ITM
//	0x1000  32  DWT_CTRL          Provides configuration and status information for the DWT unit, and used to control features of the unit
//	0x1004  32  DWT_CYCCNT        Shows or sets the value of the processor cycle counter, CYCCNT
//	0x100C  32  DWT_EXCCNT        Counts the total cycles spent in exception processing
//	0x1014  32  DWT_LSUCNT        Increments on the additional cycles required to execute all load or store instructions
//	0x1018  32  DWT_FOLDCNT       Increments on the additional cycles required to execute all load or store instructions
//	0x1020  32  DWT_COMP0         Provides a reference value for use by watchpoint comparator 0
//	0x1028  32  DWT_FUNCTION0     Controls the operation of watchpoint comparator 0
//	0x1030  32  DWT_COMP1         Provides a reference value for use by watchpoint comparator 1
//	0x1038  32  DWT_FUNCTION1     Controls the operation of watchpoint comparator 1
//	0x1040  32  DWT_COMP2         Provides a reference value for use by watchpoint comparator 2
//	0x1048  32  DWT_FUNCTION2     Controls the operation of watchpoint comparator 2
//	0x1050  32  DWT_COMP3         Provides a reference value for use by watchpoint comparator 3
//	0x1058  32  DWT_FUNCTION3     Controls the operation of watchpoint comparator 3
//	0x1FBC  32  DWT_DEVARCH       Provides CoreSight discovery information for the DWT
//	0x1FCC  32  DWT_DEVTYPE       Provides CoreSight discovery information for the DWT
//	0x1FD0  32  DWT_PIDR4         Provides CoreSight discovery information for the DWT
//	0x1FD4  32  DWT_PIDR5         Provides CoreSight discovery information for the DWT
//	0x1FD8  32  DWT_PIDR6         Provides CoreSight discovery information for the DWT
//	0x1FDC  32  DWT_PIDR7         Provides CoreSight discovery information for the DWT
//	0x1FE0  32  DWT_PIDR0         Provides CoreSight discovery information for the DWT
//	0x1FE4  32  DWT_PIDR1         Provides CoreSight discovery information for the DWT
//	0x1FE8  32  DWT_PIDR2         Provides CoreSight discovery information for the DWT
//	0x1FEC  32  DWT_PIDR3         Provides CoreSight discovery information for the DWT
//	0x1FF0  32  DWT_CIDR0         Provides CoreSight discovery information for the DWT
//	0x1FF4  32  DWT_CIDR1         Provides CoreSight discovery information for the DWT
//	0x1FF8  32  DWT_CIDR2         Provides CoreSight discovery information for the DWT
//	0x1FFC  32  DWT_CIDR3         Provides CoreSight discovery information for the DWT
//	0x2000  32  FP_CTRL           Provides FPB implementation information, and the global enable for the FPB unit
//	0x2004  32  FP_REMAP          Indicates whether the implementation supports Flash Patch remap and, if it does, holds the target address for remap
//	0x2008  32  FP_COMP0          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x200C  32  FP_COMP1          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x2010  32  FP_COMP2          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x2014  32  FP_COMP3          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x2018  32  FP_COMP4          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x201C  32  FP_COMP5          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x2020  32  FP_COMP6          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x2024  32  FP_COMP7          Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether the comparator is an instruction address comparator or a literal address comparator
//	0x2FBC  32  FP_DEVARCH        Provides CoreSight discovery information for the FPB
//	0x2FCC  32  FP_DEVTYPE        Provides CoreSight discovery information for the FPB
//	0x2FD0  32  FP_PIDR4          Provides CoreSight discovery information for the FP
//	0x2FD4  32  FP_PIDR5          Provides CoreSight discovery information for the FP
//	0x2FD8  32  FP_PIDR6          Provides CoreSight discovery information for the FP
//	0x2FDC  32  FP_PIDR7          Provides CoreSight discovery information for the FP
//	0x2FE0  32  FP_PIDR0          Provides CoreSight discovery information for the FP
//	0x2FE4  32  FP_PIDR1          Provides CoreSight discovery information for the FP
//	0x2FE8  32  FP_PIDR2          Provides CoreSight discovery information for the FP
//	0x2FEC  32  FP_PIDR3          Provides CoreSight discovery information for the FP
//	0x2FF0  32  FP_CIDR0          Provides CoreSight discovery information for the FP
//	0x2FF4  32  FP_CIDR1          Provides CoreSight discovery information for the FP
//	0x2FF8  32  FP_CIDR2          Provides CoreSight discovery information for the FP
//	0x2FFC  32  FP_CIDR3          Provides CoreSight discovery information for the FP
//	0xE004  32  ICTR              Provides information about the interrupt controller
//	0xE008  32  ACTLR             Provides IMPLEMENTATION DEFINED configuration and control options
//	0xE010  32  SYST_CSR          Use the SysTick Control and Status Register to enable the SysTick features.
//	0xE014  32  SYST_RVR          Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN. To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
//	0xE018  32  SYST_CVR          Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN.
//	0xE01C  32  SYST_CALIB        Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply.
//	0xE100  32  NVIC_ISER0        Enables or reads the enabled state of each group of 32 interrupts
//	0xE104  32  NVIC_ISER1        Enables or reads the enabled state of each group of 32 interrupts
//	0xE180  32  NVIC_ICER0        Clears or reads the enabled state of each group of 32 interrupts
//	0xE184  32  NVIC_ICER1        Clears or reads the enabled state of each group of 32 interrupts
//	0xE200  32  NVIC_ISPR0        Enables or reads the pending state of each group of 32 interrupts
//	0xE204  32  NVIC_ISPR1        Enables or reads the pending state of each group of 32 interrupts
//	0xE280  32  NVIC_ICPR0        Clears or reads the pending state of each group of 32 interrupts
//	0xE284  32  NVIC_ICPR1        Clears or reads the pending state of each group of 32 interrupts
//	0xE300  32  NVIC_IABR0        For each group of 32 interrupts, shows the active state of each interrupt
//	0xE304  32  NVIC_IABR1        For each group of 32 interrupts, shows the active state of each interrupt
//	0xE380  32  NVIC_ITNS0        For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
//	0xE384  32  NVIC_ITNS1        For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
//	0xE400  32  NVIC_IPR0         Sets or reads interrupt priorities
//	0xE404  32  NVIC_IPR1         Sets or reads interrupt priorities
//	0xE408  32  NVIC_IPR2         Sets or reads interrupt priorities
//	0xE40C  32  NVIC_IPR3         Sets or reads interrupt priorities
//	0xE410  32  NVIC_IPR4         Sets or reads interrupt priorities
//	0xE414  32  NVIC_IPR5         Sets or reads interrupt priorities
//	0xE418  32  NVIC_IPR6         Sets or reads interrupt priorities
//	0xE41C  32  NVIC_IPR7         Sets or reads interrupt priorities
//	0xE420  32  NVIC_IPR8         Sets or reads interrupt priorities
//	0xE424  32  NVIC_IPR9         Sets or reads interrupt priorities
//	0xE428  32  NVIC_IPR10        Sets or reads interrupt priorities
//	0xE42C  32  NVIC_IPR11        Sets or reads interrupt priorities
//	0xE430  32  NVIC_IPR12        Sets or reads interrupt priorities
//	0xE434  32  NVIC_IPR13        Sets or reads interrupt priorities
//	0xE438  32  NVIC_IPR14        Sets or reads interrupt priorities
//	0xE43C  32  NVIC_IPR15        Sets or reads interrupt priorities
//	0xED00  32  CPUID             Provides identification information for the PE, including an implementer code for the device and a device ID number
//	0xED04  32  ICSR              Controls and provides status information for NMI, PendSV, SysTick and interrupts
//	0xED08  32  VTOR              The VTOR indicates the offset of the vector table base address from memory address 0x00000000.
//	0xED0C  32  AIRCR             Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset.
//	0xED10  32  SCR               System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states.
//	0xED14  32  CCR               Sets or returns configuration and control data
//	0xED18  32  SHPR1             Sets or returns priority for system handlers 4 - 7
//	0xED1C  32  SHPR2             Sets or returns priority for system handlers 8 - 11
//	0xED20  32  SHPR3             Sets or returns priority for system handlers 12 - 15
//	0xED24  32  SHCSR             Provides access to the active and pending status of system exceptions
//	0xED28  32  CFSR              Contains the three Configurable Fault Status Registers. 31:16 UFSR: Provides information on UsageFault exceptions 15:8 BFSR: Provides information on BusFault exceptions 7:0 MMFSR: Provides information on MemManage exceptions
//	0xED2C  32  HFSR              Shows the cause of any HardFaults
//	0xED30  32  DFSR              Shows which debug event occurred
//	0xED34  32  MMFAR             Shows the address of the memory location that caused an MPU fault
//	0xED38  32  BFAR              Shows the address associated with a precise data access BusFault
//	0xED40  32  ID_PFR0           Gives top-level information about the instruction set supported by the PE
//	0xED44  32  ID_PFR1           Gives information about the programmers' model and Extensions support
//	0xED48  32  ID_DFR0           Provides top level information about the debug system
//	0xED4C  32  ID_AFR0           Provides information about the IMPLEMENTATION DEFINED features of the PE
//	0xED50  32  ID_MMFR0          Provides information about the implemented memory model and memory management support
//	0xED54  32  ID_MMFR1          Provides information about the implemented memory model and memory management support
//	0xED58  32  ID_MMFR2          Provides information about the implemented memory model and memory management support
//	0xED5C  32  ID_MMFR3          Provides information about the implemented memory model and memory management support
//	0xED60  32  ID_ISAR0          Provides information about the instruction set implemented by the PE
//	0xED64  32  ID_ISAR1          Provides information about the instruction set implemented by the PE
//	0xED68  32  ID_ISAR2          Provides information about the instruction set implemented by the PE
//	0xED6C  32  ID_ISAR3          Provides information about the instruction set implemented by the PE
//	0xED70  32  ID_ISAR4          Provides information about the instruction set implemented by the PE
//	0xED74  32  ID_ISAR5          Provides information about the instruction set implemented by the PE
//	0xED7C  32  CTR               Provides information about the architecture of the caches. CTR is RES0 if CLIDR is zero.
//	0xED88  32  CPACR             Specifies the access privileges for coprocessors and the FP Extension
//	0xED8C  32  NSACR             Defines the Non-secure access permissions for both the FP Extension and coprocessors CP0 to CP7
//	0xED90  32  MPU_TYPE          The MPU Type Register indicates how many regions the MPU `FTSSS supports
//	0xED94  32  MPU_CTRL          Enables the MPU and, when the MPU is enabled, controls whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1
//	0xED98  32  MPU_RNR           Selects the region currently accessed by MPU_RBAR and MPU_RLAR
//	0xED9C  32  MPU_RBAR          Provides indirect read and write access to the base address of the currently selected MPU region `FTSSS
//	0xEDA0  32  MPU_RLAR          Provides indirect read and write access to the limit address of the currently selected MPU region `FTSSS
//	0xEDA4  32  MPU_RBAR_A1       Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
//	0xEDA8  32  MPU_RLAR_A1       Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
//	0xEDAC  32  MPU_RBAR_A2       Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
//	0xEDB0  32  MPU_RLAR_A2       Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
//	0xEDB4  32  MPU_RBAR_A3       Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
//	0xEDB8  32  MPU_RLAR_A3       Provides indirect read and write access to the limit address of the currently selected MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
//	0xEDC0  32  MPU_MAIR0         Along with MPU_MAIR1, provides the memory attribute encodings corresponding to the AttrIndex values
//	0xEDC4  32  MPU_MAIR1         Along with MPU_MAIR0, provides the memory attribute encodings corresponding to the AttrIndex values
//	0xEDD0  32  SAU_CTRL          Allows enabling of the Security Attribution Unit
//	0xEDD4  32  SAU_TYPE          Indicates the number of regions implemented by the Security Attribution Unit
//	0xEDD8  32  SAU_RNR           Selects the region currently accessed by SAU_RBAR and SAU_RLAR
//	0xEDDC  32  SAU_RBAR          Provides indirect read and write access to the base address of the currently selected SAU region
//	0xEDE0  32  SAU_RLAR          Provides indirect read and write access to the limit address of the currently selected SAU region
//	0xEDE4  32  SFSR              Provides information about any security related faults
//	0xEDE8  32  SFAR              Shows the address of the memory location that caused a Security violation
//	0xEDF0  32  DHCSR             Controls halting debug
//	0xEDF4  32  DCRSR             With the DCRDR, provides debug access to the general-purpose registers, special-purpose registers, and the FP extension registers. A write to the DCRSR specifies the register to transfer, whether the transfer is a read or write, and starts the transfer
//	0xEDF8  32  DCRDR             With the DCRSR, provides debug access to the general-purpose registers, special-purpose registers, and the FP Extension registers. If the Main Extension is implemented, it can also be used for message passing between an external debugger and a debug agent running on the PE
//	0xEDFC  32  DEMCR             Manages vector catch behavior and DebugMonitor handling when debugging
//	0xEE08  32  DSCSR             Provides control and status information for Secure debug
//	0xEF00  32  STIR              Provides a mechanism for software to generate an interrupt
//	0xEF34  32  FPCCR             Holds control data for the Floating-point extension
//	0xEF38  32  FPCAR             Holds the location of the unpopulated floating-point register space allocated on an exception stack frame
//	0xEF3C  32  FPDSCR            Holds the default values for the floating-point status control data that the PE assigns to the FPSCR when it creates a new floating-point context
//	0xEF40  32  MVFR0             Describes the features provided by the Floating-point Extension
//	0xEF44  32  MVFR1             Describes the features provided by the Floating-point Extension
//	0xEF48  32  MVFR2             Describes the features provided by the Floating-point Extension
//	0xEFBC  32  DDEVARCH          Provides CoreSight discovery information for the SCS
//	0xEFCC  32  DDEVTYPE          Provides CoreSight discovery information for the SCS
//	0xEFD0  32  DPIDR4            Provides CoreSight discovery information for the SCS
//	0xEFD4  32  DPIDR5            Provides CoreSight discovery information for the SCS
//	0xEFD8  32  DPIDR6            Provides CoreSight discovery information for the SCS
//	0xEFDC  32  DPIDR7            Provides CoreSight discovery information for the SCS
//	0xEFE0  32  DPIDR0            Provides CoreSight discovery information for the SCS
//	0xEFE4  32  DPIDR1            Provides CoreSight discovery information for the SCS
//	0xEFE8  32  DPIDR2            Provides CoreSight discovery information for the SCS
//	0xEFEC  32  DPIDR3            Provides CoreSight discovery information for the SCS
//	0xEFF0  32  DCIDR0            Provides CoreSight discovery information for the SCS
//	0xEFF4  32  DCIDR1            Provides CoreSight discovery information for the SCS
//	0xEFF8  32  DCIDR2            Provides CoreSight discovery information for the SCS
//	0xEFFC  32  DCIDR3            Provides CoreSight discovery information for the SCS
//	0x41004 32  TRCPRGCTLR        Programming Control Register
//	0x4100C 32  TRCSTATR          The TRCSTATR indicates the ETM-Teal status
//	0x41010 32  TRCCONFIGR        The TRCCONFIGR sets the basic tracing options for the trace unit
//	0x41020 32  TRCEVENTCTL0R     The TRCEVENTCTL0R controls the tracing of events in the trace stream. The events also drive the ETM-Teal external outputs.
//	0x41024 32  TRCEVENTCTL1R     The TRCEVENTCTL1R controls how the events selected by TRCEVENTCTL0R behave
//	0x4102C 32  TRCSTALLCTLR      The TRCSTALLCTLR enables ETM-Teal to stall the processor if the ETM-Teal FIFO goes over the programmed level to minimize risk of overflow
//	0x41030 32  TRCTSCTLR         The TRCTSCTLR controls the insertion of global timestamps into the trace stream. A timestamp is always inserted into the instruction trace stream
//	0x41034 32  TRCSYNCPR         The TRCSYNCPR specifies the period of trace synchronization of the trace streams. TRCSYNCPR defines a number of bytes of trace between requests for trace synchronization. This value is always a power of two
//	0x41038 32  TRCCCCTLR         The TRCCCCTLR sets the threshold value for instruction trace cycle counting. The threshold represents the minimum interval between cycle count trace packets
//	0x41080 32  TRCVICTLR         The TRCVICTLR controls instruction trace filtering
//	0x41140 32  TRCCNTRLDVR0      The TRCCNTRLDVR defines the reload value for the reduced function counter
//	0x41180 32  TRCIDR8           TRCIDR8
//	0x41184 32  TRCIDR9           TRCIDR9
//	0x41188 32  TRCIDR10          TRCIDR10
//	0x4118C 32  TRCIDR11          TRCIDR11
//	0x41190 32  TRCIDR12          TRCIDR12
//	0x41194 32  TRCIDR13          TRCIDR13
//	0x411C0 32  TRCIMSPEC         The TRCIMSPEC shows the presence of any IMPLEMENTATION SPECIFIC features, and enables any features that are provided
//	0x411E0 32  TRCIDR0           TRCIDR0
//	0x411E4 32  TRCIDR1           TRCIDR1
//	0x411E8 32  TRCIDR2           TRCIDR2
//	0x411EC 32  TRCIDR3           TRCIDR3
//	0x411F0 32  TRCIDR4           TRCIDR4
//	0x411F4 32  TRCIDR5           TRCIDR5
//	0x411F8 32  TRCIDR6           TRCIDR6
//	0x411FC 32  TRCIDR7           TRCIDR7
//	0x41208 32  TRCRSCTLR2        The TRCRSCTLR controls the trace resources
//	0x4120C 32  TRCRSCTLR3        The TRCRSCTLR controls the trace resources
//	0x412A0 32  TRCSSCSR          Controls the corresponding single-shot comparator resource
//	0x412C0 32  TRCSSPCICR        Selects the PE comparator inputs for Single-shot control
//	0x41310 32  TRCPDCR           Requests the system to provide power to the trace unit
//	0x41314 32  TRCPDSR           Returns the following information about the trace unit: - OS Lock status. - Core power domain status. - Power interruption status
//	0x41EE4 32  TRCITATBIDR       Trace Integration ATB Identification Register
//	0x41EF4 32  TRCITIATBINR      Trace Integration Instruction ATB In Register
//	0x41EFC 32  TRCITIATBOUTR     Trace Integration Instruction ATB Out Register
//	0x41FA0 32  TRCCLAIMSET       Claim Tag Set Register
//	0x41FA4 32  TRCCLAIMCLR       Claim Tag Clear Register
//	0x41FB8 32  TRCAUTHSTATUS     Returns the level of tracing that the trace unit can support
//	0x41FBC 32  TRCDEVARCH        TRCDEVARCH
//	0x41FC8 32  TRCDEVID          TRCDEVID
//	0x41FCC 32  TRCDEVTYPE        TRCDEVTYPE
//	0x41FD0 32  TRCPIDR4          TRCPIDR4
//	0x41FD4 32  TRCPIDR5          TRCPIDR5
//	0x41FD8 32  TRCPIDR6          TRCPIDR6
//	0x41FDC 32  TRCPIDR7          TRCPIDR7
//	0x41FE0 32  TRCPIDR0          TRCPIDR0
//	0x41FE4 32  TRCPIDR1          TRCPIDR1
//	0x41FE8 32  TRCPIDR2          TRCPIDR2
//	0x41FEC 32  TRCPIDR3          TRCPIDR3
//	0x41FF0 32  TRCCIDR0          TRCCIDR0
//	0x41FF4 32  TRCCIDR1          TRCCIDR1
//	0x41FF8 32  TRCCIDR2          TRCCIDR2
//	0x41FFC 32  TRCCIDR3          TRCCIDR3
//	0x42000 32  CTICONTROL        CTI Control Register
//	0x42010 32  CTIINTACK         CTI Interrupt Acknowledge Register
//	0x42014 32  CTIAPPSET         CTI Application Trigger Set Register
//	0x42018 32  CTIAPPCLEAR       CTI Application Trigger Clear Register
//	0x4201C 32  CTIAPPPULSE       CTI Application Pulse Register
//	0x42020 32  CTIINEN0          CTI Trigger to Channel Enable Registers
//	0x42024 32  CTIINEN1          CTI Trigger to Channel Enable Registers
//	0x42028 32  CTIINEN2          CTI Trigger to Channel Enable Registers
//	0x4202C 32  CTIINEN3          CTI Trigger to Channel Enable Registers
//	0x42030 32  CTIINEN4          CTI Trigger to Channel Enable Registers
//	0x42034 32  CTIINEN5          CTI Trigger to Channel Enable Registers
//	0x42038 32  CTIINEN6          CTI Trigger to Channel Enable Registers
//	0x4203C 32  CTIINEN7          CTI Trigger to Channel Enable Registers
//	0x420A0 32  CTIOUTEN0         CTI Trigger to Channel Enable Registers
//	0x420A4 32  CTIOUTEN1         CTI Trigger to Channel Enable Registers
//	0x420A8 32  CTIOUTEN2         CTI Trigger to Channel Enable Registers
//	0x420AC 32  CTIOUTEN3         CTI Trigger to Channel Enable Registers
//	0x420B0 32  CTIOUTEN4         CTI Trigger to Channel Enable Registers
//	0x420B4 32  CTIOUTEN5         CTI Trigger to Channel Enable Registers
//	0x420B8 32  CTIOUTEN6         CTI Trigger to Channel Enable Registers
//	0x420BC 32  CTIOUTEN7         CTI Trigger to Channel Enable Registers
//	0x42130 32  CTITRIGINSTATUS   CTI Trigger to Channel Enable Registers
//	0x42134 32  CTITRIGOUTSTATUS  CTI Trigger In Status Register
//	0x42138 32  CTICHINSTATUS     CTI Channel In Status Register
//	0x42140 32  CTIGATE           Enable CTI Channel Gate register
//	0x42144 32  ASICCTL           External Multiplexer Control register
//	0x42EE4 32  ITCHOUT           Integration Test Channel Output register
//	0x42EE8 32  ITTRIGOUT         Integration Test Trigger Output register
//	0x42EF4 32  ITCHIN            Integration Test Channel Input register
//	0x42F00 32  ITCTRL            Integration Mode Control register
//	0x42FBC 32  DEVARCH           Device Architecture register
//	0x42FC8 32  DEVID             Device Configuration register
//	0x42FCC 32  DEVTYPE           Device Type Identifier register
//	0x42FD0 32  PIDR4             CoreSight Peripheral ID4
//	0x42FD4 32  PIDR5             CoreSight Peripheral ID5
//	0x42FD8 32  PIDR6             CoreSight Peripheral ID6
//	0x42FDC 32  PIDR7             CoreSight Peripheral ID7
//	0x42FE0 32  PIDR0             CoreSight Peripheral ID0
//	0x42FE4 32  PIDR1             CoreSight Peripheral ID1
//	0x42FE8 32  PIDR2             CoreSight Peripheral ID2
//	0x42FEC 32  PIDR3             CoreSight Peripheral ID3
//	0x42FF0 32  CIDR0             CoreSight Component ID0
//	0x42FF4 32  CIDR1             CoreSight Component ID1
//	0x42FF8 32  CIDR2             CoreSight Component ID2
//	0x42FFC 32  CIDR3             CoreSight Component ID3
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package ppb

const (
	ITMENA     ITM_TCR = 0x01 << 0  //+ Enables the ITM
	TSENA      ITM_TCR = 0x01 << 1  //+ Enables Local timestamp generation
	SYNCENA    ITM_TCR = 0x01 << 2  //+ Enables Synchronization packet transmission for a synchronous TPIU
	TXENA      ITM_TCR = 0x01 << 3  //+ Enables forwarding of hardware event packet from the DWT unit to the ITM for output to the TPIU
	SWOENA     ITM_TCR = 0x01 << 4  //+ Enables asynchronous clocking of the timestamp counter
	STALLENA   ITM_TCR = 0x01 << 5  //+ Stall the PE to guarantee delivery of Data Trace packets.
	TSPRESCALE ITM_TCR = 0x03 << 8  //+ Local timestamp prescaler, used with the trace packet reference clock
	GTSFREQ    ITM_TCR = 0x03 << 10 //+ Defines how often the ITM generates a global timestamp, based on the global timestamp clock frequency, or disables generation of global timestamps
	TRACEBUSID ITM_TCR = 0x7F << 16 //+ Identifier for multi-source trace stream formatting. If multi-source trace is in use, the debugger must write a unique non-zero trace ID value to this field
	BUSY       ITM_TCR = 0x01 << 23 //+ Indicates whether the ITM is currently processing events
)

const (
	ITMENAn     = 0
	TSENAn      = 1
	SYNCENAn    = 2
	TXENAn      = 3
	SWOENAn     = 4
	STALLENAn   = 5
	TSPRESCALEn = 8
	GTSFREQn    = 10
	TRACEBUSIDn = 16
	BUSYn       = 23
)

const (
	ATREADY INT_ATREADY = 0x01 << 0 //+ A read of this bit returns the value of ATREADY
	AFVALID INT_ATREADY = 0x01 << 1 //+ A read of this bit returns the value of AFVALID
)

const (
	ATREADYn = 0
	AFVALIDn = 1
)

const (
	ATREADY INT_ATVALID = 0x01 << 0 //+ A write to this bit gives the value of ATVALID
	AFREADY INT_ATVALID = 0x01 << 1 //+ A write to this bit gives the value of AFREADY
)

const (
	ATREADYn = 0
	AFREADYn = 1
)

const (
	ARCHPART  ITM_DEVARCH = 0xFFF << 0  //+ Defines the architecture of the component
	ARCHVER   ITM_DEVARCH = 0x0F << 12  //+ Defines the architecture version of the component
	REVISION  ITM_DEVARCH = 0x0F << 16  //+ Defines the architecture revision of the component
	PRESENT   ITM_DEVARCH = 0x01 << 20  //+ Defines that the DEVARCH register is present
	ARCHITECT ITM_DEVARCH = 0x7FF << 21 //+ Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
)

const (
	ARCHPARTn  = 0
	ARCHVERn   = 12
	REVISIONn  = 16
	PRESENTn   = 20
	ARCHITECTn = 21
)

const (
	MAJOR ITM_DEVTYPE = 0x0F << 0 //+ Component major type
	SUB   ITM_DEVTYPE = 0x0F << 4 //+ Component sub-type
)

const (
	MAJORn = 0
	SUBn   = 4
)

const (
	DES_2 ITM_PIDR4 = 0x0F << 0 //+ See CoreSight Architecture Specification
	SIZE  ITM_PIDR4 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_2n = 0
	SIZEn  = 4
)

const (
	PART_1 ITM_PIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	DES_0  ITM_PIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PART_1n = 0
	DES_0n  = 4
)

const (
	DES_1    ITM_PIDR2 = 0x07 << 0 //+ See CoreSight Architecture Specification
	JEDEC    ITM_PIDR2 = 0x01 << 3 //+ See CoreSight Architecture Specification
	REVISION ITM_PIDR2 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_1n    = 0
	JEDECn    = 3
	REVISIONn = 4
)

const (
	CMOD   ITM_PIDR3 = 0x0F << 0 //+ See CoreSight Architecture Specification
	REVAND ITM_PIDR3 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	CMODn   = 0
	REVANDn = 4
)

const (
	PRMBL_1 ITM_CIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	CLASS   ITM_CIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PRMBL_1n = 0
	CLASSn   = 4
)

const (
	CYCCNTENA   DWT_CTRL = 0x01 << 0  //+ Enables CYCCNT
	POSTPRESET  DWT_CTRL = 0x0F << 1  //+ Reload value for the POSTCNT counter
	POSTINIT    DWT_CTRL = 0x0F << 5  //+ Initial value for the POSTCNT counter
	CYCTAP      DWT_CTRL = 0x01 << 9  //+ Selects the position of the POSTCNT tap on the CYCCNT counter
	SYNCTAP     DWT_CTRL = 0x03 << 10 //+ Selects the position of the synchronization packet counter tap on the CYCCNT counter. This determines the Synchronization packet rate
	PCSAMPLENA  DWT_CTRL = 0x01 << 12 //+ Enables use of POSTCNT counter as a timer for Periodic PC Sample packet generation
	EXTTRCENA   DWT_CTRL = 0x01 << 16 //+ Enables generation of Exception Trace packets
	CPIEVTENA   DWT_CTRL = 0x01 << 17 //+ Enables DWT_CPICNT counter
	EXCEVTENA   DWT_CTRL = 0x01 << 18 //+ Enables DWT_EXCCNT counter
	SLEEPEVTENA DWT_CTRL = 0x01 << 19 //+ Enable DWT_SLEEPCNT counter
	LSUEVTENA   DWT_CTRL = 0x01 << 20 //+ Enables DWT_LSUCNT counter
	FOLDEVTENA  DWT_CTRL = 0x01 << 21 //+ Enables DWT_FOLDCNT counter
	CYCEVTENA   DWT_CTRL = 0x01 << 22 //+ Enables Event Counter packet generation on POSTCNT underflow
	CYCDISS     DWT_CTRL = 0x01 << 23 //+ Controls whether the cycle counter is disabled in Secure state
	NOPRFCNT    DWT_CTRL = 0x01 << 24 //+ Indicates whether the implementation does not include the profiling counters
	NOCYCCNT    DWT_CTRL = 0x01 << 25 //+ Indicates whether the implementation does not include a cycle counter
	NOEXTTRIG   DWT_CTRL = 0x01 << 26 //+ Reserved, RAZ
	NOTRCPKT    DWT_CTRL = 0x01 << 27 //+ Indicates whether the implementation does not support trace
	NUMCOMP     DWT_CTRL = 0x0F << 28 //+ Number of DWT comparators implemented
)

const (
	CYCCNTENAn   = 0
	POSTPRESETn  = 1
	POSTINITn    = 5
	CYCTAPn      = 9
	SYNCTAPn     = 10
	PCSAMPLENAn  = 12
	EXTTRCENAn   = 16
	CPIEVTENAn   = 17
	EXCEVTENAn   = 18
	SLEEPEVTENAn = 19
	LSUEVTENAn   = 20
	FOLDEVTENAn  = 21
	CYCEVTENAn   = 22
	CYCDISSn     = 23
	NOPRFCNTn    = 24
	NOCYCCNTn    = 25
	NOEXTTRIGn   = 26
	NOTRCPKTn    = 27
	NUMCOMPn     = 28
)

const (
	MATCH     DWT_FUNCTION0 = 0x0F << 0  //+ Controls the type of match generated by this comparator
	ACTION    DWT_FUNCTION0 = 0x03 << 4  //+ Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
	DATAVSIZE DWT_FUNCTION0 = 0x03 << 10 //+ Defines the size of the object being watched for by Data Value and Data Address comparators
	MATCHED   DWT_FUNCTION0 = 0x01 << 24 //+ Set to 1 when the comparator matches
	ID        DWT_FUNCTION0 = 0x1F << 27 //+ Identifies the capabilities for MATCH for comparator *n
)

const (
	MATCHn     = 0
	ACTIONn    = 4
	DATAVSIZEn = 10
	MATCHEDn   = 24
	IDn        = 27
)

const (
	MATCH     DWT_FUNCTION1 = 0x0F << 0  //+ Controls the type of match generated by this comparator
	ACTION    DWT_FUNCTION1 = 0x03 << 4  //+ Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
	DATAVSIZE DWT_FUNCTION1 = 0x03 << 10 //+ Defines the size of the object being watched for by Data Value and Data Address comparators
	MATCHED   DWT_FUNCTION1 = 0x01 << 24 //+ Set to 1 when the comparator matches
	ID        DWT_FUNCTION1 = 0x1F << 27 //+ Identifies the capabilities for MATCH for comparator *n
)

const (
	MATCHn     = 0
	ACTIONn    = 4
	DATAVSIZEn = 10
	MATCHEDn   = 24
	IDn        = 27
)

const (
	MATCH     DWT_FUNCTION2 = 0x0F << 0  //+ Controls the type of match generated by this comparator
	ACTION    DWT_FUNCTION2 = 0x03 << 4  //+ Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
	DATAVSIZE DWT_FUNCTION2 = 0x03 << 10 //+ Defines the size of the object being watched for by Data Value and Data Address comparators
	MATCHED   DWT_FUNCTION2 = 0x01 << 24 //+ Set to 1 when the comparator matches
	ID        DWT_FUNCTION2 = 0x1F << 27 //+ Identifies the capabilities for MATCH for comparator *n
)

const (
	MATCHn     = 0
	ACTIONn    = 4
	DATAVSIZEn = 10
	MATCHEDn   = 24
	IDn        = 27
)

const (
	MATCH     DWT_FUNCTION3 = 0x0F << 0  //+ Controls the type of match generated by this comparator
	ACTION    DWT_FUNCTION3 = 0x03 << 4  //+ Defines the action on a match. This field is ignored and the comparator generates no actions if it is disabled by MATCH
	DATAVSIZE DWT_FUNCTION3 = 0x03 << 10 //+ Defines the size of the object being watched for by Data Value and Data Address comparators
	MATCHED   DWT_FUNCTION3 = 0x01 << 24 //+ Set to 1 when the comparator matches
	ID        DWT_FUNCTION3 = 0x1F << 27 //+ Identifies the capabilities for MATCH for comparator *n
)

const (
	MATCHn     = 0
	ACTIONn    = 4
	DATAVSIZEn = 10
	MATCHEDn   = 24
	IDn        = 27
)

const (
	ARCHPART  DWT_DEVARCH = 0xFFF << 0  //+ Defines the architecture of the component
	ARCHVER   DWT_DEVARCH = 0x0F << 12  //+ Defines the architecture version of the component
	REVISION  DWT_DEVARCH = 0x0F << 16  //+ Defines the architecture revision of the component
	PRESENT   DWT_DEVARCH = 0x01 << 20  //+ Defines that the DEVARCH register is present
	ARCHITECT DWT_DEVARCH = 0x7FF << 21 //+ Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
)

const (
	ARCHPARTn  = 0
	ARCHVERn   = 12
	REVISIONn  = 16
	PRESENTn   = 20
	ARCHITECTn = 21
)

const (
	MAJOR DWT_DEVTYPE = 0x0F << 0 //+ Component major type
	SUB   DWT_DEVTYPE = 0x0F << 4 //+ Component sub-type
)

const (
	MAJORn = 0
	SUBn   = 4
)

const (
	DES_2 DWT_PIDR4 = 0x0F << 0 //+ See CoreSight Architecture Specification
	SIZE  DWT_PIDR4 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_2n = 0
	SIZEn  = 4
)

const (
	PART_1 DWT_PIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	DES_0  DWT_PIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PART_1n = 0
	DES_0n  = 4
)

const (
	DES_1    DWT_PIDR2 = 0x07 << 0 //+ See CoreSight Architecture Specification
	JEDEC    DWT_PIDR2 = 0x01 << 3 //+ See CoreSight Architecture Specification
	REVISION DWT_PIDR2 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_1n    = 0
	JEDECn    = 3
	REVISIONn = 4
)

const (
	CMOD   DWT_PIDR3 = 0x0F << 0 //+ See CoreSight Architecture Specification
	REVAND DWT_PIDR3 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	CMODn   = 0
	REVANDn = 4
)

const (
	PRMBL_1 DWT_CIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	CLASS   DWT_CIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PRMBL_1n = 0
	CLASSn   = 4
)

const (
	ENABLE          FP_CTRL = 0x01 << 0  //+ Enables the FPB
	KEY             FP_CTRL = 0x01 << 1  //+ Writes to the FP_CTRL are ignored unless KEY is concurrently written to one
	NUM_CODE_7_4_   FP_CTRL = 0x0F << 4  //+ Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1
	NUM_LIT         FP_CTRL = 0x0F << 8  //+ Indicates the number of implemented literal address comparators. The Literal Address comparators are numbered from NUM_CODE to NUM_CODE + NUM_LIT - 1
	NUM_CODE_14_12_ FP_CTRL = 0x07 << 12 //+ Indicates the number of implemented instruction address comparators. Zero indicates no Instruction Address comparators are implemented. The Instruction Address comparators are numbered from 0 to NUM_CODE - 1
	REV             FP_CTRL = 0x0F << 28 //+ Flash Patch and Breakpoint Unit architecture revision
)

const (
	ENABLEn          = 0
	KEYn             = 1
	NUM_CODE_7_4_n   = 4
	NUM_LITn         = 8
	NUM_CODE_14_12_n = 12
	REVn             = 28
)

const (
	REMAP  FP_REMAP = 0xFFFFFF << 5 //+ Holds the bits[28:5] of the Flash Patch remap address
	RMPSPT FP_REMAP = 0x01 << 29    //+ Indicates whether the FPB unit supports the Flash Patch remap function
)

const (
	REMAPn  = 5
	RMPSPTn = 29
)

const (
	ARCHPART  FP_DEVARCH = 0xFFF << 0  //+ Defines the architecture of the component
	ARCHVER   FP_DEVARCH = 0x0F << 12  //+ Defines the architecture version of the component
	REVISION  FP_DEVARCH = 0x0F << 16  //+ Defines the architecture revision of the component
	PRESENT   FP_DEVARCH = 0x01 << 20  //+ Defines that the DEVARCH register is present
	ARCHITECT FP_DEVARCH = 0x7FF << 21 //+ Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
)

const (
	ARCHPARTn  = 0
	ARCHVERn   = 12
	REVISIONn  = 16
	PRESENTn   = 20
	ARCHITECTn = 21
)

const (
	MAJOR FP_DEVTYPE = 0x0F << 0 //+ Component major type
	SUB   FP_DEVTYPE = 0x0F << 4 //+ Component sub-type
)

const (
	MAJORn = 0
	SUBn   = 4
)

const (
	DES_2 FP_PIDR4 = 0x0F << 0 //+ See CoreSight Architecture Specification
	SIZE  FP_PIDR4 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_2n = 0
	SIZEn  = 4
)

const (
	PART_1 FP_PIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	DES_0  FP_PIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PART_1n = 0
	DES_0n  = 4
)

const (
	DES_1    FP_PIDR2 = 0x07 << 0 //+ See CoreSight Architecture Specification
	JEDEC    FP_PIDR2 = 0x01 << 3 //+ See CoreSight Architecture Specification
	REVISION FP_PIDR2 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_1n    = 0
	JEDECn    = 3
	REVISIONn = 4
)

const (
	CMOD   FP_PIDR3 = 0x0F << 0 //+ See CoreSight Architecture Specification
	REVAND FP_PIDR3 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	CMODn   = 0
	REVANDn = 4
)

const (
	PRMBL_1 FP_CIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	CLASS   FP_CIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PRMBL_1n = 0
	CLASSn   = 4
)

const (
	DISMCYCINT     ACTLR = 0x01 << 0  //+ Disable dual-issue.
	DISFOLD        ACTLR = 0x01 << 2  //+ Disable dual-issue.
	DISOOFP        ACTLR = 0x01 << 9  //+ Disable out-of-order FP instruction completion
	FPEXCODIS      ACTLR = 0x01 << 10 //+ Disable FPU exception outputs
	DISITMATBFLUSH ACTLR = 0x01 << 12 //+ Disable ATB Flush
	EXTEXCLALL     ACTLR = 0x01 << 29 //+ External Exclusives Allowed with no MPU
)

const (
	DISMCYCINTn     = 0
	DISFOLDn        = 2
	DISOOFPn        = 9
	FPEXCODISn      = 10
	DISITMATBFLUSHn = 12
	EXTEXCLALLn     = 29
)

const (
	ENABLE    SYST_CSR = 0x01 << 0  //+ Enable SysTick counter: 0 = Counter disabled. 1 = Counter enabled.
	TICKINT   SYST_CSR = 0x01 << 1  //+ Enables SysTick exception request: 0 = Counting down to zero does not assert the SysTick exception request. 1 = Counting down to zero to asserts the SysTick exception request.
	CLKSOURCE SYST_CSR = 0x01 << 2  //+ SysTick clock source. Always reads as one if SYST_CALIB reports NOREF. Selects the SysTick timer clock source: 0 = External reference clock. 1 = Processor clock.
	COUNTFLAG SYST_CSR = 0x01 << 16 //+ Returns 1 if timer counted to 0 since last time this was read. Clears on read by application or debugger.
)

const (
	ENABLEn    = 0
	TICKINTn   = 1
	CLKSOURCEn = 2
	COUNTFLAGn = 16
)

const (
	TENMS SYST_CALIB = 0xFFFFFF << 0 //+ An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. If the value reads as 0, the calibration value is not known.
	SKEW  SYST_CALIB = 0x01 << 30    //+ If reads as 1, the calibration value for 10ms is inexact (due to clock frequency).
	NOREF SYST_CALIB = 0x01 << 31    //+ If reads as 1, the Reference clock is not provided - the CLKSOURCE bit of the SysTick Control and Status register will be forced to 1 and cannot be cleared to 0.
)

const (
	TENMSn = 0
	SKEWn  = 30
	NOREFn = 31
)

const (
	PRI_N0 NVIC_IPR0 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR0 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR0 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR0 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR1 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR1 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR1 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR1 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR2 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR2 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR2 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR2 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR3 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR3 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR3 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR3 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR4 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR4 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR4 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR4 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR5 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR5 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR5 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR5 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR6 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR6 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR6 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR6 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR7 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR7 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR7 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR7 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR8 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR8 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR8 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR8 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR9 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR9 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR9 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR9 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR10 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR10 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR10 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR10 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR11 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR11 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR11 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR11 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR12 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR12 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR12 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR12 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR13 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR13 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR13 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR13 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR14 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR14 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR14 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR14 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	PRI_N0 NVIC_IPR15 = 0x0F << 4  //+ For register NVIC_IPRn, the priority of interrupt number 4*n+0, or RES0 if the PE does not implement this interrupt
	PRI_N1 NVIC_IPR15 = 0x0F << 12 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+1, or RES0 if the PE does not implement this interrupt
	PRI_N2 NVIC_IPR15 = 0x0F << 20 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+2, or RES0 if the PE does not implement this interrupt
	PRI_N3 NVIC_IPR15 = 0x0F << 28 //+ For register NVIC_IPRn, the priority of interrupt number 4*n+3, or RES0 if the PE does not implement this interrupt
)

const (
	PRI_N0n = 4
	PRI_N1n = 12
	PRI_N2n = 20
	PRI_N3n = 28
)

const (
	REVISION     CPUID = 0x0F << 0  //+ IMPLEMENTATION DEFINED revision number for the device
	PARTNO       CPUID = 0xFFF << 4 //+ IMPLEMENTATION DEFINED primary part number for the device
	ARCHITECTURE CPUID = 0x0F << 16 //+ Defines the Architecture implemented by the PE
	VARIANT      CPUID = 0x0F << 20 //+ IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish between different product variants, or major revisions of a product
	IMPLEMENTER  CPUID = 0xFF << 24 //+ This field must hold an implementer code that has been assigned by ARM
)

const (
	REVISIONn     = 0
	PARTNOn       = 4
	ARCHITECTUREn = 16
	VARIANTn      = 20
	IMPLEMENTERn  = 24
)

const (
	VECTACTIVE  ICSR = 0x1FF << 0  //+ The exception number of the current executing exception
	RETTOBASE   ICSR = 0x01 << 11  //+ In Handler mode, indicates whether there is more than one active exception
	VECTPENDING ICSR = 0x1FF << 12 //+ The exception number of the highest priority pending and enabled interrupt
	ISRPENDING  ICSR = 0x01 << 22  //+ Indicates whether an external interrupt, generated by the NVIC, is pending
	ISRPREEMPT  ICSR = 0x01 << 23  //+ Indicates whether a pending exception will be serviced on exit from debug halt state
	STTNS       ICSR = 0x01 << 24  //+ Controls whether in a single SysTick implementation, the SysTick is Secure or Non-secure
	PENDSTCLR   ICSR = 0x01 << 25  //+ Allows the SysTick exception pend state to be cleared `FTSSS
	PENDSTSET   ICSR = 0x01 << 26  //+ Indicates whether the SysTick `FTSSS exception is pending
	PENDSVCLR   ICSR = 0x01 << 27  //+ Allows the PendSV exception pend state to be cleared `FTSSS
	PENDSVSET   ICSR = 0x01 << 28  //+ Indicates whether the PendSV `FTSSS exception is pending
	PENDNMICLR  ICSR = 0x01 << 30  //+ Allows the NMI exception pend state to be cleared
	PENDNMISET  ICSR = 0x01 << 31  //+ Indicates whether the NMI exception is pending
)

const (
	VECTACTIVEn  = 0
	RETTOBASEn   = 11
	VECTPENDINGn = 12
	ISRPENDINGn  = 22
	ISRPREEMPTn  = 23
	STTNSn       = 24
	PENDSTCLRn   = 25
	PENDSTSETn   = 26
	PENDSVCLRn   = 27
	PENDSVSETn   = 28
	PENDNMICLRn  = 30
	PENDNMISETn  = 31
)

const (
	TBLOFF VTOR = 0x1FFFFFF << 7 //+ Vector table base offset field. It contains bits[31:7] of the offset of the table base from the bottom of the memory map.
)

const (
	TBLOFFn = 7
)

const (
	VECTCLRACTIVE AIRCR = 0x01 << 1    //+ Clears all active state information for fixed and configurable exceptions. This bit: is self-clearing, can only be set by the DAP when the core is halted. When set: clears all active exception status of the processor, forces a return to Thread mode, forces an IPSR of 0. A debugger must re-initialize the stack.
	SYSRESETREQ   AIRCR = 0x01 << 2    //+ Writing 1 to this bit causes the SYSRESETREQ signal to the outer system to be asserted to request a reset. The intention is to force a large system reset of all major components except for debug. The C_HALT bit in the DHCSR is cleared as a result of the system reset requested. The debugger does not lose contact with the device.
	SYSRESETREQS  AIRCR = 0x01 << 3    //+ System reset request, Secure state only. 0 SYSRESETREQ functionality is available to both Security states. 1 SYSRESETREQ functionality is only available to Secure state.
	PRIGROUP      AIRCR = 0x07 << 8    //+ Interrupt priority grouping field. This field determines the split of group priority from subpriority. See https://developer.arm.com/documentation/100235/0004/the-cortex-m33-peripherals/system-control-block/application-interrupt-and-reset-control-register?lang=en
	BFHFNMINS     AIRCR = 0x01 << 13   //+ BusFault, HardFault, and NMI Non-secure enable. 0 BusFault, HardFault, and NMI are Secure. 1 BusFault and NMI are Non-secure and exceptions can target Non-secure HardFault.
	PRIS          AIRCR = 0x01 << 14   //+ Prioritize Secure exceptions. The value of this bit defines whether Secure exception priority boosting is enabled. 0 Priority ranges of Secure and Non-secure exceptions are identical. 1 Non-secure exceptions are de-prioritized.
	ENDIANESS     AIRCR = 0x01 << 15   //+ Data endianness implemented: 0 = Little-endian.
	VECTKEY       AIRCR = 0xFFFF << 16 //+ Register key: Reads as Unknown On writes, write 0x05FA to VECTKEY, otherwise the write is ignored.
)

const (
	VECTCLRACTIVEn = 1
	SYSRESETREQn   = 2
	SYSRESETREQSn  = 3
	PRIGROUPn      = 8
	BFHFNMINSn     = 13
	PRISn          = 14
	ENDIANESSn     = 15
	VECTKEYn       = 16
)

const (
	SLEEPONEXIT SCR = 0x01 << 1 //+ Indicates sleep-on-exit when returning from Handler mode to Thread mode: 0 = Do not sleep when returning to Thread mode. 1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode. Setting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application.
	SLEEPDEEP   SCR = 0x01 << 2 //+ Controls whether the processor uses sleep or deep sleep as its low power mode: 0 = Sleep. 1 = Deep sleep.
	SLEEPDEEPS  SCR = 0x01 << 3 //+ 0 SLEEPDEEP is available to both security states 1 SLEEPDEEP is only available to Secure state
	SEVONPEND   SCR = 0x01 << 4 //+ Send Event on Pending bit: 0 = Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded. 1 = Enabled events and all interrupts, including disabled interrupts, can wakeup the processor. When an event or interrupt becomes pending, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE. The processor also wakes up on execution of an SEV instruction or an external event.
)

const (
	SLEEPONEXITn = 1
	SLEEPDEEPn   = 2
	SLEEPDEEPSn  = 3
	SEVONPENDn   = 4
)

const (
	RES1_1       CCR = 0x01 << 0  //+ Reserved, RES1
	USERSETMPEND CCR = 0x01 << 1  //+ Determines whether unprivileged accesses are permitted to pend interrupts via the STIR
	UNALIGN_TRP  CCR = 0x01 << 3  //+ Controls the trapping of unaligned word or halfword accesses
	DIV_0_TRP    CCR = 0x01 << 4  //+ Controls the generation of a DIVBYZERO UsageFault when attempting to perform integer division by zero
	BFHFNMIGN    CCR = 0x01 << 8  //+ Determines the effect of precise BusFaults on handlers running at a requested priority less than 0
	RES1         CCR = 0x01 << 9  //+ Reserved, RES1
	STKOFHFNMIGN CCR = 0x01 << 10 //+ Controls the effect of a stack limit violation while executing at a requested priority less than 0
	DC           CCR = 0x01 << 16 //+ Enables data caching of all data accesses to Normal memory `FTSSS
	IC           CCR = 0x01 << 17 //+ This is a global enable bit for instruction caches in the selected Security state
	BP           CCR = 0x01 << 18 //+ Enables program flow prediction `FTSSS
)

const (
	RES1_1n       = 0
	USERSETMPENDn = 1
	UNALIGN_TRPn  = 3
	DIV_0_TRPn    = 4
	BFHFNMIGNn    = 8
	RES1n         = 9
	STKOFHFNMIGNn = 10
	DCn           = 16
	ICn           = 17
	BPn           = 18
)

const (
	PRI_4_3 SHPR1 = 0x07 << 5  //+ Priority of system handler 4, SecureFault
	PRI_5_3 SHPR1 = 0x07 << 13 //+ Priority of system handler 5, SecureFault
	PRI_6_3 SHPR1 = 0x07 << 21 //+ Priority of system handler 6, SecureFault
	PRI_7_3 SHPR1 = 0x07 << 29 //+ Priority of system handler 7, SecureFault
)

const (
	PRI_4_3n = 5
	PRI_5_3n = 13
	PRI_6_3n = 21
	PRI_7_3n = 29
)

const (
	PRI_8    SHPR2 = 0xFF << 0  //+ Reserved, RES0
	PRI_9    SHPR2 = 0xFF << 8  //+ Reserved, RES0
	PRI_10   SHPR2 = 0xFF << 16 //+ Reserved, RES0
	PRI_11_3 SHPR2 = 0x07 << 29 //+ Priority of system handler 11, SecureFault
)

const (
	PRI_8n    = 0
	PRI_9n    = 8
	PRI_10n   = 16
	PRI_11_3n = 29
)

const (
	PRI_12_3 SHPR3 = 0x07 << 5  //+ Priority of system handler 12, SecureFault
	PRI_13   SHPR3 = 0xFF << 8  //+ Reserved, RES0
	PRI_14_3 SHPR3 = 0x07 << 21 //+ Priority of system handler 14, SecureFault
	PRI_15_3 SHPR3 = 0x07 << 29 //+ Priority of system handler 15, SecureFault
)

const (
	PRI_12_3n = 5
	PRI_13n   = 8
	PRI_14_3n = 21
	PRI_15_3n = 29
)

const (
	MEMFAULTACT       SHCSR = 0x01 << 0  //+ `IAAMO the active state of the MemManage exception `FTSSS
	BUSFAULTACT       SHCSR = 0x01 << 1  //+ `IAAMO the active state of the BusFault exception
	HARDFAULTACT      SHCSR = 0x01 << 2  //+ Indicates and allows limited modification of the active state of the HardFault exception `FTSSS
	USGFAULTACT       SHCSR = 0x01 << 3  //+ `IAAMO the active state of the UsageFault exception `FTSSS
	SECUREFAULTACT    SHCSR = 0x01 << 4  //+ `IAAMO the active state of the SecureFault exception
	NMIACT            SHCSR = 0x01 << 5  //+ `IAAMO the active state of the NMI exception
	SVCALLACT         SHCSR = 0x01 << 7  //+ `IAAMO the active state of the SVCall exception `FTSSS
	MONITORACT        SHCSR = 0x01 << 8  //+ `IAAMO the active state of the DebugMonitor exception
	PENDSVACT         SHCSR = 0x01 << 10 //+ `IAAMO the active state of the PendSV exception `FTSSS
	SYSTICKACT        SHCSR = 0x01 << 11 //+ `IAAMO the active state of the SysTick exception `FTSSS
	USGFAULTPENDED    SHCSR = 0x01 << 12 //+ The UsageFault exception is banked between Security states, `IAAMO the pending state of the UsageFault exception `FTSSS
	MEMFAULTPENDED    SHCSR = 0x01 << 13 //+ `IAAMO the pending state of the MemManage exception `FTSSS
	BUSFAULTPENDED    SHCSR = 0x01 << 14 //+ `IAAMO the pending state of the BusFault exception
	SVCALLPENDED      SHCSR = 0x01 << 15 //+ `IAAMO the pending state of the SVCall exception `FTSSS
	MEMFAULTENA       SHCSR = 0x01 << 16 //+ `DW the MemManage exception is enabled `FTSSS
	BUSFAULTENA       SHCSR = 0x01 << 17 //+ `DW the BusFault exception is enabled
	USGFAULTENA       SHCSR = 0x01 << 18 //+ `DW the UsageFault exception is enabled `FTSSS
	SECUREFAULTENA    SHCSR = 0x01 << 19 //+ `DW the SecureFault exception is enabled
	SECUREFAULTPENDED SHCSR = 0x01 << 20 //+ `IAAMO the pending state of the SecureFault exception
	HARDFAULTPENDED   SHCSR = 0x01 << 21 //+ `IAAMO the pending state of the HardFault exception `CTTSSS
)

const (
	MEMFAULTACTn       = 0
	BUSFAULTACTn       = 1
	HARDFAULTACTn      = 2
	USGFAULTACTn       = 3
	SECUREFAULTACTn    = 4
	NMIACTn            = 5
	SVCALLACTn         = 7
	MONITORACTn        = 8
	PENDSVACTn         = 10
	SYSTICKACTn        = 11
	USGFAULTPENDEDn    = 12
	MEMFAULTPENDEDn    = 13
	BUSFAULTPENDEDn    = 14
	SVCALLPENDEDn      = 15
	MEMFAULTENAn       = 16
	BUSFAULTENAn       = 17
	USGFAULTENAn       = 18
	SECUREFAULTENAn    = 19
	SECUREFAULTPENDEDn = 20
	HARDFAULTPENDEDn   = 21
)

const (
	MMFSR            CFSR = 0xFF << 0  //+ Provides information on MemManage exceptions
	BFSR_IBUSERR     CFSR = 0x01 << 8  //+ Records whether a BusFault on an instruction prefetch has occurred
	BFSR_PRECISERR   CFSR = 0x01 << 9  //+ Records whether a precise data access error has occurred
	BFSR_IMPRECISERR CFSR = 0x01 << 10 //+ Records whether an imprecise data access error has occurred
	BFSR_UNSTKERR    CFSR = 0x01 << 11 //+ Records whether a derived BusFault occurred during exception return unstacking
	BFSR_STKERR      CFSR = 0x01 << 12 //+ Records whether a derived BusFault occurred during exception entry stacking
	BFSR_LSPERR      CFSR = 0x01 << 13 //+ Records whether a BusFault occurred during FP lazy state preservation
	BFSR_BFARVALID   CFSR = 0x01 << 15 //+ Indicates validity of the contents of the BFAR register
	UFSR_UNDEFINSTR  CFSR = 0x01 << 16 //+ Sticky flag indicating whether an undefined instruction error has occurred
	UFSR_INVSTATE    CFSR = 0x01 << 17 //+ Sticky flag indicating whether an EPSR.T or EPSR.IT validity error has occurred
	UFSR_INVPC       CFSR = 0x01 << 18 //+ Sticky flag indicating whether an integrity check error has occurred
	UFSR_NOCP        CFSR = 0x01 << 19 //+ Sticky flag indicating whether a coprocessor disabled or not present error has occurred
	UFSR_STKOF       CFSR = 0x01 << 20 //+ Sticky flag indicating whether a stack overflow error has occurred
	UFSR_UNALIGNED   CFSR = 0x01 << 24 //+ Sticky flag indicating whether an unaligned access error has occurred
	UFSR_DIVBYZERO   CFSR = 0x01 << 25 //+ Sticky flag indicating whether an integer division by zero error has occurred
)

const (
	MMFSRn            = 0
	BFSR_IBUSERRn     = 8
	BFSR_PRECISERRn   = 9
	BFSR_IMPRECISERRn = 10
	BFSR_UNSTKERRn    = 11
	BFSR_STKERRn      = 12
	BFSR_LSPERRn      = 13
	BFSR_BFARVALIDn   = 15
	UFSR_UNDEFINSTRn  = 16
	UFSR_INVSTATEn    = 17
	UFSR_INVPCn       = 18
	UFSR_NOCPn        = 19
	UFSR_STKOFn       = 20
	UFSR_UNALIGNEDn   = 24
	UFSR_DIVBYZEROn   = 25
)

const (
	VECTTBL  HFSR = 0x01 << 1  //+ Indicates when a fault has occurred because of a vector table read error on exception processing
	FORCED   HFSR = 0x01 << 30 //+ Indicates that a fault with configurable priority has been escalated to a HardFault exception, because it could not be made active, because of priority, or because it was disabled
	DEBUGEVT HFSR = 0x01 << 31 //+ Indicates when a Debug event has occurred
)

const (
	VECTTBLn  = 1
	FORCEDn   = 30
	DEBUGEVTn = 31
)

const (
	HALTED   DFSR = 0x01 << 0 //+ Sticky flag indicating that a Halt request debug event or Step debug event has occurred
	BKPT     DFSR = 0x01 << 1 //+ Sticky flag indicating whether a Breakpoint debug event has occurred
	DWTTRAP  DFSR = 0x01 << 2 //+ Sticky flag indicating whether a Watchpoint debug event has occurred
	VCATCH   DFSR = 0x01 << 3 //+ Sticky flag indicating whether a Vector catch debug event has occurred
	EXTERNAL DFSR = 0x01 << 4 //+ Sticky flag indicating whether an External debug request debug event has occurred
)

const (
	HALTEDn   = 0
	BKPTn     = 1
	DWTTRAPn  = 2
	VCATCHn   = 3
	EXTERNALn = 4
)

const (
	STATE0 ID_PFR0 = 0x0F << 0 //+ A32 instruction set support
	STATE1 ID_PFR0 = 0x0F << 4 //+ T32 instruction set support
)

const (
	STATE0n = 0
	STATE1n = 4
)

const (
	SECURITY ID_PFR1 = 0x0F << 4 //+ Identifies whether the Security Extension is implemented
	MPROGMOD ID_PFR1 = 0x0F << 8 //+ Identifies support for the M-Profile programmers' model support
)

const (
	SECURITYn = 4
	MPROGMODn = 8
)

const (
	MPROFDBG ID_DFR0 = 0x0F << 20 //+ Indicates the supported M-profile debug architecture
)

const (
	MPROFDBGn = 20
)

const (
	IMPDEF0 ID_AFR0 = 0x0F << 0  //+ IMPLEMENTATION DEFINED meaning
	IMPDEF1 ID_AFR0 = 0x0F << 4  //+ IMPLEMENTATION DEFINED meaning
	IMPDEF2 ID_AFR0 = 0x0F << 8  //+ IMPLEMENTATION DEFINED meaning
	IMPDEF3 ID_AFR0 = 0x0F << 12 //+ IMPLEMENTATION DEFINED meaning
)

const (
	IMPDEF0n = 0
	IMPDEF1n = 4
	IMPDEF2n = 8
	IMPDEF3n = 12
)

const (
	PMSA     ID_MMFR0 = 0x0F << 4  //+ Indicates support for the protected memory system architecture (PMSA)
	OUTERSHR ID_MMFR0 = 0x0F << 8  //+ Indicates the outermost shareability domain implemented
	SHARELVL ID_MMFR0 = 0x0F << 12 //+ Indicates the number of shareability levels implemented
	TCM      ID_MMFR0 = 0x0F << 16 //+ Indicates support for tightly coupled memories (TCMs)
	AUXREG   ID_MMFR0 = 0x0F << 20 //+ Indicates support for Auxiliary Control Registers
)

const (
	PMSAn     = 4
	OUTERSHRn = 8
	SHARELVLn = 12
	TCMn      = 16
	AUXREGn   = 20
)

const (
	WFISTALL ID_MMFR2 = 0x0F << 24 //+ Indicates the support for Wait For Interrupt (WFI) stalling
)

const (
	WFISTALLn = 24
)

const (
	CMAINTVA ID_MMFR3 = 0x0F << 0 //+ Indicates the supported cache maintenance operations by address
	CMAINTSW ID_MMFR3 = 0x0F << 4 //+ Indicates the supported cache maintenance operations by set/way
	BPMAINT  ID_MMFR3 = 0x0F << 8 //+ Indicates the supported branch predictor maintenance
)

const (
	CMAINTVAn = 0
	CMAINTSWn = 4
	BPMAINTn  = 8
)

const (
	BITCOUNT  ID_ISAR0 = 0x0F << 4  //+ Indicates the supported bit count instructions
	BITFIELD  ID_ISAR0 = 0x0F << 8  //+ Indicates the supported bit field instructions
	CMPBRANCH ID_ISAR0 = 0x0F << 12 //+ Indicates the supported combined Compare and Branch instructions
	COPROC    ID_ISAR0 = 0x0F << 16 //+ Indicates the supported Coprocessor instructions
	DEBUG     ID_ISAR0 = 0x0F << 20 //+ Indicates the implemented Debug instructions
	DIVIDE    ID_ISAR0 = 0x0F << 24 //+ Indicates the supported Divide instructions
)

const (
	BITCOUNTn  = 4
	BITFIELDn  = 8
	CMPBRANCHn = 12
	COPROCn    = 16
	DEBUGn     = 20
	DIVIDEn    = 24
)

const (
	EXTEND    ID_ISAR1 = 0x0F << 12 //+ Indicates the implemented Extend instructions
	IFTHEN    ID_ISAR1 = 0x0F << 16 //+ Indicates the implemented If-Then instructions
	IMMEDIATE ID_ISAR1 = 0x0F << 20 //+ Indicates the implemented for data-processing instructions with long immediates
	INTERWORK ID_ISAR1 = 0x0F << 24 //+ Indicates the implemented Interworking instructions
)

const (
	EXTENDn    = 12
	IFTHENn    = 16
	IMMEDIATEn = 20
	INTERWORKn = 24
)

const (
	LOADSTORE      ID_ISAR2 = 0x0F << 0  //+ Indicates the implemented additional load/store instructions
	MEMHINT        ID_ISAR2 = 0x0F << 4  //+ Indicates the implemented Memory Hint instructions
	MULTIACCESSINT ID_ISAR2 = 0x0F << 8  //+ Indicates the support for interruptible multi-access instructions
	MULT           ID_ISAR2 = 0x0F << 12 //+ Indicates the implemented additional Multiply instructions
	MULTS          ID_ISAR2 = 0x0F << 16 //+ Indicates the implemented advanced signed Multiply instructions
	MULTU          ID_ISAR2 = 0x0F << 20 //+ Indicates the implemented advanced unsigned Multiply instructions
	REVERSAL       ID_ISAR2 = 0x0F << 28 //+ Indicates the implemented Reversal instructions
)

const (
	LOADSTOREn      = 0
	MEMHINTn        = 4
	MULTIACCESSINTn = 8
	MULTn           = 12
	MULTSn          = 16
	MULTUn          = 20
	REVERSALn       = 28
)

const (
	SATURATE  ID_ISAR3 = 0x0F << 0  //+ Indicates the implemented saturating instructions
	SIMD      ID_ISAR3 = 0x0F << 4  //+ Indicates the implemented SIMD instructions
	SVC       ID_ISAR3 = 0x0F << 8  //+ Indicates the implemented SVC instructions
	SYNCHPRIM ID_ISAR3 = 0x0F << 12 //+ Used in conjunction with ID_ISAR4.SynchPrim_frac to indicate the implemented Synchronization Primitive instructions
	TABBRANCH ID_ISAR3 = 0x0F << 16 //+ Indicates the implemented Table Branch instructions
	T32COPY   ID_ISAR3 = 0x0F << 20 //+ Indicates the support for T32 non flag-setting MOV instructions
	TRUENOP   ID_ISAR3 = 0x0F << 24 //+ Indicates the implemented true NOP instructions
)

const (
	SATURATEn  = 0
	SIMDn      = 4
	SVCn       = 8
	SYNCHPRIMn = 12
	TABBRANCHn = 16
	T32COPYn   = 20
	TRUENOPn   = 24
)

const (
	UNPRIV        ID_ISAR4 = 0x0F << 0  //+ Indicates the implemented unprivileged instructions
	WITHSHIFTS    ID_ISAR4 = 0x0F << 4  //+ Indicates the support for writeback addressing modes
	WRITEBACK     ID_ISAR4 = 0x0F << 8  //+ Indicates the support for writeback addressing modes
	BARRIER       ID_ISAR4 = 0x0F << 16 //+ Indicates the implemented Barrier instructions
	SYNCPRIM_FRAC ID_ISAR4 = 0x0F << 20 //+ Used in conjunction with ID_ISAR3.SynchPrim to indicate the implemented Synchronization Primitive instructions
	PSR_M         ID_ISAR4 = 0x0F << 24 //+ Indicates the implemented M profile instructions to modify the PSRs
)

const (
	UNPRIVn        = 0
	WITHSHIFTSn    = 4
	WRITEBACKn     = 8
	BARRIERn       = 16
	SYNCPRIM_FRACn = 20
	PSR_Mn         = 24
)

const (
	IMINLINE CTR = 0x0F << 0  //+ Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the PE
	RES1_1   CTR = 0x03 << 14 //+ Reserved, RES1
	DMINLINE CTR = 0x0F << 16 //+ Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the PE
	ERG      CTR = 0x0F << 20 //+ Log2 of the number of words of the maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions
	CWG      CTR = 0x0F << 24 //+ Log2 of the number of words of the maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified
	RES1     CTR = 0x01 << 31 //+ Reserved, RES1
)

const (
	IMINLINEn = 0
	RES1_1n   = 14
	DMINLINEn = 16
	ERGn      = 20
	CWGn      = 24
	RES1n     = 31
)

const (
	CP0  CPACR = 0x03 << 0  //+ Controls access privileges for coprocessor 0
	CP1  CPACR = 0x03 << 2  //+ Controls access privileges for coprocessor 1
	CP2  CPACR = 0x03 << 4  //+ Controls access privileges for coprocessor 2
	CP3  CPACR = 0x03 << 6  //+ Controls access privileges for coprocessor 3
	CP4  CPACR = 0x03 << 8  //+ Controls access privileges for coprocessor 4
	CP5  CPACR = 0x03 << 10 //+ Controls access privileges for coprocessor 5
	CP6  CPACR = 0x03 << 12 //+ Controls access privileges for coprocessor 6
	CP7  CPACR = 0x03 << 14 //+ Controls access privileges for coprocessor 7
	CP10 CPACR = 0x03 << 20 //+ Defines the access rights for the floating-point functionality
	CP11 CPACR = 0x03 << 22 //+ The value in this field is ignored. If the implementation does not include the FP Extension, this field is RAZ/WI. If the value of this bit is not programmed to the same value as the CP10 field, then the value is UNKNOWN
)

const (
	CP0n  = 0
	CP1n  = 2
	CP2n  = 4
	CP3n  = 6
	CP4n  = 8
	CP5n  = 10
	CP6n  = 12
	CP7n  = 14
	CP10n = 20
	CP11n = 22
)

const (
	CP0  NSACR = 0x01 << 0  //+ Enables Non-secure access to coprocessor CP0
	CP1  NSACR = 0x01 << 1  //+ Enables Non-secure access to coprocessor CP1
	CP2  NSACR = 0x01 << 2  //+ Enables Non-secure access to coprocessor CP2
	CP3  NSACR = 0x01 << 3  //+ Enables Non-secure access to coprocessor CP3
	CP4  NSACR = 0x01 << 4  //+ Enables Non-secure access to coprocessor CP4
	CP5  NSACR = 0x01 << 5  //+ Enables Non-secure access to coprocessor CP5
	CP6  NSACR = 0x01 << 6  //+ Enables Non-secure access to coprocessor CP6
	CP7  NSACR = 0x01 << 7  //+ Enables Non-secure access to coprocessor CP7
	CP10 NSACR = 0x01 << 10 //+ Enables Non-secure access to the Floating-point Extension
	CP11 NSACR = 0x01 << 11 //+ Enables Non-secure access to the Floating-point Extension
)

const (
	CP0n  = 0
	CP1n  = 1
	CP2n  = 2
	CP3n  = 3
	CP4n  = 4
	CP5n  = 5
	CP6n  = 6
	CP7n  = 7
	CP10n = 10
	CP11n = 11
)

const (
	SEPARATE MPU_TYPE = 0x01 << 0 //+ Indicates support for separate instructions and data address regions
	DREGION  MPU_TYPE = 0xFF << 8 //+ Number of regions supported by the MPU
)

const (
	SEPARATEn = 0
	DREGIONn  = 8
)

const (
	ENABLE     MPU_CTRL = 0x01 << 0 //+ Enables the MPU
	HFNMIENA   MPU_CTRL = 0x01 << 1 //+ Controls whether handlers executing with priority less than 0 access memory with the MPU enabled or disabled. This applies to HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1
	PRIVDEFENA MPU_CTRL = 0x01 << 2 //+ Controls whether the default memory map is enabled for privileged software
)

const (
	ENABLEn     = 0
	HFNMIENAn   = 1
	PRIVDEFENAn = 2
)

const (
	XN   MPU_RBAR = 0x01 << 0      //+ Defines whether code can be executed from this region
	AP   MPU_RBAR = 0x03 << 1      //+ Defines the access permissions for this region
	SH   MPU_RBAR = 0x03 << 3      //+ Defines the Shareability domain of this region for Normal memory
	BASE MPU_RBAR = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
)

const (
	XNn   = 0
	APn   = 1
	SHn   = 3
	BASEn = 5
)

const (
	EN       MPU_RLAR = 0x01 << 0      //+ Region enable
	ATTRINDX MPU_RLAR = 0x07 << 1      //+ Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
	LIMIT    MPU_RLAR = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
)

const (
	ENn       = 0
	ATTRINDXn = 1
	LIMITn    = 5
)

const (
	XN   MPU_RBAR_A1 = 0x01 << 0      //+ Defines whether code can be executed from this region
	AP   MPU_RBAR_A1 = 0x03 << 1      //+ Defines the access permissions for this region
	SH   MPU_RBAR_A1 = 0x03 << 3      //+ Defines the Shareability domain of this region for Normal memory
	BASE MPU_RBAR_A1 = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
)

const (
	XNn   = 0
	APn   = 1
	SHn   = 3
	BASEn = 5
)

const (
	EN       MPU_RLAR_A1 = 0x01 << 0      //+ Region enable
	ATTRINDX MPU_RLAR_A1 = 0x07 << 1      //+ Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
	LIMIT    MPU_RLAR_A1 = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
)

const (
	ENn       = 0
	ATTRINDXn = 1
	LIMITn    = 5
)

const (
	XN   MPU_RBAR_A2 = 0x01 << 0      //+ Defines whether code can be executed from this region
	AP   MPU_RBAR_A2 = 0x03 << 1      //+ Defines the access permissions for this region
	SH   MPU_RBAR_A2 = 0x03 << 3      //+ Defines the Shareability domain of this region for Normal memory
	BASE MPU_RBAR_A2 = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
)

const (
	XNn   = 0
	APn   = 1
	SHn   = 3
	BASEn = 5
)

const (
	EN       MPU_RLAR_A2 = 0x01 << 0      //+ Region enable
	ATTRINDX MPU_RLAR_A2 = 0x07 << 1      //+ Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
	LIMIT    MPU_RLAR_A2 = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
)

const (
	ENn       = 0
	ATTRINDXn = 1
	LIMITn    = 5
)

const (
	XN   MPU_RBAR_A3 = 0x01 << 0      //+ Defines whether code can be executed from this region
	AP   MPU_RBAR_A3 = 0x03 << 1      //+ Defines the access permissions for this region
	SH   MPU_RBAR_A3 = 0x03 << 3      //+ Defines the Shareability domain of this region for Normal memory
	BASE MPU_RBAR_A3 = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the lower inclusive limit of the selected MPU memory region. This value is zero extended to provide the base address to be checked against
)

const (
	XNn   = 0
	APn   = 1
	SHn   = 3
	BASEn = 5
)

const (
	EN       MPU_RLAR_A3 = 0x01 << 0      //+ Region enable
	ATTRINDX MPU_RLAR_A3 = 0x07 << 1      //+ Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1 fields
	LIMIT    MPU_RLAR_A3 = 0x7FFFFFF << 5 //+ Contains bits [31:5] of the upper inclusive limit of the selected MPU memory region. This value is postfixed with 0x1F to provide the limit address to be checked against
)

const (
	ENn       = 0
	ATTRINDXn = 1
	LIMITn    = 5
)

const (
	ATTR0 MPU_MAIR0 = 0xFF << 0  //+ Memory attribute encoding for MPU regions with an AttrIndex of 0
	ATTR1 MPU_MAIR0 = 0xFF << 8  //+ Memory attribute encoding for MPU regions with an AttrIndex of 1
	ATTR2 MPU_MAIR0 = 0xFF << 16 //+ Memory attribute encoding for MPU regions with an AttrIndex of 2
	ATTR3 MPU_MAIR0 = 0xFF << 24 //+ Memory attribute encoding for MPU regions with an AttrIndex of 3
)

const (
	ATTR0n = 0
	ATTR1n = 8
	ATTR2n = 16
	ATTR3n = 24
)

const (
	ATTR4 MPU_MAIR1 = 0xFF << 0  //+ Memory attribute encoding for MPU regions with an AttrIndex of 4
	ATTR5 MPU_MAIR1 = 0xFF << 8  //+ Memory attribute encoding for MPU regions with an AttrIndex of 5
	ATTR6 MPU_MAIR1 = 0xFF << 16 //+ Memory attribute encoding for MPU regions with an AttrIndex of 6
	ATTR7 MPU_MAIR1 = 0xFF << 24 //+ Memory attribute encoding for MPU regions with an AttrIndex of 7
)

const (
	ATTR4n = 0
	ATTR5n = 8
	ATTR6n = 16
	ATTR7n = 24
)

const (
	ENABLE SAU_CTRL = 0x01 << 0 //+ Enables the SAU
	ALLNS  SAU_CTRL = 0x01 << 1 //+ When SAU_CTRL.ENABLE is 0 this bit controls if the memory is marked as Non-secure or Secure
)

const (
	ENABLEn = 0
	ALLNSn  = 1
)

const (
	BADDR SAU_RBAR = 0x7FFFFFF << 5 //+ Holds bits [31:5] of the base address for the selected SAU region
)

const (
	BADDRn = 5
)

const (
	ENABLE SAU_RLAR = 0x01 << 0      //+ SAU region enable
	NSC    SAU_RLAR = 0x01 << 1      //+ Controls whether Non-secure state is permitted to execute an SG instruction from this region
	LADDR  SAU_RLAR = 0x7FFFFFF << 5 //+ Holds bits [31:5] of the limit address for the selected SAU region
)

const (
	ENABLEn = 0
	NSCn    = 1
	LADDRn  = 5
)

const (
	INVEP     SFSR = 0x01 << 0 //+ This bit is set if a function call from the Non-secure state or exception targets a non-SG instruction in the Secure state. This bit is also set if the target address is a SG instruction, but there is no matching SAU/IDAU region with the NSC flag set
	INVIS     SFSR = 0x01 << 1 //+ This bit is set if the integrity signature in an exception stack frame is found to be invalid during the unstacking operation
	INVER     SFSR = 0x01 << 2 //+ This can be caused by EXC_RETURN.DCRS being set to 0 when returning from an exception in the Non-secure state, or by EXC_RETURN.ES being set to 1 when returning from an exception in the Non-secure state
	AUVIOL    SFSR = 0x01 << 3 //+ Sticky flag indicating that an attempt was made to access parts of the address space that are marked as Secure with NS-Req for the transaction set to Non-secure. This bit is not set if the violation occurred during lazy state preservation. See LSPERR
	INVTRAN   SFSR = 0x01 << 4 //+ Sticky flag indicating that an exception was raised due to a branch that was not flagged as being domain crossing causing a transition from Secure to Non-secure memory
	LSPERR    SFSR = 0x01 << 5 //+ Stick flag indicating that an SAU or IDAU violation occurred during the lazy preservation of floating-point state
	SFARVALID SFSR = 0x01 << 6 //+ This bit is set when the SFAR register contains a valid value. As with similar fields, such as BFSR.BFARVALID and MMFSR.MMARVALID, this bit can be cleared by other exceptions, such as BusFault
	LSERR     SFSR = 0x01 << 7 //+ Sticky flag indicating that an error occurred during lazy state activation or deactivation
)

const (
	INVEPn     = 0
	INVISn     = 1
	INVERn     = 2
	AUVIOLn    = 3
	INVTRANn   = 4
	LSPERRn    = 5
	SFARVALIDn = 6
	LSERRn     = 7
)

const (
	C_DEBUGEN    DHCSR = 0x01 << 0  //+ Enable Halting debug
	C_HALT       DHCSR = 0x01 << 1  //+ PE enter Debug state halt request
	C_STEP       DHCSR = 0x01 << 2  //+ Enable single instruction step
	C_MASKINTS   DHCSR = 0x01 << 3  //+ When debug is enabled, the debugger can write to this bit to mask PendSV, SysTick and external configurable interrupts
	C_SNAPSTALL  DHCSR = 0x01 << 5  //+ Allow imprecise entry to Debug state
	S_REGRDY     DHCSR = 0x01 << 16 //+ Handshake flag to transfers through the DCRDR
	S_HALT       DHCSR = 0x01 << 17 //+ Indicates whether the PE is in Debug state
	S_SLEEP      DHCSR = 0x01 << 18 //+ Indicates whether the PE is sleeping
	S_LOCKUP     DHCSR = 0x01 << 19 //+ Indicates whether the PE is in Lockup state
	S_SDE        DHCSR = 0x01 << 20 //+ Indicates whether Secure invasive debug is allowed
	S_RETIRE_ST  DHCSR = 0x01 << 24 //+ Set to 1 every time the PE retires one of more instructions
	S_RESET_ST   DHCSR = 0x01 << 25 //+ Indicates whether the PE has been reset since the last read of the DHCSR
	S_RESTART_ST DHCSR = 0x01 << 26 //+ Indicates the PE has processed a request to clear DHCSR.C_HALT to 0. That is, either a write to DHCSR that clears DHCSR.C_HALT from 1 to 0, or an External Restart Request
)

const (
	C_DEBUGENn    = 0
	C_HALTn       = 1
	C_STEPn       = 2
	C_MASKINTSn   = 3
	C_SNAPSTALLn  = 5
	S_REGRDYn     = 16
	S_HALTn       = 17
	S_SLEEPn      = 18
	S_LOCKUPn     = 19
	S_SDEn        = 20
	S_RETIRE_STn  = 24
	S_RESET_STn   = 25
	S_RESTART_STn = 26
)

const (
	REGSEL DCRSR = 0x7F << 0  //+ Specifies the general-purpose register, special-purpose register, or FP register to transfer
	REGWNR DCRSR = 0x01 << 16 //+ Specifies the access type for the transfer
)

const (
	REGSELn = 0
	REGWNRn = 16
)

const (
	VC_CORERESET DEMCR = 0x01 << 0  //+ Enable Reset Vector Catch. This causes a warm reset to halt a running system
	VC_MMERR     DEMCR = 0x01 << 4  //+ Enable halting debug trap on a MemManage exception
	VC_NOCPERR   DEMCR = 0x01 << 5  //+ Enable halting debug trap on a UsageFault caused by an access to a coprocessor
	VC_CHKERR    DEMCR = 0x01 << 6  //+ Enable halting debug trap on a UsageFault exception caused by a checking error, for example an alignment check error
	VC_STATERR   DEMCR = 0x01 << 7  //+ Enable halting debug trap on a UsageFault exception caused by a state information error, for example an Undefined Instruction exception
	VC_BUSERR    DEMCR = 0x01 << 8  //+ BusFault exception halting debug vector catch enable
	VC_INTERR    DEMCR = 0x01 << 9  //+ Enable halting debug vector catch for faults during exception entry and return
	VC_HARDERR   DEMCR = 0x01 << 10 //+ HardFault exception halting debug vector catch enable
	VC_SFERR     DEMCR = 0x01 << 11 //+ SecureFault exception halting debug vector catch enable
	MON_EN       DEMCR = 0x01 << 16 //+ Enable the DebugMonitor exception
	MON_PEND     DEMCR = 0x01 << 17 //+ Sets or clears the pending state of the DebugMonitor exception
	MON_STEP     DEMCR = 0x01 << 18 //+ Enable DebugMonitor stepping
	MON_REQ      DEMCR = 0x01 << 19 //+ DebugMonitor semaphore bit
	SDME         DEMCR = 0x01 << 20 //+ Indicates whether the DebugMonitor targets the Secure or the Non-secure state and whether debug events are allowed in Secure state
	TRCENA       DEMCR = 0x01 << 24 //+ Global enable for all DWT and ITM features
)

const (
	VC_CORERESETn = 0
	VC_MMERRn     = 4
	VC_NOCPERRn   = 5
	VC_CHKERRn    = 6
	VC_STATERRn   = 7
	VC_BUSERRn    = 8
	VC_INTERRn    = 9
	VC_HARDERRn   = 10
	VC_SFERRn     = 11
	MON_ENn       = 16
	MON_PENDn     = 17
	MON_STEPn     = 18
	MON_REQn      = 19
	SDMEn         = 20
	TRCENAn       = 24
)

const (
	SBRSELEN DSCSR = 0x01 << 0  //+ Controls whether the SBRSEL field or the current Security state of the processor selects which version of the memory-mapped Banked registers are accessed to the debugger
	SBRSEL   DSCSR = 0x01 << 1  //+ If SBRSELEN is 1 this bit selects whether the Non-secure or the Secure version of the memory-mapped Banked registers are accessible to the debugger
	CDS      DSCSR = 0x01 << 16 //+ This field indicates the current Security state of the processor
	CDSKEY   DSCSR = 0x01 << 17 //+ Writes to the CDS bit are ignored unless CDSKEY is concurrently written to zero
)

const (
	SBRSELENn = 0
	SBRSELn   = 1
	CDSn      = 16
	CDSKEYn   = 17
)

const (
	LSPACT    FPCCR = 0x01 << 0  //+ Indicates whether lazy preservation of the floating-point state is active
	USER      FPCCR = 0x01 << 1  //+ Indicates the privilege level of the software executing when the PE allocated the floating-point stack frame
	S         FPCCR = 0x01 << 2  //+ Security status of the floating-point context. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state. This bit is updated whenever lazy state preservation is activated, or when a floating-point instruction is executed
	THREAD    FPCCR = 0x01 << 3  //+ Indicates the PE mode when it allocated the floating-point stack frame
	HFRDY     FPCCR = 0x01 << 4  //+ Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the HardFault exception to pending
	MMRDY     FPCCR = 0x01 << 5  //+ Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the MemManage exception to pending
	BFRDY     FPCCR = 0x01 << 6  //+ Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the BusFault exception to pending
	SFRDY     FPCCR = 0x01 << 7  //+ Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the SecureFault exception to pending. This bit is only present in the Secure version of the register, and behaves as RAZ/WI when accessed from the Non-secure state
	MONRDY    FPCCR = 0x01 << 8  //+ Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the DebugMonitor exception to pending
	SPLIMVIOL FPCCR = 0x01 << 9  //+ This bit is banked between the Security states and indicates whether the floating-point context violates the stack pointer limit that was active when lazy state preservation was activated. SPLIMVIOL modifies the lazy floating-point state preservation behavior
	UFRDY     FPCCR = 0x01 << 10 //+ Indicates whether the software executing when the PE allocated the floating-point stack frame was able to set the UsageFault exception to pending
	TS        FPCCR = 0x01 << 26 //+ Treat floating-point registers as Secure enable
	CLRONRETS FPCCR = 0x01 << 27 //+ This bit controls whether the CLRONRET bit is writeable from the Non-secure state
	CLRONRET  FPCCR = 0x01 << 28 //+ Clear floating-point caller saved registers on exception return
	LSPENS    FPCCR = 0x01 << 29 //+ This bit controls whether the LSPEN bit is writeable from the Non-secure state
	LSPEN     FPCCR = 0x01 << 30 //+ Enables lazy context save of floating-point state
	ASPEN     FPCCR = 0x01 << 31 //+ When this bit is set to 1, execution of a floating-point instruction sets the CONTROL.FPCA bit to 1
)

const (
	LSPACTn    = 0
	USERn      = 1
	Sn         = 2
	THREADn    = 3
	HFRDYn     = 4
	MMRDYn     = 5
	BFRDYn     = 6
	SFRDYn     = 7
	MONRDYn    = 8
	SPLIMVIOLn = 9
	UFRDYn     = 10
	TSn        = 26
	CLRONRETSn = 27
	CLRONRETn  = 28
	LSPENSn    = 29
	LSPENn     = 30
	ASPENn     = 31
)

const (
	ADDRESS FPCAR = 0x1FFFFFFF << 3 //+ The location of the unpopulated floating-point register space allocated on an exception stack frame
)

const (
	ADDRESSn = 3
)

const (
	RMODE FPDSCR = 0x03 << 22 //+ Default value for FPSCR.RMode
	FZ    FPDSCR = 0x01 << 24 //+ Default value for FPSCR.FZ
	DN    FPDSCR = 0x01 << 25 //+ Default value for FPSCR.DN
	AHP   FPDSCR = 0x01 << 26 //+ Default value for FPSCR.AHP
)

const (
	RMODEn = 22
	FZn    = 24
	DNn    = 25
	AHPn   = 26
)

const (
	SIMDREG  MVFR0 = 0x0F << 0  //+ Indicates size of FP register file
	FPSP     MVFR0 = 0x0F << 4  //+ Indicates support for FP single-precision operations
	FPDP     MVFR0 = 0x0F << 8  //+ Indicates support for FP double-precision operations
	FPDIVIDE MVFR0 = 0x0F << 16 //+ Indicates the support for FP divide operations
	FPSQRT   MVFR0 = 0x0F << 20 //+ Indicates the support for FP square root operations
	FPROUND  MVFR0 = 0x0F << 28 //+ Indicates the rounding modes supported by the FP Extension
)

const (
	SIMDREGn  = 0
	FPSPn     = 4
	FPDPn     = 8
	FPDIVIDEn = 16
	FPSQRTn   = 20
	FPROUNDn  = 28
)

const (
	FPFTZ  MVFR1 = 0x0F << 0  //+ Indicates whether subnormals are always flushed-to-zero
	FPDNAN MVFR1 = 0x0F << 4  //+ Indicates whether the FP hardware implementation supports NaN propagation
	FPHP   MVFR1 = 0x0F << 24 //+ Indicates whether the FP Extension implements half-precision FP conversion instructions
	FMAC   MVFR1 = 0x0F << 28 //+ Indicates whether the FP Extension implements the fused multiply accumulate instructions
)

const (
	FPFTZn  = 0
	FPDNANn = 4
	FPHPn   = 24
	FMACn   = 28
)

const (
	FPMISC MVFR2 = 0x0F << 4 //+ Indicates support for miscellaneous FP features
)

const (
	FPMISCn = 4
)

const (
	ARCHPART  DDEVARCH = 0xFFF << 0  //+ Defines the architecture of the component
	ARCHVER   DDEVARCH = 0x0F << 12  //+ Defines the architecture version of the component
	REVISION  DDEVARCH = 0x0F << 16  //+ Defines the architecture revision of the component
	PRESENT   DDEVARCH = 0x01 << 20  //+ Defines that the DEVARCH register is present
	ARCHITECT DDEVARCH = 0x7FF << 21 //+ Defines the architect of the component. Bits [31:28] are the JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the JEP106 ID code.
)

const (
	ARCHPARTn  = 0
	ARCHVERn   = 12
	REVISIONn  = 16
	PRESENTn   = 20
	ARCHITECTn = 21
)

const (
	MAJOR DDEVTYPE = 0x0F << 0 //+ CoreSight major type
	SUB   DDEVTYPE = 0x0F << 4 //+ Component sub-type
)

const (
	MAJORn = 0
	SUBn   = 4
)

const (
	DES_2 DPIDR4 = 0x0F << 0 //+ See CoreSight Architecture Specification
	SIZE  DPIDR4 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_2n = 0
	SIZEn  = 4
)

const (
	PART_1 DPIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	DES_0  DPIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PART_1n = 0
	DES_0n  = 4
)

const (
	DES_1    DPIDR2 = 0x07 << 0 //+ See CoreSight Architecture Specification
	JEDEC    DPIDR2 = 0x01 << 3 //+ See CoreSight Architecture Specification
	REVISION DPIDR2 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	DES_1n    = 0
	JEDECn    = 3
	REVISIONn = 4
)

const (
	CMOD   DPIDR3 = 0x0F << 0 //+ See CoreSight Architecture Specification
	REVAND DPIDR3 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	CMODn   = 0
	REVANDn = 4
)

const (
	PRMBL_1 DCIDR1 = 0x0F << 0 //+ See CoreSight Architecture Specification
	CLASS   DCIDR1 = 0x0F << 4 //+ See CoreSight Architecture Specification
)

const (
	PRMBL_1n = 0
	CLASSn   = 4
)

const (
	IDLE     TRCSTATR = 0x01 << 0 //+ Indicates that the trace unit is inactive
	PMSTABLE TRCSTATR = 0x01 << 1 //+ Indicates whether the ETM-Teal registers are stable and can be read
)

const (
	IDLEn     = 0
	PMSTABLEn = 1
)

const (
	BB   TRCCONFIGR = 0x01 << 3  //+ Branch broadcast mode
	CCI  TRCCONFIGR = 0x01 << 4  //+ Cycle counting in instruction trace
	COND TRCCONFIGR = 0x3F << 5  //+ Conditional instruction tracing
	TS   TRCCONFIGR = 0x01 << 11 //+ Global timestamp tracing
	RS   TRCCONFIGR = 0x01 << 12 //+ Return stack enable
)

const (
	BBn   = 3
	CCIn  = 4
	CONDn = 5
	TSn   = 11
	RSn   = 12
)

const (
	SEL0  TRCEVENTCTL0R = 0x07 << 0  //+ Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0]. When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
	TYPE0 TRCEVENTCTL0R = 0x01 << 7  //+ Selects the resource type for event 0
	SEL1  TRCEVENTCTL0R = 0x07 << 8  //+ Selects the resource number, based on the value of TYPE1: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL1[2:0]. When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL1[2:0]
	TYPE1 TRCEVENTCTL0R = 0x01 << 15 //+ Selects the resource type for event 1
)

const (
	SEL0n  = 0
	TYPE0n = 7
	SEL1n  = 8
	TYPE1n = 15
)

const (
	INSTEN0    TRCEVENTCTL1R = 0x01 << 0  //+ One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs
	INSTEN1    TRCEVENTCTL1R = 0x01 << 1  //+ One bit per event, to enable generation of an event element in the instruction trace stream when the selected event occurs
	ATB        TRCEVENTCTL1R = 0x01 << 11 //+ ATB enabled
	LPOVERRIDE TRCEVENTCTL1R = 0x01 << 12 //+ Low power state behavior override
)

const (
	INSTEN0n    = 0
	INSTEN1n    = 1
	ATBn        = 11
	LPOVERRIDEn = 12
)

const (
	LEVEL        TRCSTALLCTLR = 0x03 << 2  //+ Threshold at which stalling becomes active. This provides four levels. This level can be varied to optimize the level of invasion caused by stalling, balanced against the risk of a FIFO overflow
	ISTALL       TRCSTALLCTLR = 0x01 << 8  //+ Stall processor based on instruction trace buffer space
	INSTPRIORITY TRCSTALLCTLR = 0x01 << 10 //+ Reserved, RES0
)

const (
	LEVELn        = 2
	ISTALLn       = 8
	INSTPRIORITYn = 10
)

const (
	SEL0  TRCTSCTLR = 0x03 << 0 //+ Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0]. When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
	TYPE0 TRCTSCTLR = 0x01 << 7 //+ Selects the resource type for event 0
)

const (
	SEL0n  = 0
	TYPE0n = 7
)

const (
	SEL0       TRCVICTLR = 0x03 << 0  //+ Selects the resource number, based on the value of TYPE0: When TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0]. When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined by SEL0[2:0]
	TYPE0      TRCVICTLR = 0x01 << 7  //+ Selects the resource type for event 0
	SSSTATUS   TRCVICTLR = 0x01 << 9  //+ Indicates the current status of the start/stop logic
	TRCRESET   TRCVICTLR = 0x01 << 10 //+ Selects whether a reset exception must always be traced
	TRCERR     TRCVICTLR = 0x01 << 11 //+ Selects whether a system error exception must always be traced
	EXLEVEL_S0 TRCVICTLR = 0x01 << 16 //+ In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level
	EXLEVEL_S3 TRCVICTLR = 0x01 << 19 //+ In Secure state, each bit controls whether instruction tracing is enabled for the corresponding exception level
)

const (
	SEL0n       = 0
	TYPE0n      = 7
	SSSTATUSn   = 9
	TRCRESETn   = 10
	TRCERRn     = 11
	EXLEVEL_S0n = 16
	EXLEVEL_S3n = 19
)

const (
	RES1      TRCIDR0 = 0x01 << 0  //+ Reserved, RES1
	INSTP0    TRCIDR0 = 0x03 << 1  //+ reads as `ImpDef
	TRCDATA   TRCIDR0 = 0x03 << 3  //+ reads as `ImpDef
	TRCBB     TRCIDR0 = 0x01 << 5  //+ reads as `ImpDef
	TRCCOND   TRCIDR0 = 0x01 << 6  //+ reads as `ImpDef
	TRCCCI    TRCIDR0 = 0x01 << 7  //+ reads as `ImpDef
	RETSTACK  TRCIDR0 = 0x01 << 9  //+ reads as `ImpDef
	NUMEVENT  TRCIDR0 = 0x03 << 10 //+ reads as `ImpDef
	CONDTYPE  TRCIDR0 = 0x03 << 12 //+ reads as `ImpDef
	QFILT     TRCIDR0 = 0x01 << 14 //+ reads as `ImpDef
	QSUPP     TRCIDR0 = 0x03 << 15 //+ reads as `ImpDef
	TRCEXDATA TRCIDR0 = 0x01 << 17 //+ reads as `ImpDef
	TSSIZE    TRCIDR0 = 0x1F << 24 //+ reads as `ImpDef
	COMMOPT   TRCIDR0 = 0x01 << 29 //+ reads as `ImpDef
)

const (
	RES1n      = 0
	INSTP0n    = 1
	TRCDATAn   = 3
	TRCBBn     = 5
	TRCCONDn   = 6
	TRCCCIn    = 7
	RETSTACKn  = 9
	NUMEVENTn  = 10
	CONDTYPEn  = 12
	QFILTn     = 14
	QSUPPn     = 15
	TRCEXDATAn = 17
	TSSIZEn    = 24
	COMMOPTn   = 29
)

const (
	REVISION   TRCIDR1 = 0x0F << 0  //+ reads as `ImpDef
	TRCARCHMIN TRCIDR1 = 0x0F << 4  //+ reads as 0b0000
	TRCARCHMAJ TRCIDR1 = 0x0F << 8  //+ reads as 0b0100
	RES1       TRCIDR1 = 0x0F << 12 //+ Reserved, RES1
	DESIGNER   TRCIDR1 = 0xFF << 24 //+ reads as `ImpDef
)

const (
	REVISIONn   = 0
	TRCARCHMINn = 4
	TRCARCHMAJn = 8
	RES1n       = 12
	DESIGNERn   = 24
)

const (
	IASIZE   TRCIDR2 = 0x1F << 0  //+ reads as `ImpDef
	CIDSIZE  TRCIDR2 = 0x1F << 5  //+ reads as `ImpDef
	VMIDSIZE TRCIDR2 = 0x1F << 10 //+ reads as `ImpDef
	DASIZE   TRCIDR2 = 0x1F << 15 //+ reads as `ImpDef
	DVSIZE   TRCIDR2 = 0x1F << 20 //+ reads as `ImpDef
	CCSIZE   TRCIDR2 = 0x0F << 25 //+ reads as `ImpDef
)

const (
	IASIZEn   = 0
	CIDSIZEn  = 5
	VMIDSIZEn = 10
	DASIZEn   = 15
	DVSIZEn   = 20
	CCSIZEn   = 25
)

const (
	CCITMIN    TRCIDR3 = 0xFFF << 0 //+ reads as `ImpDef
	EXLEVEL_S  TRCIDR3 = 0x0F << 16 //+ reads as `ImpDef
	EXLEVEL_NS TRCIDR3 = 0x0F << 20 //+ reads as `ImpDef
	TRCERR     TRCIDR3 = 0x01 << 24 //+ reads as `ImpDef
	SYNCPR     TRCIDR3 = 0x01 << 25 //+ reads as `ImpDef
	STALLCTL   TRCIDR3 = 0x01 << 26 //+ reads as `ImpDef
	SYSSTALL   TRCIDR3 = 0x01 << 27 //+ reads as `ImpDef
	NUMPROC    TRCIDR3 = 0x07 << 28 //+ reads as `ImpDef
	NOOVERFLOW TRCIDR3 = 0x01 << 31 //+ reads as `ImpDef
)

const (
	CCITMINn    = 0
	EXLEVEL_Sn  = 16
	EXLEVEL_NSn = 20
	TRCERRn     = 24
	SYNCPRn     = 25
	STALLCTLn   = 26
	SYSSTALLn   = 27
	NUMPROCn    = 28
	NOOVERFLOWn = 31
)

const (
	NUMACPAIRS TRCIDR4 = 0x0F << 0  //+ reads as `ImpDef
	NUMDVC     TRCIDR4 = 0x0F << 4  //+ reads as `ImpDef
	SUPPDAC    TRCIDR4 = 0x01 << 8  //+ reads as `ImpDef
	NUMPC      TRCIDR4 = 0x0F << 12 //+ reads as `ImpDef
	NUMRSPAIR  TRCIDR4 = 0x0F << 16 //+ reads as `ImpDef
	NUMSSCC    TRCIDR4 = 0x0F << 20 //+ reads as `ImpDef
	NUMCIDC    TRCIDR4 = 0x0F << 24 //+ reads as `ImpDef
	NUMVMIDC   TRCIDR4 = 0x0F << 28 //+ reads as `ImpDef
)

const (
	NUMACPAIRSn = 0
	NUMDVCn     = 4
	SUPPDACn    = 8
	NUMPCn      = 12
	NUMRSPAIRn  = 16
	NUMSSCCn    = 20
	NUMCIDCn    = 24
	NUMVMIDCn   = 28
)

const (
	NUMEXTIN    TRCIDR5 = 0x1FF << 0 //+ reads as `ImpDef
	NUMEXTINSEL TRCIDR5 = 0x07 << 9  //+ reads as `ImpDef
	TRACEIDSIZE TRCIDR5 = 0x3F << 16 //+ reads as 0x07
	ATBTRIG     TRCIDR5 = 0x01 << 22 //+ reads as `ImpDef
	LPOVERRIDE  TRCIDR5 = 0x01 << 23 //+ reads as `ImpDef
	NUMSEQSTATE TRCIDR5 = 0x07 << 25 //+ reads as `ImpDef
	NUMCNTR     TRCIDR5 = 0x07 << 28 //+ reads as `ImpDef
	REDFUNCNTR  TRCIDR5 = 0x01 << 31 //+ reads as `ImpDef
)

const (
	NUMEXTINn    = 0
	NUMEXTINSELn = 9
	TRACEIDSIZEn = 16
	ATBTRIGn     = 22
	LPOVERRIDEn  = 23
	NUMSEQSTATEn = 25
	NUMCNTRn     = 28
	REDFUNCNTRn  = 31
)

const (
	SELECT  TRCRSCTLR2 = 0xFF << 0  //+ Selects one or more resources from the wanted group. One bit is provided per resource from the group
	GROUP   TRCRSCTLR2 = 0x07 << 16 //+ Selects a group of resource
	INV     TRCRSCTLR2 = 0x01 << 20 //+ Inverts the selected resources
	PAIRINV TRCRSCTLR2 = 0x01 << 21 //+ Inverts the result of a combined pair of resources. This bit is only implemented on the lower register for a pair of resource selectors
)

const (
	SELECTn  = 0
	GROUPn   = 16
	INVn     = 20
	PAIRINVn = 21
)

const (
	SELECT  TRCRSCTLR3 = 0xFF << 0  //+ Selects one or more resources from the wanted group. One bit is provided per resource from the group
	GROUP   TRCRSCTLR3 = 0x07 << 16 //+ Selects a group of resource
	INV     TRCRSCTLR3 = 0x01 << 20 //+ Inverts the selected resources
	PAIRINV TRCRSCTLR3 = 0x01 << 21 //+ Inverts the result of a combined pair of resources. This bit is only implemented on the lower register for a pair of resource selectors
)

const (
	SELECTn  = 0
	GROUPn   = 16
	INVn     = 20
	PAIRINVn = 21
)

const (
	INST   TRCSSCSR = 0x01 << 0  //+ Reserved, RES0
	DA     TRCSSCSR = 0x01 << 1  //+ Reserved, RES0
	DV     TRCSSCSR = 0x01 << 2  //+ Reserved, RES0
	PC     TRCSSCSR = 0x01 << 3  //+ Reserved, RES1
	STATUS TRCSSCSR = 0x01 << 31 //+ Single-shot status bit. Indicates if any of the comparators, that TRCSSCCRn.SAC or TRCSSCCRn.ARC selects, have matched
)

const (
	INSTn   = 0
	DAn     = 1
	DVn     = 2
	PCn     = 3
	STATUSn = 31
)

const (
	PU TRCPDCR = 0x01 << 3 //+ Powerup request bit:
)

const (
	PUn = 3
)

const (
	POWER    TRCPDSR = 0x01 << 0 //+ Power status bit:
	STICKYPD TRCPDSR = 0x01 << 1 //+ Sticky powerdown status bit. Indicates whether the trace register state is valid:
	OSLK     TRCPDSR = 0x01 << 5 //+ OS Lock status bit:
)

const (
	POWERn    = 0
	STICKYPDn = 1
	OSLKn     = 5
)

const (
	ATREADYM TRCITIATBINR = 0x01 << 0 //+ Integration Mode instruction ATREADYM in
	AFVALIDM TRCITIATBINR = 0x01 << 1 //+ Integration Mode instruction AFVALIDM in
)

const (
	ATREADYMn = 0
	AFVALIDMn = 1
)

const (
	ATVALID TRCITIATBOUTR = 0x01 << 0 //+ Integration Mode instruction ATVALID out
	AFREADY TRCITIATBOUTR = 0x01 << 1 //+ Integration Mode instruction AFREADY out
)

const (
	ATVALIDn = 0
	AFREADYn = 1
)

const (
	SET0 TRCCLAIMSET = 0x01 << 0 //+ When a write to one of these bits occurs, with the value:
	SET1 TRCCLAIMSET = 0x01 << 1 //+ When a write to one of these bits occurs, with the value:
	SET2 TRCCLAIMSET = 0x01 << 2 //+ When a write to one of these bits occurs, with the value:
	SET3 TRCCLAIMSET = 0x01 << 3 //+ When a write to one of these bits occurs, with the value:
)

const (
	SET0n = 0
	SET1n = 1
	SET2n = 2
	SET3n = 3
)

const (
	CLR0 TRCCLAIMCLR = 0x01 << 0 //+ When a write to one of these bits occurs, with the value:
	CLR1 TRCCLAIMCLR = 0x01 << 1 //+ When a write to one of these bits occurs, with the value:
	CLR2 TRCCLAIMCLR = 0x01 << 2 //+ When a write to one of these bits occurs, with the value:
	CLR3 TRCCLAIMCLR = 0x01 << 3 //+ When a write to one of these bits occurs, with the value:
)

const (
	CLR0n = 0
	CLR1n = 1
	CLR2n = 2
	CLR3n = 3
)

const (
	NSID  TRCAUTHSTATUS = 0x03 << 0 //+ Indicates whether the trace unit supports Non-secure invasive debug:
	NSNID TRCAUTHSTATUS = 0x03 << 2 //+ Indicates whether the system enables the trace unit to support Non-secure non-invasive debug:
	SID   TRCAUTHSTATUS = 0x03 << 4 //+ Indicates whether the trace unit supports Secure invasive debug:
	SNID  TRCAUTHSTATUS = 0x03 << 6 //+ Indicates whether the system enables the trace unit to support Secure non-invasive debug:
)

const (
	NSIDn  = 0
	NSNIDn = 2
	SIDn   = 4
	SNIDn  = 6
)

const (
	ARCHID    TRCDEVARCH = 0xFFFF << 0 //+ reads as 0b0100101000010011
	REVISION  TRCDEVARCH = 0x0F << 16  //+ reads as 0b0000
	PRESENT   TRCDEVARCH = 0x01 << 20  //+ reads as 0b1
	ARCHITECT TRCDEVARCH = 0x7FF << 21 //+ reads as 0b01000111011
)

const (
	ARCHIDn    = 0
	REVISIONn  = 16
	PRESENTn   = 20
	ARCHITECTn = 21
)

const (
	MAJOR TRCDEVTYPE = 0x0F << 0 //+ reads as 0b0011
	SUB   TRCDEVTYPE = 0x0F << 4 //+ reads as 0b0001
)

const (
	MAJORn = 0
	SUBn   = 4
)

const (
	DES_2 TRCPIDR4 = 0x0F << 0 //+ reads as `ImpDef
	SIZE  TRCPIDR4 = 0x0F << 4 //+ reads as `ImpDef
)

const (
	DES_2n = 0
	SIZEn  = 4
)

const (
	PART_0 TRCPIDR1 = 0x0F << 0 //+ reads as `ImpDef
	DES_0  TRCPIDR1 = 0x0F << 4 //+ reads as `ImpDef
)

const (
	PART_0n = 0
	DES_0n  = 4
)

const (
	DES_0    TRCPIDR2 = 0x07 << 0 //+ reads as `ImpDef
	JEDEC    TRCPIDR2 = 0x01 << 3 //+ reads as 0b1
	REVISION TRCPIDR2 = 0x0F << 4 //+ reads as `ImpDef
)

const (
	DES_0n    = 0
	JEDECn    = 3
	REVISIONn = 4
)

const (
	CMOD   TRCPIDR3 = 0x0F << 0 //+ reads as `ImpDef
	REVAND TRCPIDR3 = 0x0F << 4 //+ reads as `ImpDef
)

const (
	CMODn   = 0
	REVANDn = 4
)

const (
	PRMBL_1 TRCCIDR1 = 0x0F << 0 //+ reads as 0b0000
	CLASS   TRCCIDR1 = 0x0F << 4 //+ reads as 0b1001
)

const (
	PRMBL_1n = 0
	CLASSn   = 4
)

const (
	CTIGATEEN0 CTIGATE = 0x01 << 0 //+ Enable ctichout0. Set to 0 to disable channel propagation.
	CTIGATEEN1 CTIGATE = 0x01 << 1 //+ Enable ctichout1. Set to 0 to disable channel propagation.
	CTIGATEEN2 CTIGATE = 0x01 << 2 //+ Enable ctichout2. Set to 0 to disable channel propagation.
	CTIGATEEN3 CTIGATE = 0x01 << 3 //+ Enable ctichout3. Set to 0 to disable channel propagation.
)

const (
	CTIGATEEN0n = 0
	CTIGATEEN1n = 1
	CTIGATEEN2n = 2
	CTIGATEEN3n = 3
)

const (
	ARCHID    DEVARCH = 0xFFFF << 0 //+ Indicates the component
	REVISION  DEVARCH = 0x0F << 16  //+ Indicates the architecture revision
	PRESENT   DEVARCH = 0x01 << 20  //+ Indicates whether the DEVARCH register is present
	ARCHITECT DEVARCH = 0x7FF << 21 //+ Indicates the component architect
)

const (
	ARCHIDn    = 0
	REVISIONn  = 16
	PRESENTn   = 20
	ARCHITECTn = 21
)

const (
	EXTMUXNUM DEVID = 0x1F << 0  //+ Indicates the number of multiplexers available on Trigger Inputs and Trigger Outputs that are using asicctl. The default value of 0b00000 indicates that no multiplexing is present. This value of this bit depends on the Verilog define EXTMUXNUM that you must change accordingly.
	NUMTRIG   DEVID = 0xFF << 8  //+ Number of ECT triggers available.
	NUMCH     DEVID = 0x0F << 16 //+ Number of ECT channels available
)

const (
	EXTMUXNUMn = 0
	NUMTRIGn   = 8
	NUMCHn     = 16
)

const (
	MAJOR DEVTYPE = 0x0F << 0 //+ Major classification of the type of the debug component as specified in the ARM Architecture Specification for this debug and trace component.
	SUB   DEVTYPE = 0x0F << 4 //+ Sub-classification of the type of the debug component as specified in the ARM Architecture Specification within the major classification as specified in the MAJOR field.
)

const (
	MAJORn = 0
	SUBn   = 4
)

const (
	DES_2 PIDR4 = 0x0F << 0 //+ Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
	SIZE  PIDR4 = 0x0F << 4 //+ Always 0b0000. Indicates that the device only occupies 4KB of memory
)

const (
	DES_2n = 0
	SIZEn  = 4
)

const (
	PART_1 PIDR1 = 0x0F << 0 //+ Bits[11:8] of the 12-bit part number of the component. The designer of the component assigns this part number.
	DES_0  PIDR1 = 0x0F << 4 //+ Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
)

const (
	PART_1n = 0
	DES_0n  = 4
)

const (
	DES_1    PIDR2 = 0x07 << 0 //+ Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the designer of the component.
	JEDEC    PIDR2 = 0x01 << 3 //+ Always 1. Indicates that the JEDEC-assigned designer ID is used.
	REVISION PIDR2 = 0x0F << 4 //+ This device is at r1p0
)

const (
	DES_1n    = 0
	JEDECn    = 3
	REVISIONn = 4
)

const (
	CMOD   PIDR3 = 0x0F << 0 //+ Customer Modified. Indicates whether the customer has modified the behavior of the component. In most cases, this field is 0b0000. Customers change this value when they make authorized modifications to this component.
	REVAND PIDR3 = 0x0F << 4 //+ Indicates minor errata fixes specific to the revision of the component being used, for example metal fixes after implementation. In most cases, this field is 0b0000. ARM recommends that the component designers ensure that a metal fix can change this field if required, for example, by driving it from registers that reset to 0b0000.
)

const (
	CMODn   = 0
	REVANDn = 4
)

const (
	PRMBL_1 CIDR1 = 0x0F << 0 //+ Preamble[1]. Contains bits[11:8] of the component identification code.
	CLASS   CIDR1 = 0x0F << 4 //+ Class of the component, for example, whether the component is a ROM table or a generic CoreSight component. Contains bits[15:12] of the component identification code.
)

const (
	PRMBL_1n = 0
	CLASSn   = 4
)
