// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package usb provides access to the registers of the USB peripheral.
//
// Instances:
//
//	USB  USB_BASE  -  USBCTRL  USB FS/LS controller device registers
//
// Registers:
//
//	0x000 32  ADDR_ENDP               Device address and endpoint control
//	0x004 32  ADDR_ENDP1              Interrupt endpoint 1. Only valid for HOST mode.
//	0x008 32  ADDR_ENDP2              Interrupt endpoint 2. Only valid for HOST mode.
//	0x00C 32  ADDR_ENDP3              Interrupt endpoint 3. Only valid for HOST mode.
//	0x010 32  ADDR_ENDP4              Interrupt endpoint 4. Only valid for HOST mode.
//	0x014 32  ADDR_ENDP5              Interrupt endpoint 5. Only valid for HOST mode.
//	0x018 32  ADDR_ENDP6              Interrupt endpoint 6. Only valid for HOST mode.
//	0x01C 32  ADDR_ENDP7              Interrupt endpoint 7. Only valid for HOST mode.
//	0x020 32  ADDR_ENDP8              Interrupt endpoint 8. Only valid for HOST mode.
//	0x024 32  ADDR_ENDP9              Interrupt endpoint 9. Only valid for HOST mode.
//	0x028 32  ADDR_ENDP10             Interrupt endpoint 10. Only valid for HOST mode.
//	0x02C 32  ADDR_ENDP11             Interrupt endpoint 11. Only valid for HOST mode.
//	0x030 32  ADDR_ENDP12             Interrupt endpoint 12. Only valid for HOST mode.
//	0x034 32  ADDR_ENDP13             Interrupt endpoint 13. Only valid for HOST mode.
//	0x038 32  ADDR_ENDP14             Interrupt endpoint 14. Only valid for HOST mode.
//	0x03C 32  ADDR_ENDP15             Interrupt endpoint 15. Only valid for HOST mode.
//	0x040 32  MAIN_CTRL               Main control register
//	0x044 32  SOF_WR                  Set the SOF (Start of Frame) frame number in the host controller. The SOF packet is sent every 1ms and the host will increment the frame number by 1 each time.
//	0x048 32  SOF_RD                  Read the last SOF (Start of Frame) frame number seen. In device mode the last SOF received from the host. In host mode the last SOF sent by the host.
//	0x04C 32  SIE_CTRL                SIE control register
//	0x050 32  SIE_STATUS              SIE status register
//	0x054 32  INT_EP_CTRL             interrupt endpoint control register
//	0x058 32  BUFF_STATUS             Buffer status register. A bit set here indicates that a buffer has completed on the endpoint (if the buffer interrupt is enabled). It is possible for 2 buffers to be completed, so clearing the buffer status bit may instantly re set it on the next clock cycle.
//	0x05C 32  BUFF_CPU_SHOULD_HANDLE  Which of the double buffers should be handled. Only valid if using an interrupt per buffer (i.e. not per 2 buffers). Not valid for host interrupt endpoint polling because they are only single buffered.
//	0x060 32  EP_ABORT                Device only: Can be set to ignore the buffer control register for this endpoint in case you would like to revoke a buffer. A NAK will be sent for every access to the endpoint until this bit is cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe to modify the buffer control register.
//	0x064 32  EP_ABORT_DONE           Device only: Used in conjunction with `EP_ABORT`. Set once an endpoint is idle so the programmer knows it is safe to modify the buffer control register.
//	0x068 32  EP_STALL_ARM            Device: this bit must be set in conjunction with the `STALL` bit in the buffer control register to send a STALL on EP0. The device controller clears these bits when a SETUP packet is received because the USB spec requires that a STALL condition is cleared when a SETUP packet is received.
//	0x06C 32  NAK_POLL                Used by the host controller. Sets the wait time in microseconds before trying again if the device replies with a NAK.
//	0x070 32  EP_STATUS_STALL_NAK     Device: bits are set when the `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all other endpoints it comes from the endpoint control register.
//	0x074 32  USB_MUXING              Where to connect the USB controller. Should be to_phy by default.
//	0x078 32  USB_PWR                 Overrides for the power signals in the event that the VBUS signals are not hooked up to GPIO. Set the value of the override and then the override enable to switch over to the override value.
//	0x07C 32  USBPHY_DIRECT           This register allows for direct control of the USB phy. Use in conjunction with usbphy_direct_override register to enable each override bit.
//	0x080 32  USBPHY_DIRECT_OVERRIDE  Override enable for each control in usbphy_direct
//	0x084 32  USBPHY_TRIM             Used to adjust trim values of USB phy pull down resistors.
//	0x088 32  LINESTATE_TUNING        Used for debug only.
//	0x08C 32  INTR                    Raw Interrupts
//	0x090 32  INTE                    Interrupt Enable
//	0x094 32  INTF                    Interrupt Force
//	0x098 32  INTS                    Interrupt status after masking & forcing
//	0x100 32  SOF_TIMESTAMP_RAW       Device only. Raw value of free-running PHY clock counter @48MHz. Used to calculate time between SOF events.
//	0x104 32  SOF_TIMESTAMP_LAST      Device only. Value of free-running PHY clock counter @48MHz when last SOF event occurred.
//	0x108 32  SM_STATE
//	0x10C 32  EP_TX_ERROR             TX error count for each endpoint. Write to each field to reset the counter to 0.
//	0x110 32  EP_RX_ERROR             RX error count for each endpoint. Write to each field to reset the counter to 0.
//	0x114 32  DEV_SM_WATCHDOG         Watchdog that forces the device state machine to idle and raises an interrupt if the device stays in a state that isn't idle for the configured limit. The counter is reset on every state transition. Set limit while enable is low and then set the enable.
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package usb

const (
	ADDRESS  ADDR_ENDP = 0x7F << 0  //+ In device mode, the address that the device should respond to. Set in response to a SET_ADDR setup packet from the host. In host mode set to the address of the device to communicate with.
	ENDPOINT ADDR_ENDP = 0x0F << 16 //+ Device endpoint to send data to. Only valid for HOST mode.
)

const (
	ADDRESSn  = 0
	ENDPOINTn = 16
)

const (
	ADDRESS        ADDR_ENDP1 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP1 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP1 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP1 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP2 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP2 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP2 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP2 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP3 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP3 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP3 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP3 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP4 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP4 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP4 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP4 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP5 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP5 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP5 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP5 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP6 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP6 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP6 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP6 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP7 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP7 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP7 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP7 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP8 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP8 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP8 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP8 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP9 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP9 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP9 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP9 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP10 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP10 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP10 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP10 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP11 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP11 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP11 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP11 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP12 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP12 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP12 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP12 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP13 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP13 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP13 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP13 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP14 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP14 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP14 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP14 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	ADDRESS        ADDR_ENDP15 = 0x7F << 0  //+ Device address
	ENDPOINT       ADDR_ENDP15 = 0x0F << 16 //+ Endpoint number of the interrupt endpoint
	INTEP_DIR      ADDR_ENDP15 = 0x01 << 25 //+ Direction of the interrupt endpoint. In=0, Out=1
	INTEP_PREAMBLE ADDR_ENDP15 = 0x01 << 26 //+ Interrupt EP requires preamble (is a low speed device on a full speed hub)
)

const (
	ADDRESSn        = 0
	ENDPOINTn       = 16
	INTEP_DIRn      = 25
	INTEP_PREAMBLEn = 26
)

const (
	CONTROLLER_EN MAIN_CTRL = 0x01 << 0  //+ Enable controller
	HOST_NDEVICE  MAIN_CTRL = 0x01 << 1  //+ Device mode = 0, Host mode = 1
	PHY_ISO       MAIN_CTRL = 0x01 << 2  //+ Isolates USB phy after controller power-up Remove isolation once software has configured the controller Not isolated = 0, Isolated = 1
	SIM_TIMING    MAIN_CTRL = 0x01 << 31 //+ Reduced timings for simulation
)

const (
	CONTROLLER_ENn = 0
	HOST_NDEVICEn  = 1
	PHY_ISOn       = 2
	SIM_TIMINGn    = 31
)

const (
	START_TRANS              SIE_CTRL = 0x01 << 0  //+ Host: Start transaction
	SEND_SETUP               SIE_CTRL = 0x01 << 1  //+ Host: Send Setup packet
	SEND_DATA                SIE_CTRL = 0x01 << 2  //+ Host: Send transaction (OUT from host)
	RECEIVE_DATA             SIE_CTRL = 0x01 << 3  //+ Host: Receive transaction (IN to host)
	STOP_TRANS               SIE_CTRL = 0x01 << 4  //+ Host: Stop transaction
	PREAMBLE_EN              SIE_CTRL = 0x01 << 6  //+ Host: Preable enable for LS device on FS hub
	SOF_SYNC                 SIE_CTRL = 0x01 << 8  //+ Host: Delay packet(s) until after SOF
	SOF_EN                   SIE_CTRL = 0x01 << 9  //+ Host: Enable SOF generation (for full speed bus)
	KEEP_ALIVE_EN            SIE_CTRL = 0x01 << 10 //+ Host: Enable keep alive packet (for low speed bus)
	VBUS_EN                  SIE_CTRL = 0x01 << 11 //+ Host: Enable VBUS
	RESUME                   SIE_CTRL = 0x01 << 12 //+ Device: Remote wakeup. Device can initiate its own resume after suspend.
	RESET_BUS                SIE_CTRL = 0x01 << 13 //+ Host: Reset bus
	PULLDOWN_EN              SIE_CTRL = 0x01 << 15 //+ Host: Enable pull down resistors
	PULLUP_EN                SIE_CTRL = 0x01 << 16 //+ Device: Enable pull up resistor
	RPU_OPT                  SIE_CTRL = 0x01 << 17 //+ Device: Pull-up strength (0=1K2, 1=2k3)
	TRANSCEIVER_PD           SIE_CTRL = 0x01 << 18 //+ Power down bus transceiver
	EP0_STOP_ON_SHORT_PACKET SIE_CTRL = 0x01 << 19 //+ Device: Stop EP0 on a short packet.
	DIRECT_DM                SIE_CTRL = 0x01 << 24 //+ Direct control of DM
	DIRECT_DP                SIE_CTRL = 0x01 << 25 //+ Direct control of DP
	DIRECT_EN                SIE_CTRL = 0x01 << 26 //+ Direct bus drive enable
	EP0_INT_NAK              SIE_CTRL = 0x01 << 27 //+ Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
	EP0_INT_2BUF             SIE_CTRL = 0x01 << 28 //+ Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
	EP0_INT_1BUF             SIE_CTRL = 0x01 << 29 //+ Device: Set bit in BUFF_STATUS for every buffer completed on EP0
	EP0_DOUBLE_BUF           SIE_CTRL = 0x01 << 30 //+ Device: EP0 single buffered = 0, double buffered = 1
	EP0_INT_STALL            SIE_CTRL = 0x01 << 31 //+ Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
)

const (
	START_TRANSn              = 0
	SEND_SETUPn               = 1
	SEND_DATAn                = 2
	RECEIVE_DATAn             = 3
	STOP_TRANSn               = 4
	PREAMBLE_ENn              = 6
	SOF_SYNCn                 = 8
	SOF_ENn                   = 9
	KEEP_ALIVE_ENn            = 10
	VBUS_ENn                  = 11
	RESUMEn                   = 12
	RESET_BUSn                = 13
	PULLDOWN_ENn              = 15
	PULLUP_ENn                = 16
	RPU_OPTn                  = 17
	TRANSCEIVER_PDn           = 18
	EP0_STOP_ON_SHORT_PACKETn = 19
	DIRECT_DMn                = 24
	DIRECT_DPn                = 25
	DIRECT_ENn                = 26
	EP0_INT_NAKn              = 27
	EP0_INT_2BUFn             = 28
	EP0_INT_1BUFn             = 29
	EP0_DOUBLE_BUFn           = 30
	EP0_INT_STALLn            = 31
)

const (
	VBUS_DETECTED   SIE_STATUS = 0x01 << 0  //+ Device: VBUS Detected
	LINE_STATE      SIE_STATUS = 0x03 << 2  //+ USB bus line state
	SUSPENDED       SIE_STATUS = 0x01 << 4  //+ Bus in suspended state. Valid for device. Device will go into suspend if neither Keep Alive / SOF frames are enabled.
	SPEED           SIE_STATUS = 0x03 << 8  //+ Host: device speed. Disconnected = 00, LS = 01, FS = 10
	VBUS_OVER_CURR  SIE_STATUS = 0x01 << 10 //+ VBUS over current detected
	RESUME          SIE_STATUS = 0x01 << 11 //+ Host: Device has initiated a remote resume. Device: host has initiated a resume.
	RX_SHORT_PACKET SIE_STATUS = 0x01 << 12 //+ Device or Host has received a short packet. This is when the data received is less than configured in the buffer control register. Device: If using double buffered mode on device the buffer select will not be toggled after writing status back to the buffer control register. This is to prevent any further transactions on that endpoint until the user has reset the buffer control registers. Host: the current transfer will be stopped early.
	CONNECTED       SIE_STATUS = 0x01 << 16 //+ Device: connected
	SETUP_REC       SIE_STATUS = 0x01 << 17 //+ Device: Setup packet received
	TRANS_COMPLETE  SIE_STATUS = 0x01 << 18 //+ Transaction complete. Raised by device if: * An IN or OUT packet is sent with the `LAST_BUFF` bit set in the buffer control register Raised by host if: * A setup packet is sent when no data in or data out transaction follows * An IN packet is received and the `LAST_BUFF` bit is set in the buffer control register * An IN packet is received with zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
	BUS_RESET       SIE_STATUS = 0x01 << 19 //+ Device: bus reset received
	ENDPOINT_ERROR  SIE_STATUS = 0x01 << 23 //+ An endpoint has encountered an error. Read the ep_rx_error and ep_tx_error registers to find out which endpoint had an error.
	CRC_ERROR       SIE_STATUS = 0x01 << 24 //+ CRC Error. Raised by the Serial RX engine.
	BIT_STUFF_ERROR SIE_STATUS = 0x01 << 25 //+ Bit Stuff Error. Raised by the Serial RX engine.
	RX_OVERFLOW     SIE_STATUS = 0x01 << 26 //+ RX overflow is raised by the Serial RX engine if the incoming data is too fast.
	RX_TIMEOUT      SIE_STATUS = 0x01 << 27 //+ RX timeout is raised by both the host and device if an ACK is not received in the maximum time specified by the USB spec.
	NAK_REC         SIE_STATUS = 0x01 << 28 //+ Host: NAK received
	STALL_REC       SIE_STATUS = 0x01 << 29 //+ Host: STALL received
	ACK_REC         SIE_STATUS = 0x01 << 30 //+ ACK received. Raised by both host and device.
	DATA_SEQ_ERROR  SIE_STATUS = 0x01 << 31 //+ Data Sequence Error. The device can raise a sequence error in the following conditions: * A SETUP packet is received followed by a DATA1 packet (data phase should always be DATA0) * An OUT packet is received from the host but doesn't match the data pid in the buffer control register read from DPSRAM The host can raise a data sequence error in the following conditions: * An IN packet from the device has the wrong data PID
)

const (
	VBUS_DETECTEDn   = 0
	LINE_STATEn      = 2
	SUSPENDEDn       = 4
	SPEEDn           = 8
	VBUS_OVER_CURRn  = 10
	RESUMEn          = 11
	RX_SHORT_PACKETn = 12
	CONNECTEDn       = 16
	SETUP_RECn       = 17
	TRANS_COMPLETEn  = 18
	BUS_RESETn       = 19
	ENDPOINT_ERRORn  = 23
	CRC_ERRORn       = 24
	BIT_STUFF_ERRORn = 25
	RX_OVERFLOWn     = 26
	RX_TIMEOUTn      = 27
	NAK_RECn         = 28
	STALL_RECn       = 29
	ACK_RECn         = 30
	DATA_SEQ_ERRORn  = 31
)

const (
	INT_EP_ACTIVE INT_EP_CTRL = 0x7FFF << 1 //+ Host: Enable interrupt endpoint 1 -> 15
)

const (
	INT_EP_ACTIVEn = 1
)

const (
	EP0_IN   BUFF_STATUS = 0x01 << 0  //+
	EP0_OUT  BUFF_STATUS = 0x01 << 1  //+
	EP1_IN   BUFF_STATUS = 0x01 << 2  //+
	EP1_OUT  BUFF_STATUS = 0x01 << 3  //+
	EP2_IN   BUFF_STATUS = 0x01 << 4  //+
	EP2_OUT  BUFF_STATUS = 0x01 << 5  //+
	EP3_IN   BUFF_STATUS = 0x01 << 6  //+
	EP3_OUT  BUFF_STATUS = 0x01 << 7  //+
	EP4_IN   BUFF_STATUS = 0x01 << 8  //+
	EP4_OUT  BUFF_STATUS = 0x01 << 9  //+
	EP5_IN   BUFF_STATUS = 0x01 << 10 //+
	EP5_OUT  BUFF_STATUS = 0x01 << 11 //+
	EP6_IN   BUFF_STATUS = 0x01 << 12 //+
	EP6_OUT  BUFF_STATUS = 0x01 << 13 //+
	EP7_IN   BUFF_STATUS = 0x01 << 14 //+
	EP7_OUT  BUFF_STATUS = 0x01 << 15 //+
	EP8_IN   BUFF_STATUS = 0x01 << 16 //+
	EP8_OUT  BUFF_STATUS = 0x01 << 17 //+
	EP9_IN   BUFF_STATUS = 0x01 << 18 //+
	EP9_OUT  BUFF_STATUS = 0x01 << 19 //+
	EP10_IN  BUFF_STATUS = 0x01 << 20 //+
	EP10_OUT BUFF_STATUS = 0x01 << 21 //+
	EP11_IN  BUFF_STATUS = 0x01 << 22 //+
	EP11_OUT BUFF_STATUS = 0x01 << 23 //+
	EP12_IN  BUFF_STATUS = 0x01 << 24 //+
	EP12_OUT BUFF_STATUS = 0x01 << 25 //+
	EP13_IN  BUFF_STATUS = 0x01 << 26 //+
	EP13_OUT BUFF_STATUS = 0x01 << 27 //+
	EP14_IN  BUFF_STATUS = 0x01 << 28 //+
	EP14_OUT BUFF_STATUS = 0x01 << 29 //+
	EP15_IN  BUFF_STATUS = 0x01 << 30 //+
	EP15_OUT BUFF_STATUS = 0x01 << 31 //+
)

const (
	EP0_INn   = 0
	EP0_OUTn  = 1
	EP1_INn   = 2
	EP1_OUTn  = 3
	EP2_INn   = 4
	EP2_OUTn  = 5
	EP3_INn   = 6
	EP3_OUTn  = 7
	EP4_INn   = 8
	EP4_OUTn  = 9
	EP5_INn   = 10
	EP5_OUTn  = 11
	EP6_INn   = 12
	EP6_OUTn  = 13
	EP7_INn   = 14
	EP7_OUTn  = 15
	EP8_INn   = 16
	EP8_OUTn  = 17
	EP9_INn   = 18
	EP9_OUTn  = 19
	EP10_INn  = 20
	EP10_OUTn = 21
	EP11_INn  = 22
	EP11_OUTn = 23
	EP12_INn  = 24
	EP12_OUTn = 25
	EP13_INn  = 26
	EP13_OUTn = 27
	EP14_INn  = 28
	EP14_OUTn = 29
	EP15_INn  = 30
	EP15_OUTn = 31
)

const (
	EP0_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 0  //+
	EP0_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 1  //+
	EP1_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 2  //+
	EP1_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 3  //+
	EP2_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 4  //+
	EP2_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 5  //+
	EP3_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 6  //+
	EP3_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 7  //+
	EP4_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 8  //+
	EP4_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 9  //+
	EP5_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 10 //+
	EP5_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 11 //+
	EP6_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 12 //+
	EP6_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 13 //+
	EP7_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 14 //+
	EP7_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 15 //+
	EP8_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 16 //+
	EP8_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 17 //+
	EP9_IN   BUFF_CPU_SHOULD_HANDLE = 0x01 << 18 //+
	EP9_OUT  BUFF_CPU_SHOULD_HANDLE = 0x01 << 19 //+
	EP10_IN  BUFF_CPU_SHOULD_HANDLE = 0x01 << 20 //+
	EP10_OUT BUFF_CPU_SHOULD_HANDLE = 0x01 << 21 //+
	EP11_IN  BUFF_CPU_SHOULD_HANDLE = 0x01 << 22 //+
	EP11_OUT BUFF_CPU_SHOULD_HANDLE = 0x01 << 23 //+
	EP12_IN  BUFF_CPU_SHOULD_HANDLE = 0x01 << 24 //+
	EP12_OUT BUFF_CPU_SHOULD_HANDLE = 0x01 << 25 //+
	EP13_IN  BUFF_CPU_SHOULD_HANDLE = 0x01 << 26 //+
	EP13_OUT BUFF_CPU_SHOULD_HANDLE = 0x01 << 27 //+
	EP14_IN  BUFF_CPU_SHOULD_HANDLE = 0x01 << 28 //+
	EP14_OUT BUFF_CPU_SHOULD_HANDLE = 0x01 << 29 //+
	EP15_IN  BUFF_CPU_SHOULD_HANDLE = 0x01 << 30 //+
	EP15_OUT BUFF_CPU_SHOULD_HANDLE = 0x01 << 31 //+
)

const (
	EP0_INn   = 0
	EP0_OUTn  = 1
	EP1_INn   = 2
	EP1_OUTn  = 3
	EP2_INn   = 4
	EP2_OUTn  = 5
	EP3_INn   = 6
	EP3_OUTn  = 7
	EP4_INn   = 8
	EP4_OUTn  = 9
	EP5_INn   = 10
	EP5_OUTn  = 11
	EP6_INn   = 12
	EP6_OUTn  = 13
	EP7_INn   = 14
	EP7_OUTn  = 15
	EP8_INn   = 16
	EP8_OUTn  = 17
	EP9_INn   = 18
	EP9_OUTn  = 19
	EP10_INn  = 20
	EP10_OUTn = 21
	EP11_INn  = 22
	EP11_OUTn = 23
	EP12_INn  = 24
	EP12_OUTn = 25
	EP13_INn  = 26
	EP13_OUTn = 27
	EP14_INn  = 28
	EP14_OUTn = 29
	EP15_INn  = 30
	EP15_OUTn = 31
)

const (
	EP0_IN   EP_ABORT = 0x01 << 0  //+
	EP0_OUT  EP_ABORT = 0x01 << 1  //+
	EP1_IN   EP_ABORT = 0x01 << 2  //+
	EP1_OUT  EP_ABORT = 0x01 << 3  //+
	EP2_IN   EP_ABORT = 0x01 << 4  //+
	EP2_OUT  EP_ABORT = 0x01 << 5  //+
	EP3_IN   EP_ABORT = 0x01 << 6  //+
	EP3_OUT  EP_ABORT = 0x01 << 7  //+
	EP4_IN   EP_ABORT = 0x01 << 8  //+
	EP4_OUT  EP_ABORT = 0x01 << 9  //+
	EP5_IN   EP_ABORT = 0x01 << 10 //+
	EP5_OUT  EP_ABORT = 0x01 << 11 //+
	EP6_IN   EP_ABORT = 0x01 << 12 //+
	EP6_OUT  EP_ABORT = 0x01 << 13 //+
	EP7_IN   EP_ABORT = 0x01 << 14 //+
	EP7_OUT  EP_ABORT = 0x01 << 15 //+
	EP8_IN   EP_ABORT = 0x01 << 16 //+
	EP8_OUT  EP_ABORT = 0x01 << 17 //+
	EP9_IN   EP_ABORT = 0x01 << 18 //+
	EP9_OUT  EP_ABORT = 0x01 << 19 //+
	EP10_IN  EP_ABORT = 0x01 << 20 //+
	EP10_OUT EP_ABORT = 0x01 << 21 //+
	EP11_IN  EP_ABORT = 0x01 << 22 //+
	EP11_OUT EP_ABORT = 0x01 << 23 //+
	EP12_IN  EP_ABORT = 0x01 << 24 //+
	EP12_OUT EP_ABORT = 0x01 << 25 //+
	EP13_IN  EP_ABORT = 0x01 << 26 //+
	EP13_OUT EP_ABORT = 0x01 << 27 //+
	EP14_IN  EP_ABORT = 0x01 << 28 //+
	EP14_OUT EP_ABORT = 0x01 << 29 //+
	EP15_IN  EP_ABORT = 0x01 << 30 //+
	EP15_OUT EP_ABORT = 0x01 << 31 //+
)

const (
	EP0_INn   = 0
	EP0_OUTn  = 1
	EP1_INn   = 2
	EP1_OUTn  = 3
	EP2_INn   = 4
	EP2_OUTn  = 5
	EP3_INn   = 6
	EP3_OUTn  = 7
	EP4_INn   = 8
	EP4_OUTn  = 9
	EP5_INn   = 10
	EP5_OUTn  = 11
	EP6_INn   = 12
	EP6_OUTn  = 13
	EP7_INn   = 14
	EP7_OUTn  = 15
	EP8_INn   = 16
	EP8_OUTn  = 17
	EP9_INn   = 18
	EP9_OUTn  = 19
	EP10_INn  = 20
	EP10_OUTn = 21
	EP11_INn  = 22
	EP11_OUTn = 23
	EP12_INn  = 24
	EP12_OUTn = 25
	EP13_INn  = 26
	EP13_OUTn = 27
	EP14_INn  = 28
	EP14_OUTn = 29
	EP15_INn  = 30
	EP15_OUTn = 31
)

const (
	EP0_IN   EP_ABORT_DONE = 0x01 << 0  //+
	EP0_OUT  EP_ABORT_DONE = 0x01 << 1  //+
	EP1_IN   EP_ABORT_DONE = 0x01 << 2  //+
	EP1_OUT  EP_ABORT_DONE = 0x01 << 3  //+
	EP2_IN   EP_ABORT_DONE = 0x01 << 4  //+
	EP2_OUT  EP_ABORT_DONE = 0x01 << 5  //+
	EP3_IN   EP_ABORT_DONE = 0x01 << 6  //+
	EP3_OUT  EP_ABORT_DONE = 0x01 << 7  //+
	EP4_IN   EP_ABORT_DONE = 0x01 << 8  //+
	EP4_OUT  EP_ABORT_DONE = 0x01 << 9  //+
	EP5_IN   EP_ABORT_DONE = 0x01 << 10 //+
	EP5_OUT  EP_ABORT_DONE = 0x01 << 11 //+
	EP6_IN   EP_ABORT_DONE = 0x01 << 12 //+
	EP6_OUT  EP_ABORT_DONE = 0x01 << 13 //+
	EP7_IN   EP_ABORT_DONE = 0x01 << 14 //+
	EP7_OUT  EP_ABORT_DONE = 0x01 << 15 //+
	EP8_IN   EP_ABORT_DONE = 0x01 << 16 //+
	EP8_OUT  EP_ABORT_DONE = 0x01 << 17 //+
	EP9_IN   EP_ABORT_DONE = 0x01 << 18 //+
	EP9_OUT  EP_ABORT_DONE = 0x01 << 19 //+
	EP10_IN  EP_ABORT_DONE = 0x01 << 20 //+
	EP10_OUT EP_ABORT_DONE = 0x01 << 21 //+
	EP11_IN  EP_ABORT_DONE = 0x01 << 22 //+
	EP11_OUT EP_ABORT_DONE = 0x01 << 23 //+
	EP12_IN  EP_ABORT_DONE = 0x01 << 24 //+
	EP12_OUT EP_ABORT_DONE = 0x01 << 25 //+
	EP13_IN  EP_ABORT_DONE = 0x01 << 26 //+
	EP13_OUT EP_ABORT_DONE = 0x01 << 27 //+
	EP14_IN  EP_ABORT_DONE = 0x01 << 28 //+
	EP14_OUT EP_ABORT_DONE = 0x01 << 29 //+
	EP15_IN  EP_ABORT_DONE = 0x01 << 30 //+
	EP15_OUT EP_ABORT_DONE = 0x01 << 31 //+
)

const (
	EP0_INn   = 0
	EP0_OUTn  = 1
	EP1_INn   = 2
	EP1_OUTn  = 3
	EP2_INn   = 4
	EP2_OUTn  = 5
	EP3_INn   = 6
	EP3_OUTn  = 7
	EP4_INn   = 8
	EP4_OUTn  = 9
	EP5_INn   = 10
	EP5_OUTn  = 11
	EP6_INn   = 12
	EP6_OUTn  = 13
	EP7_INn   = 14
	EP7_OUTn  = 15
	EP8_INn   = 16
	EP8_OUTn  = 17
	EP9_INn   = 18
	EP9_OUTn  = 19
	EP10_INn  = 20
	EP10_OUTn = 21
	EP11_INn  = 22
	EP11_OUTn = 23
	EP12_INn  = 24
	EP12_OUTn = 25
	EP13_INn  = 26
	EP13_OUTn = 27
	EP14_INn  = 28
	EP14_OUTn = 29
	EP15_INn  = 30
	EP15_OUTn = 31
)

const (
	EP0_IN  EP_STALL_ARM = 0x01 << 0 //+
	EP0_OUT EP_STALL_ARM = 0x01 << 1 //+
)

const (
	EP0_INn  = 0
	EP0_OUTn = 1
)

const (
	DELAY_LS           NAK_POLL = 0x3FF << 0  //+ NAK polling interval for a low speed device
	RETRY_COUNT_LO     NAK_POLL = 0x3F << 10  //+ Bits 5:0 of nak_retry_count
	DELAY_FS           NAK_POLL = 0x3FF << 16 //+ NAK polling interval for a full speed device
	STOP_EPX_ON_NAK    NAK_POLL = 0x01 << 26  //+ Stop polling epx when a nak is received
	EPX_STOPPED_ON_NAK NAK_POLL = 0x01 << 27  //+ EPX polling has stopped because a nak was received
	RETRY_COUNT_HI     NAK_POLL = 0x0F << 28  //+ Bits 9:6 of nak_retry count
)

const (
	DELAY_LSn           = 0
	RETRY_COUNT_LOn     = 10
	DELAY_FSn           = 16
	STOP_EPX_ON_NAKn    = 26
	EPX_STOPPED_ON_NAKn = 27
	RETRY_COUNT_HIn     = 28
)

const (
	EP0_IN   EP_STATUS_STALL_NAK = 0x01 << 0  //+
	EP0_OUT  EP_STATUS_STALL_NAK = 0x01 << 1  //+
	EP1_IN   EP_STATUS_STALL_NAK = 0x01 << 2  //+
	EP1_OUT  EP_STATUS_STALL_NAK = 0x01 << 3  //+
	EP2_IN   EP_STATUS_STALL_NAK = 0x01 << 4  //+
	EP2_OUT  EP_STATUS_STALL_NAK = 0x01 << 5  //+
	EP3_IN   EP_STATUS_STALL_NAK = 0x01 << 6  //+
	EP3_OUT  EP_STATUS_STALL_NAK = 0x01 << 7  //+
	EP4_IN   EP_STATUS_STALL_NAK = 0x01 << 8  //+
	EP4_OUT  EP_STATUS_STALL_NAK = 0x01 << 9  //+
	EP5_IN   EP_STATUS_STALL_NAK = 0x01 << 10 //+
	EP5_OUT  EP_STATUS_STALL_NAK = 0x01 << 11 //+
	EP6_IN   EP_STATUS_STALL_NAK = 0x01 << 12 //+
	EP6_OUT  EP_STATUS_STALL_NAK = 0x01 << 13 //+
	EP7_IN   EP_STATUS_STALL_NAK = 0x01 << 14 //+
	EP7_OUT  EP_STATUS_STALL_NAK = 0x01 << 15 //+
	EP8_IN   EP_STATUS_STALL_NAK = 0x01 << 16 //+
	EP8_OUT  EP_STATUS_STALL_NAK = 0x01 << 17 //+
	EP9_IN   EP_STATUS_STALL_NAK = 0x01 << 18 //+
	EP9_OUT  EP_STATUS_STALL_NAK = 0x01 << 19 //+
	EP10_IN  EP_STATUS_STALL_NAK = 0x01 << 20 //+
	EP10_OUT EP_STATUS_STALL_NAK = 0x01 << 21 //+
	EP11_IN  EP_STATUS_STALL_NAK = 0x01 << 22 //+
	EP11_OUT EP_STATUS_STALL_NAK = 0x01 << 23 //+
	EP12_IN  EP_STATUS_STALL_NAK = 0x01 << 24 //+
	EP12_OUT EP_STATUS_STALL_NAK = 0x01 << 25 //+
	EP13_IN  EP_STATUS_STALL_NAK = 0x01 << 26 //+
	EP13_OUT EP_STATUS_STALL_NAK = 0x01 << 27 //+
	EP14_IN  EP_STATUS_STALL_NAK = 0x01 << 28 //+
	EP14_OUT EP_STATUS_STALL_NAK = 0x01 << 29 //+
	EP15_IN  EP_STATUS_STALL_NAK = 0x01 << 30 //+
	EP15_OUT EP_STATUS_STALL_NAK = 0x01 << 31 //+
)

const (
	EP0_INn   = 0
	EP0_OUTn  = 1
	EP1_INn   = 2
	EP1_OUTn  = 3
	EP2_INn   = 4
	EP2_OUTn  = 5
	EP3_INn   = 6
	EP3_OUTn  = 7
	EP4_INn   = 8
	EP4_OUTn  = 9
	EP5_INn   = 10
	EP5_OUTn  = 11
	EP6_INn   = 12
	EP6_OUTn  = 13
	EP7_INn   = 14
	EP7_OUTn  = 15
	EP8_INn   = 16
	EP8_OUTn  = 17
	EP9_INn   = 18
	EP9_OUTn  = 19
	EP10_INn  = 20
	EP10_OUTn = 21
	EP11_INn  = 22
	EP11_OUTn = 23
	EP12_INn  = 24
	EP12_OUTn = 25
	EP13_INn  = 26
	EP13_OUTn = 27
	EP14_INn  = 28
	EP14_OUTn = 29
	EP15_INn  = 30
	EP15_OUTn = 31
)

const (
	TO_PHY         USB_MUXING = 0x01 << 0  //+
	TO_EXTPHY      USB_MUXING = 0x01 << 1  //+
	TO_DIGITAL_PAD USB_MUXING = 0x01 << 2  //+
	SOFTCON        USB_MUXING = 0x01 << 3  //+
	USBPHY_AS_GPIO USB_MUXING = 0x01 << 4  //+ Use the usb DP and DM pins as GPIO pins instead of connecting them to the USB controller.
	SWAP_DPDM      USB_MUXING = 0x01 << 31 //+ Swap the USB PHY DP and DM pins and all related controls and flip receive differential data. Can be used to switch USB DP/DP on the PCB. This is done at a low level so overrides all other controls.
)

const (
	TO_PHYn         = 0
	TO_EXTPHYn      = 1
	TO_DIGITAL_PADn = 2
	SOFTCONn        = 3
	USBPHY_AS_GPIOn = 4
	SWAP_DPDMn      = 31
)

const (
	VBUS_EN                 USB_PWR = 0x01 << 0 //+
	VBUS_EN_OVERRIDE_EN     USB_PWR = 0x01 << 1 //+
	VBUS_DETECT             USB_PWR = 0x01 << 2 //+
	VBUS_DETECT_OVERRIDE_EN USB_PWR = 0x01 << 3 //+
	OVERCURR_DETECT         USB_PWR = 0x01 << 4 //+
	OVERCURR_DETECT_EN      USB_PWR = 0x01 << 5 //+
)

const (
	VBUS_ENn                 = 0
	VBUS_EN_OVERRIDE_ENn     = 1
	VBUS_DETECTn             = 2
	VBUS_DETECT_OVERRIDE_ENn = 3
	OVERCURR_DETECTn         = 4
	OVERCURR_DETECT_ENn      = 5
)

const (
	DP_PULLUP_HISEL USBPHY_DIRECT = 0x01 << 0  //+ Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
	DP_PULLUP_EN    USBPHY_DIRECT = 0x01 << 1  //+ DP pull up enable
	DP_PULLDN_EN    USBPHY_DIRECT = 0x01 << 2  //+ DP pull down enable
	DM_PULLUP_HISEL USBPHY_DIRECT = 0x01 << 4  //+ Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1 + Rpu2
	DM_PULLUP_EN    USBPHY_DIRECT = 0x01 << 5  //+ DM pull up enable
	DM_PULLDN_EN    USBPHY_DIRECT = 0x01 << 6  //+ DM pull down enable
	TX_DP_OE        USBPHY_DIRECT = 0x01 << 8  //+ Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state; 1 - DPP driving
	TX_DM_OE        USBPHY_DIRECT = 0x01 << 9  //+ Output enable. If TX_DIFFMODE=1, Ignored. If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state; 1 - DPM driving
	TX_DP           USBPHY_DIRECT = 0x01 << 10 //+ Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable drive. DPP=TX_DP
	TX_DM           USBPHY_DIRECT = 0x01 << 11 //+ Output data. TX_DIFFMODE=1, Ignored TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive. DPM=TX_DM
	RX_PD           USBPHY_DIRECT = 0x01 << 12 //+ RX power down override (if override enable is set). 1 = powered down.
	TX_PD           USBPHY_DIRECT = 0x01 << 13 //+ TX power down override (if override enable is set). 1 = powered down.
	TX_FSSLEW       USBPHY_DIRECT = 0x01 << 14 //+ TX_FSSLEW=0: Low speed slew rate TX_FSSLEW=1: Full speed slew rate
	TX_DIFFMODE     USBPHY_DIRECT = 0x01 << 15 //+ TX_DIFFMODE=0: Single ended mode TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE ignored)
	RX_DD           USBPHY_DIRECT = 0x01 << 16 //+ Differential RX
	RX_DP           USBPHY_DIRECT = 0x01 << 17 //+ DPP pin state
	RX_DM           USBPHY_DIRECT = 0x01 << 18 //+ DPM pin state
	DP_OVCN         USBPHY_DIRECT = 0x01 << 19 //+ DP overcurrent
	DM_OVCN         USBPHY_DIRECT = 0x01 << 20 //+ DM overcurrent
	DP_OVV          USBPHY_DIRECT = 0x01 << 21 //+ DP over voltage
	DM_OVV          USBPHY_DIRECT = 0x01 << 22 //+ DM over voltage
	RX_DD_OVERRIDE  USBPHY_DIRECT = 0x01 << 23 //+ Override rx_dd value into controller
	RX_DP_OVERRIDE  USBPHY_DIRECT = 0x01 << 24 //+ Override rx_dp value into controller
	RX_DM_OVERRIDE  USBPHY_DIRECT = 0x01 << 25 //+ Override rx_dm value into controller
)

const (
	DP_PULLUP_HISELn = 0
	DP_PULLUP_ENn    = 1
	DP_PULLDN_ENn    = 2
	DM_PULLUP_HISELn = 4
	DM_PULLUP_ENn    = 5
	DM_PULLDN_ENn    = 6
	TX_DP_OEn        = 8
	TX_DM_OEn        = 9
	TX_DPn           = 10
	TX_DMn           = 11
	RX_PDn           = 12
	TX_PDn           = 13
	TX_FSSLEWn       = 14
	TX_DIFFMODEn     = 15
	RX_DDn           = 16
	RX_DPn           = 17
	RX_DMn           = 18
	DP_OVCNn         = 19
	DM_OVCNn         = 20
	DP_OVVn          = 21
	DM_OVVn          = 22
	RX_DD_OVERRIDEn  = 23
	RX_DP_OVERRIDEn  = 24
	RX_DM_OVERRIDEn  = 25
)

const (
	DP_PULLUP_HISEL_OVERRIDE_EN USBPHY_DIRECT_OVERRIDE = 0x01 << 0  //+
	DM_PULLUP_HISEL_OVERRIDE_EN USBPHY_DIRECT_OVERRIDE = 0x01 << 1  //+
	DP_PULLUP_EN_OVERRIDE_EN    USBPHY_DIRECT_OVERRIDE = 0x01 << 2  //+
	DP_PULLDN_EN_OVERRIDE_EN    USBPHY_DIRECT_OVERRIDE = 0x01 << 3  //+
	DM_PULLDN_EN_OVERRIDE_EN    USBPHY_DIRECT_OVERRIDE = 0x01 << 4  //+
	TX_DP_OE_OVERRIDE_EN        USBPHY_DIRECT_OVERRIDE = 0x01 << 5  //+
	TX_DM_OE_OVERRIDE_EN        USBPHY_DIRECT_OVERRIDE = 0x01 << 6  //+
	TX_DP_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 7  //+
	TX_DM_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 8  //+
	RX_PD_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 9  //+
	TX_PD_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 10 //+
	TX_FSSLEW_OVERRIDE_EN       USBPHY_DIRECT_OVERRIDE = 0x01 << 11 //+
	DM_PULLUP_OVERRIDE_EN       USBPHY_DIRECT_OVERRIDE = 0x01 << 12 //+
	TX_DIFFMODE_OVERRIDE_EN     USBPHY_DIRECT_OVERRIDE = 0x01 << 15 //+
	RX_DD_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 16 //+
	RX_DP_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 17 //+
	RX_DM_OVERRIDE_EN           USBPHY_DIRECT_OVERRIDE = 0x01 << 18 //+
)

const (
	DP_PULLUP_HISEL_OVERRIDE_ENn = 0
	DM_PULLUP_HISEL_OVERRIDE_ENn = 1
	DP_PULLUP_EN_OVERRIDE_ENn    = 2
	DP_PULLDN_EN_OVERRIDE_ENn    = 3
	DM_PULLDN_EN_OVERRIDE_ENn    = 4
	TX_DP_OE_OVERRIDE_ENn        = 5
	TX_DM_OE_OVERRIDE_ENn        = 6
	TX_DP_OVERRIDE_ENn           = 7
	TX_DM_OVERRIDE_ENn           = 8
	RX_PD_OVERRIDE_ENn           = 9
	TX_PD_OVERRIDE_ENn           = 10
	TX_FSSLEW_OVERRIDE_ENn       = 11
	DM_PULLUP_OVERRIDE_ENn       = 12
	TX_DIFFMODE_OVERRIDE_ENn     = 15
	RX_DD_OVERRIDE_ENn           = 16
	RX_DP_OVERRIDE_ENn           = 17
	RX_DM_OVERRIDE_ENn           = 18
)

const (
	DP_PULLDN_TRIM USBPHY_TRIM = 0x1F << 0 //+ Value to drive to USB PHY DP pulldown resistor trim control Experimental data suggests that the reset value will work, but this register allows adjustment if required
	DM_PULLDN_TRIM USBPHY_TRIM = 0x1F << 8 //+ Value to drive to USB PHY DM pulldown resistor trim control Experimental data suggests that the reset value will work, but this register allows adjustment if required
)

const (
	DP_PULLDN_TRIMn = 0
	DM_PULLDN_TRIMn = 8
)

const (
	RCV_DELAY                        LINESTATE_TUNING = 0x01 << 0 //+ Device - register the received data to account for hub bit dribble before EOP. Only affects certain hubs.
	LINESTATE_DELAY                  LINESTATE_TUNING = 0x01 << 1 //+ Device/Host - add an extra 1-bit debounce of linestate sampling.
	MULTI_HUB_FIX                    LINESTATE_TUNING = 0x01 << 2 //+ Host - increase inter-packet and turnaround timeouts to accommodate worst-case hub delays.
	DEV_BUFF_CONTROL_DOUBLE_READ_FIX LINESTATE_TUNING = 0x01 << 3 //+ Device - the controller FSM performs two reads of the buffer status memory address to avoid sampling metastable data. An enabled buffer is only used if both reads match.
	SIE_RX_BITSTUFF_FIX              LINESTATE_TUNING = 0x01 << 4 //+ RX - when a bitstuff error is signalled by rx_dasm, unconditionally terminate RX decode to avoid a hang during certain packet phases.
	SIE_RX_CHATTER_SE0_FIX           LINESTATE_TUNING = 0x01 << 5 //+ RX - when recovering from line chatter or bitstuff errors, treat SE0 as the end of chatter as well as 8 consecutive idle bits.
	DEV_RX_ERR_QUIESCE               LINESTATE_TUNING = 0x01 << 6 //+ Device - suppress repeated errors until the device FSM is next in the process of decoding an inbound packet.
	DEV_LS_WAKE_FIX                  LINESTATE_TUNING = 0x01 << 7 //+ Device - exit suspend on any non-idle signalling, not qualified with a 1ms timer
	SPARE_FIX                        LINESTATE_TUNING = 0x0F << 8 //+
)

const (
	RCV_DELAYn                        = 0
	LINESTATE_DELAYn                  = 1
	MULTI_HUB_FIXn                    = 2
	DEV_BUFF_CONTROL_DOUBLE_READ_FIXn = 3
	SIE_RX_BITSTUFF_FIXn              = 4
	SIE_RX_CHATTER_SE0_FIXn           = 5
	DEV_RX_ERR_QUIESCEn               = 6
	DEV_LS_WAKE_FIXn                  = 7
	SPARE_FIXn                        = 8
)

const (
	HOST_CONN_DIS         INTR = 0x01 << 0  //+ Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME           INTR = 0x01 << 1  //+ Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
	HOST_SOF              INTR = 0x01 << 2  //+ Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE        INTR = 0x01 << 3  //+ Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS           INTR = 0x01 << 4  //+ Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ        INTR = 0x01 << 5  //+ Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT      INTR = 0x01 << 6  //+ Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW     INTR = 0x01 << 7  //+ Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF       INTR = 0x01 << 8  //+ Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC             INTR = 0x01 << 9  //+ Source: SIE_STATUS.CRC_ERROR
	STALL                 INTR = 0x01 << 10 //+ Source: SIE_STATUS.STALL_REC
	VBUS_DETECT           INTR = 0x01 << 11 //+ Source: SIE_STATUS.VBUS_DETECTED
	BUS_RESET             INTR = 0x01 << 12 //+ Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS          INTR = 0x01 << 13 //+ Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND           INTR = 0x01 << 14 //+ Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST  INTR = 0x01 << 15 //+ Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
	SETUP_REQ             INTR = 0x01 << 16 //+ Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF               INTR = 0x01 << 17 //+ Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE            INTR = 0x01 << 18 //+ Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK          INTR = 0x01 << 19 //+ Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
	RX_SHORT_PACKET       INTR = 0x01 << 20 //+ Source: SIE_STATUS.RX_SHORT_PACKET
	ENDPOINT_ERROR        INTR = 0x01 << 21 //+ Source: SIE_STATUS.ENDPOINT_ERROR
	DEV_SM_WATCHDOG_FIRED INTR = 0x01 << 22 //+ Source: DEV_SM_WATCHDOG.FIRED
	EPX_STOPPED_ON_NAK    INTR = 0x01 << 23 //+ Source: NAK_POLL.EPX_STOPPED_ON_NAK
)

const (
	HOST_CONN_DISn         = 0
	HOST_RESUMEn           = 1
	HOST_SOFn              = 2
	TRANS_COMPLETEn        = 3
	BUFF_STATUSn           = 4
	ERROR_DATA_SEQn        = 5
	ERROR_RX_TIMEOUTn      = 6
	ERROR_RX_OVERFLOWn     = 7
	ERROR_BIT_STUFFn       = 8
	ERROR_CRCn             = 9
	STALLn                 = 10
	VBUS_DETECTn           = 11
	BUS_RESETn             = 12
	DEV_CONN_DISn          = 13
	DEV_SUSPENDn           = 14
	DEV_RESUME_FROM_HOSTn  = 15
	SETUP_REQn             = 16
	DEV_SOFn               = 17
	ABORT_DONEn            = 18
	EP_STALL_NAKn          = 19
	RX_SHORT_PACKETn       = 20
	ENDPOINT_ERRORn        = 21
	DEV_SM_WATCHDOG_FIREDn = 22
	EPX_STOPPED_ON_NAKn    = 23
)

const (
	HOST_CONN_DIS         INTE = 0x01 << 0  //+ Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME           INTE = 0x01 << 1  //+ Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
	HOST_SOF              INTE = 0x01 << 2  //+ Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE        INTE = 0x01 << 3  //+ Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS           INTE = 0x01 << 4  //+ Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ        INTE = 0x01 << 5  //+ Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT      INTE = 0x01 << 6  //+ Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW     INTE = 0x01 << 7  //+ Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF       INTE = 0x01 << 8  //+ Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC             INTE = 0x01 << 9  //+ Source: SIE_STATUS.CRC_ERROR
	STALL                 INTE = 0x01 << 10 //+ Source: SIE_STATUS.STALL_REC
	VBUS_DETECT           INTE = 0x01 << 11 //+ Source: SIE_STATUS.VBUS_DETECTED
	BUS_RESET             INTE = 0x01 << 12 //+ Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS          INTE = 0x01 << 13 //+ Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND           INTE = 0x01 << 14 //+ Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST  INTE = 0x01 << 15 //+ Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
	SETUP_REQ             INTE = 0x01 << 16 //+ Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF               INTE = 0x01 << 17 //+ Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE            INTE = 0x01 << 18 //+ Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK          INTE = 0x01 << 19 //+ Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
	RX_SHORT_PACKET       INTE = 0x01 << 20 //+ Source: SIE_STATUS.RX_SHORT_PACKET
	ENDPOINT_ERROR        INTE = 0x01 << 21 //+ Source: SIE_STATUS.ENDPOINT_ERROR
	DEV_SM_WATCHDOG_FIRED INTE = 0x01 << 22 //+ Source: DEV_SM_WATCHDOG.FIRED
	EPX_STOPPED_ON_NAK    INTE = 0x01 << 23 //+ Source: NAK_POLL.EPX_STOPPED_ON_NAK
)

const (
	HOST_CONN_DISn         = 0
	HOST_RESUMEn           = 1
	HOST_SOFn              = 2
	TRANS_COMPLETEn        = 3
	BUFF_STATUSn           = 4
	ERROR_DATA_SEQn        = 5
	ERROR_RX_TIMEOUTn      = 6
	ERROR_RX_OVERFLOWn     = 7
	ERROR_BIT_STUFFn       = 8
	ERROR_CRCn             = 9
	STALLn                 = 10
	VBUS_DETECTn           = 11
	BUS_RESETn             = 12
	DEV_CONN_DISn          = 13
	DEV_SUSPENDn           = 14
	DEV_RESUME_FROM_HOSTn  = 15
	SETUP_REQn             = 16
	DEV_SOFn               = 17
	ABORT_DONEn            = 18
	EP_STALL_NAKn          = 19
	RX_SHORT_PACKETn       = 20
	ENDPOINT_ERRORn        = 21
	DEV_SM_WATCHDOG_FIREDn = 22
	EPX_STOPPED_ON_NAKn    = 23
)

const (
	HOST_CONN_DIS         INTF = 0x01 << 0  //+ Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME           INTF = 0x01 << 1  //+ Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
	HOST_SOF              INTF = 0x01 << 2  //+ Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE        INTF = 0x01 << 3  //+ Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS           INTF = 0x01 << 4  //+ Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ        INTF = 0x01 << 5  //+ Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT      INTF = 0x01 << 6  //+ Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW     INTF = 0x01 << 7  //+ Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF       INTF = 0x01 << 8  //+ Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC             INTF = 0x01 << 9  //+ Source: SIE_STATUS.CRC_ERROR
	STALL                 INTF = 0x01 << 10 //+ Source: SIE_STATUS.STALL_REC
	VBUS_DETECT           INTF = 0x01 << 11 //+ Source: SIE_STATUS.VBUS_DETECTED
	BUS_RESET             INTF = 0x01 << 12 //+ Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS          INTF = 0x01 << 13 //+ Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND           INTF = 0x01 << 14 //+ Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST  INTF = 0x01 << 15 //+ Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
	SETUP_REQ             INTF = 0x01 << 16 //+ Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF               INTF = 0x01 << 17 //+ Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE            INTF = 0x01 << 18 //+ Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK          INTF = 0x01 << 19 //+ Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
	RX_SHORT_PACKET       INTF = 0x01 << 20 //+ Source: SIE_STATUS.RX_SHORT_PACKET
	ENDPOINT_ERROR        INTF = 0x01 << 21 //+ Source: SIE_STATUS.ENDPOINT_ERROR
	DEV_SM_WATCHDOG_FIRED INTF = 0x01 << 22 //+ Source: DEV_SM_WATCHDOG.FIRED
	EPX_STOPPED_ON_NAK    INTF = 0x01 << 23 //+ Source: NAK_POLL.EPX_STOPPED_ON_NAK
)

const (
	HOST_CONN_DISn         = 0
	HOST_RESUMEn           = 1
	HOST_SOFn              = 2
	TRANS_COMPLETEn        = 3
	BUFF_STATUSn           = 4
	ERROR_DATA_SEQn        = 5
	ERROR_RX_TIMEOUTn      = 6
	ERROR_RX_OVERFLOWn     = 7
	ERROR_BIT_STUFFn       = 8
	ERROR_CRCn             = 9
	STALLn                 = 10
	VBUS_DETECTn           = 11
	BUS_RESETn             = 12
	DEV_CONN_DISn          = 13
	DEV_SUSPENDn           = 14
	DEV_RESUME_FROM_HOSTn  = 15
	SETUP_REQn             = 16
	DEV_SOFn               = 17
	ABORT_DONEn            = 18
	EP_STALL_NAKn          = 19
	RX_SHORT_PACKETn       = 20
	ENDPOINT_ERRORn        = 21
	DEV_SM_WATCHDOG_FIREDn = 22
	EPX_STOPPED_ON_NAKn    = 23
)

const (
	HOST_CONN_DIS         INTS = 0x01 << 0  //+ Host: raised when a device is connected or disconnected (i.e. when SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
	HOST_RESUME           INTS = 0x01 << 1  //+ Host: raised when a device wakes up the host. Cleared by writing to SIE_STATUS.RESUME
	HOST_SOF              INTS = 0x01 << 2  //+ Host: raised every time the host sends a SOF (Start of Frame). Cleared by reading SOF_RD
	TRANS_COMPLETE        INTS = 0x01 << 3  //+ Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to this bit.
	BUFF_STATUS           INTS = 0x01 << 4  //+ Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in BUFF_STATUS.
	ERROR_DATA_SEQ        INTS = 0x01 << 5  //+ Source: SIE_STATUS.DATA_SEQ_ERROR
	ERROR_RX_TIMEOUT      INTS = 0x01 << 6  //+ Source: SIE_STATUS.RX_TIMEOUT
	ERROR_RX_OVERFLOW     INTS = 0x01 << 7  //+ Source: SIE_STATUS.RX_OVERFLOW
	ERROR_BIT_STUFF       INTS = 0x01 << 8  //+ Source: SIE_STATUS.BIT_STUFF_ERROR
	ERROR_CRC             INTS = 0x01 << 9  //+ Source: SIE_STATUS.CRC_ERROR
	STALL                 INTS = 0x01 << 10 //+ Source: SIE_STATUS.STALL_REC
	VBUS_DETECT           INTS = 0x01 << 11 //+ Source: SIE_STATUS.VBUS_DETECTED
	BUS_RESET             INTS = 0x01 << 12 //+ Source: SIE_STATUS.BUS_RESET
	DEV_CONN_DIS          INTS = 0x01 << 13 //+ Set when the device connection state changes. Cleared by writing to SIE_STATUS.CONNECTED
	DEV_SUSPEND           INTS = 0x01 << 14 //+ Set when the device suspend state changes. Cleared by writing to SIE_STATUS.SUSPENDED
	DEV_RESUME_FROM_HOST  INTS = 0x01 << 15 //+ Set when the device receives a resume from the host. Cleared by writing to SIE_STATUS.RESUME
	SETUP_REQ             INTS = 0x01 << 16 //+ Device. Source: SIE_STATUS.SETUP_REC
	DEV_SOF               INTS = 0x01 << 17 //+ Set every time the device receives a SOF (Start of Frame) packet. Cleared by reading SOF_RD
	ABORT_DONE            INTS = 0x01 << 18 //+ Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in ABORT_DONE.
	EP_STALL_NAK          INTS = 0x01 << 19 //+ Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all bits in EP_STATUS_STALL_NAK.
	RX_SHORT_PACKET       INTS = 0x01 << 20 //+ Source: SIE_STATUS.RX_SHORT_PACKET
	ENDPOINT_ERROR        INTS = 0x01 << 21 //+ Source: SIE_STATUS.ENDPOINT_ERROR
	DEV_SM_WATCHDOG_FIRED INTS = 0x01 << 22 //+ Source: DEV_SM_WATCHDOG.FIRED
	EPX_STOPPED_ON_NAK    INTS = 0x01 << 23 //+ Source: NAK_POLL.EPX_STOPPED_ON_NAK
)

const (
	HOST_CONN_DISn         = 0
	HOST_RESUMEn           = 1
	HOST_SOFn              = 2
	TRANS_COMPLETEn        = 3
	BUFF_STATUSn           = 4
	ERROR_DATA_SEQn        = 5
	ERROR_RX_TIMEOUTn      = 6
	ERROR_RX_OVERFLOWn     = 7
	ERROR_BIT_STUFFn       = 8
	ERROR_CRCn             = 9
	STALLn                 = 10
	VBUS_DETECTn           = 11
	BUS_RESETn             = 12
	DEV_CONN_DISn          = 13
	DEV_SUSPENDn           = 14
	DEV_RESUME_FROM_HOSTn  = 15
	SETUP_REQn             = 16
	DEV_SOFn               = 17
	ABORT_DONEn            = 18
	EP_STALL_NAKn          = 19
	RX_SHORT_PACKETn       = 20
	ENDPOINT_ERRORn        = 21
	DEV_SM_WATCHDOG_FIREDn = 22
	EPX_STOPPED_ON_NAKn    = 23
)

const (
	STATE    SM_STATE = 0x1F << 0 //+
	BC_STATE SM_STATE = 0x07 << 5 //+
	RX_DASM  SM_STATE = 0x0F << 8 //+
)

const (
	STATEn    = 0
	BC_STATEn = 5
	RX_DASMn  = 8
)

const (
	EP0  EP_TX_ERROR = 0x03 << 0  //+
	EP1  EP_TX_ERROR = 0x03 << 2  //+
	EP2  EP_TX_ERROR = 0x03 << 4  //+
	EP3  EP_TX_ERROR = 0x03 << 6  //+
	EP4  EP_TX_ERROR = 0x03 << 8  //+
	EP5  EP_TX_ERROR = 0x03 << 10 //+
	EP6  EP_TX_ERROR = 0x03 << 12 //+
	EP7  EP_TX_ERROR = 0x03 << 14 //+
	EP8  EP_TX_ERROR = 0x03 << 16 //+
	EP9  EP_TX_ERROR = 0x03 << 18 //+
	EP10 EP_TX_ERROR = 0x03 << 20 //+
	EP11 EP_TX_ERROR = 0x03 << 22 //+
	EP12 EP_TX_ERROR = 0x03 << 24 //+
	EP13 EP_TX_ERROR = 0x03 << 26 //+
	EP14 EP_TX_ERROR = 0x03 << 28 //+
	EP15 EP_TX_ERROR = 0x03 << 30 //+
)

const (
	EP0n  = 0
	EP1n  = 2
	EP2n  = 4
	EP3n  = 6
	EP4n  = 8
	EP5n  = 10
	EP6n  = 12
	EP7n  = 14
	EP8n  = 16
	EP9n  = 18
	EP10n = 20
	EP11n = 22
	EP12n = 24
	EP13n = 26
	EP14n = 28
	EP15n = 30
)

const (
	EP0_TRANSACTION  EP_RX_ERROR = 0x01 << 0  //+
	EP0_SEQ          EP_RX_ERROR = 0x01 << 1  //+
	EP1_TRANSACTION  EP_RX_ERROR = 0x01 << 2  //+
	EP1_SEQ          EP_RX_ERROR = 0x01 << 3  //+
	EP2_TRANSACTION  EP_RX_ERROR = 0x01 << 4  //+
	EP2_SEQ          EP_RX_ERROR = 0x01 << 5  //+
	EP3_TRANSACTION  EP_RX_ERROR = 0x01 << 6  //+
	EP3_SEQ          EP_RX_ERROR = 0x01 << 7  //+
	EP4_TRANSACTION  EP_RX_ERROR = 0x01 << 8  //+
	EP4_SEQ          EP_RX_ERROR = 0x01 << 9  //+
	EP5_TRANSACTION  EP_RX_ERROR = 0x01 << 10 //+
	EP5_SEQ          EP_RX_ERROR = 0x01 << 11 //+
	EP6_TRANSACTION  EP_RX_ERROR = 0x01 << 12 //+
	EP6_SEQ          EP_RX_ERROR = 0x01 << 13 //+
	EP7_TRANSACTION  EP_RX_ERROR = 0x01 << 14 //+
	EP7_SEQ          EP_RX_ERROR = 0x01 << 15 //+
	EP8_TRANSACTION  EP_RX_ERROR = 0x01 << 16 //+
	EP8_SEQ          EP_RX_ERROR = 0x01 << 17 //+
	EP9_TRANSACTION  EP_RX_ERROR = 0x01 << 18 //+
	EP9_SEQ          EP_RX_ERROR = 0x01 << 19 //+
	EP10_TRANSACTION EP_RX_ERROR = 0x01 << 20 //+
	EP10_SEQ         EP_RX_ERROR = 0x01 << 21 //+
	EP11_TRANSACTION EP_RX_ERROR = 0x01 << 22 //+
	EP11_SEQ         EP_RX_ERROR = 0x01 << 23 //+
	EP12_TRANSACTION EP_RX_ERROR = 0x01 << 24 //+
	EP12_SEQ         EP_RX_ERROR = 0x01 << 25 //+
	EP13_TRANSACTION EP_RX_ERROR = 0x01 << 26 //+
	EP13_SEQ         EP_RX_ERROR = 0x01 << 27 //+
	EP14_TRANSACTION EP_RX_ERROR = 0x01 << 28 //+
	EP14_SEQ         EP_RX_ERROR = 0x01 << 29 //+
	EP15_TRANSACTION EP_RX_ERROR = 0x01 << 30 //+
	EP15_SEQ         EP_RX_ERROR = 0x01 << 31 //+
)

const (
	EP0_TRANSACTIONn  = 0
	EP0_SEQn          = 1
	EP1_TRANSACTIONn  = 2
	EP1_SEQn          = 3
	EP2_TRANSACTIONn  = 4
	EP2_SEQn          = 5
	EP3_TRANSACTIONn  = 6
	EP3_SEQn          = 7
	EP4_TRANSACTIONn  = 8
	EP4_SEQn          = 9
	EP5_TRANSACTIONn  = 10
	EP5_SEQn          = 11
	EP6_TRANSACTIONn  = 12
	EP6_SEQn          = 13
	EP7_TRANSACTIONn  = 14
	EP7_SEQn          = 15
	EP8_TRANSACTIONn  = 16
	EP8_SEQn          = 17
	EP9_TRANSACTIONn  = 18
	EP9_SEQn          = 19
	EP10_TRANSACTIONn = 20
	EP10_SEQn         = 21
	EP11_TRANSACTIONn = 22
	EP11_SEQn         = 23
	EP12_TRANSACTIONn = 24
	EP12_SEQn         = 25
	EP13_TRANSACTIONn = 26
	EP13_SEQn         = 27
	EP14_TRANSACTIONn = 28
	EP14_SEQn         = 29
	EP15_TRANSACTIONn = 30
	EP15_SEQn         = 31
)

const (
	LIMIT  DEV_SM_WATCHDOG = 0x3FFFF << 0 //+
	ENABLE DEV_SM_WATCHDOG = 0x01 << 18   //+
	RESET  DEV_SM_WATCHDOG = 0x01 << 19   //+ Set to 1 to forcibly reset the device state machine on watchdog expiry
	FIRED  DEV_SM_WATCHDOG = 0x01 << 20   //+
)

const (
	LIMITn  = 0
	ENABLEn = 18
	RESETn  = 19
	FIREDn  = 20
)
