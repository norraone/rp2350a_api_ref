// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package hstxctrl provides access to the registers of the HSTX_CTRL peripheral.
//
// Instances:
//
//	HSTX_CTRL  HSTX_CTRL_BASE  -  -  Control interface to HSTX. For FIFO write access and status, see the HSTX_FIFO register block.
//
// Registers:
//
//	0x000 32  CSR
//	0x004 32  BIT0          Data control register for output bit 0
//	0x008 32  BIT1          Data control register for output bit 1
//	0x00C 32  BIT2          Data control register for output bit 2
//	0x010 32  BIT3          Data control register for output bit 3
//	0x014 32  BIT4          Data control register for output bit 4
//	0x018 32  BIT5          Data control register for output bit 5
//	0x01C 32  BIT6          Data control register for output bit 6
//	0x020 32  BIT7          Data control register for output bit 7
//	0x024 32  EXPAND_SHIFT  Configure the optional shifter inside the command expander
//	0x028 32  EXPAND_TMDS   Configure the optional TMDS encoder inside the command expander
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package hstxctrl

const (
	EN           CSR = 0x01 << 0  //+ When EN is 1, the HSTX will shift out data as it appears in the FIFO. As long as there is data, the HSTX shift register will shift once per clock cycle, and the frequency of popping from the FIFO is determined by the ratio of SHIFT and SHIFT_THRESH. When EN is 0, the FIFO is not popped. The shift counter and clock generator are also reset to their initial state for as long as EN is low. Note the initial phase of the clock generator can be configured by the CLKPHASE field. Once the HSTX is enabled again, and data is pushed to the FIFO, the generated clock's first rising edge will be one half-period after the first data is launched.
	EXPAND_EN    CSR = 0x01 << 1  //+ Enable the command expander. When 0, raw FIFO data is passed directly to the output shift register. When 1, the command expander can perform simple operations such as run length decoding on data between the FIFO and the shift register. Do not change CXPD_EN whilst EN is set. It's safe to set CXPD_EN simultaneously with setting EN.
	COUPLED_MODE CSR = 0x01 << 4  //+ Enable the PIO-to-HSTX 1:1 connection. The HSTX must be clocked *directly* from the system clock (not just from some other clock source of the same frequency) for this synchronous interface to function correctly. When COUPLED_MODE is set, BITx_SEL_P and SEL_N indices 24 through 31 will select bits from the 8-bit PIO-to-HSTX path, rather than shifter bits. Indices of 0 through 23 will still index the shift register as normal. The PIO outputs connected to the PIO-to-HSTX bus are those same outputs that would appear on the HSTX-capable pins if those pins' FUNCSELs were set to PIO instead of HSTX. For example, if HSTX is on GPIOs 12 through 19, then PIO outputs 12 through 19 are connected to the HSTX when coupled mode is engaged.
	COUPLED_SEL  CSR = 0x03 << 5  //+ Select which PIO to use for coupled mode operation.
	SHIFT        CSR = 0x1F << 8  //+ How many bits to right-rotate the shift register by each cycle. The use of a rotate rather than a shift allows left shifts to be emulated, by subtracting the left-shift amount from 32. It also allows data to be repeated, when the product of SHIFT and N_SHIFTS is greater than 32.
	N_SHIFTS     CSR = 0x1F << 16 //+ Number of times to shift the shift register before refilling it from the FIFO. (A count of how many times it has been shifted, *not* the total shift distance.) A register value of 0 means shift 32 times.
	CLKPHASE     CSR = 0x0F << 24 //+ Set the initial phase of the generated clock. A CLKPHASE of 0 means the clock is initially low, and the first rising edge occurs after one half period of the generated clock (i.e. CLKDIV/2 cycles of clk_hstx). Incrementing CLKPHASE by 1 will advance the initial clock phase by one half clk_hstx period. For example, if CLKDIV=2 and CLKPHASE=1: * The clock will be initially low * The first rising edge will be 0.5 clk_hstx cycles after asserting first data * The first falling edge will be 1.5 clk_hstx cycles after asserting first data This configuration would be suitable for serialising at a bit rate of clk_hstx with a centre-aligned DDR clock. When the HSTX is halted by clearing CSR_EN, the clock generator will return to its initial phase as configured by the CLKPHASE field. Note CLKPHASE must be strictly less than double the value of CLKDIV (one full period), else its operation is undefined.
	CLKDIV       CSR = 0x0F << 28 //+ Clock period of the generated clock, measured in HSTX clock cycles. Can be odd or even. The generated clock advances only on cycles where the shift register shifts. For example, a clkdiv of 5 would generate a complete output clock period for every 5 HSTX clocks (or every 10 half-clocks). A CLKDIV value of 0 is mapped to a period of 16 HSTX clock cycles.
)

const (
	ENn           = 0
	EXPAND_ENn    = 1
	COUPLED_MODEn = 4
	COUPLED_SELn  = 5
	SHIFTn        = 8
	N_SHIFTSn     = 16
	CLKPHASEn     = 24
	CLKDIVn       = 28
)

const (
	SEL_P BIT0 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT0 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT0 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT0 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT1 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT1 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT1 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT1 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT2 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT2 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT2 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT2 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT3 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT3 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT3 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT3 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT4 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT4 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT4 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT4 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT5 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT5 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT5 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT5 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT6 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT6 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT6 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT6 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	SEL_P BIT7 = 0x1F << 0  //+ Shift register data bit select for the first half of the HSTX clock cycle
	SEL_N BIT7 = 0x1F << 8  //+ Shift register data bit select for the second half of the HSTX clock cycle
	INV   BIT7 = 0x01 << 16 //+ Invert this data output (logical NOT)
	CLK   BIT7 = 0x01 << 17 //+ Connect this output to the generated clock, rather than the data shift register. SEL_P and SEL_N are ignored if this bit is set, but INV can still be set to generate an antiphase clock.
)

const (
	SEL_Pn = 0
	SEL_Nn = 8
	INVn   = 16
	CLKn   = 17
)

const (
	RAW_SHIFT    EXPAND_SHIFT = 0x1F << 0  //+ How many bits to right-rotate the shift register by each time data is pushed to the output shifter, when the current command is a raw data command.
	RAW_N_SHIFTS EXPAND_SHIFT = 0x1F << 8  //+ Number of times to consume from the shift register before refilling it from the FIFO, when the current command is a raw data command. A register value of 0 means shift 32 times.
	ENC_SHIFT    EXPAND_SHIFT = 0x1F << 16 //+ How many bits to right-rotate the shift register by each time data is pushed to the output shifter, when the current command is an encoded data command (e.g. TMDS).
	ENC_N_SHIFTS EXPAND_SHIFT = 0x1F << 24 //+ Number of times to consume from the shift register before refilling it from the FIFO, when the current command is an encoded data command (e.g. TMDS). A register value of 0 means shift 32 times.
)

const (
	RAW_SHIFTn    = 0
	RAW_N_SHIFTSn = 8
	ENC_SHIFTn    = 16
	ENC_N_SHIFTSn = 24
)

const (
	L0_ROT   EXPAND_TMDS = 0x1F << 0  //+ Right-rotate applied to the current shifter data before the lane 0 TMDS encoder.
	L0_NBITS EXPAND_TMDS = 0x07 << 5  //+ Number of valid data bits for the lane 0 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -> 7 encode counts of 1 -> 8 bits.
	L1_ROT   EXPAND_TMDS = 0x1F << 8  //+ Right-rotate applied to the current shifter data before the lane 1 TMDS encoder.
	L1_NBITS EXPAND_TMDS = 0x07 << 13 //+ Number of valid data bits for the lane 1 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -> 7 encode counts of 1 -> 8 bits.
	L2_ROT   EXPAND_TMDS = 0x1F << 16 //+ Right-rotate applied to the current shifter data before the lane 2 TMDS encoder.
	L2_NBITS EXPAND_TMDS = 0x07 << 21 //+ Number of valid data bits for the lane 2 TMDS encoder, starting from bit 7 of the rotated data. Field values of 0 -> 7 encode counts of 1 -> 8 bits.
)

const (
	L0_ROTn   = 0
	L0_NBITSn = 5
	L1_ROTn   = 8
	L1_NBITSn = 13
	L2_ROTn   = 16
	L2_NBITSn = 21
)
