// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package otp provides access to the registers of the OTP peripheral.
//
// Instances:
//
//	OTP  OTP_BASE  -  OTP  SNPS OTP control IF (SBPI and RPi wrapper control)
//
// Registers:
//
//	0x000 32  SW_LOCK0        Software lock register for page 0. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x004 32  SW_LOCK1        Software lock register for page 1. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x008 32  SW_LOCK2        Software lock register for page 2. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x00C 32  SW_LOCK3        Software lock register for page 3. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x010 32  SW_LOCK4        Software lock register for page 4. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x014 32  SW_LOCK5        Software lock register for page 5. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x018 32  SW_LOCK6        Software lock register for page 6. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x01C 32  SW_LOCK7        Software lock register for page 7. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x020 32  SW_LOCK8        Software lock register for page 8. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x024 32  SW_LOCK9        Software lock register for page 9. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x028 32  SW_LOCK10       Software lock register for page 10. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x02C 32  SW_LOCK11       Software lock register for page 11. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x030 32  SW_LOCK12       Software lock register for page 12. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x034 32  SW_LOCK13       Software lock register for page 13. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x038 32  SW_LOCK14       Software lock register for page 14. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x03C 32  SW_LOCK15       Software lock register for page 15. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x040 32  SW_LOCK16       Software lock register for page 16. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x044 32  SW_LOCK17       Software lock register for page 17. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x048 32  SW_LOCK18       Software lock register for page 18. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x04C 32  SW_LOCK19       Software lock register for page 19. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x050 32  SW_LOCK20       Software lock register for page 20. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x054 32  SW_LOCK21       Software lock register for page 21. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x058 32  SW_LOCK22       Software lock register for page 22. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x05C 32  SW_LOCK23       Software lock register for page 23. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x060 32  SW_LOCK24       Software lock register for page 24. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x064 32  SW_LOCK25       Software lock register for page 25. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x068 32  SW_LOCK26       Software lock register for page 26. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x06C 32  SW_LOCK27       Software lock register for page 27. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x070 32  SW_LOCK28       Software lock register for page 28. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x074 32  SW_LOCK29       Software lock register for page 29. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x078 32  SW_LOCK30       Software lock register for page 30. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x07C 32  SW_LOCK31       Software lock register for page 31. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x080 32  SW_LOCK32       Software lock register for page 32. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x084 32  SW_LOCK33       Software lock register for page 33. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x088 32  SW_LOCK34       Software lock register for page 34. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x08C 32  SW_LOCK35       Software lock register for page 35. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x090 32  SW_LOCK36       Software lock register for page 36. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x094 32  SW_LOCK37       Software lock register for page 37. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x098 32  SW_LOCK38       Software lock register for page 38. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x09C 32  SW_LOCK39       Software lock register for page 39. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0A0 32  SW_LOCK40       Software lock register for page 40. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0A4 32  SW_LOCK41       Software lock register for page 41. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0A8 32  SW_LOCK42       Software lock register for page 42. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0AC 32  SW_LOCK43       Software lock register for page 43. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0B0 32  SW_LOCK44       Software lock register for page 44. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0B4 32  SW_LOCK45       Software lock register for page 45. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0B8 32  SW_LOCK46       Software lock register for page 46. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0BC 32  SW_LOCK47       Software lock register for page 47. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0C0 32  SW_LOCK48       Software lock register for page 48. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0C4 32  SW_LOCK49       Software lock register for page 49. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0C8 32  SW_LOCK50       Software lock register for page 50. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0CC 32  SW_LOCK51       Software lock register for page 51. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0D0 32  SW_LOCK52       Software lock register for page 52. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0D4 32  SW_LOCK53       Software lock register for page 53. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0D8 32  SW_LOCK54       Software lock register for page 54. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0DC 32  SW_LOCK55       Software lock register for page 55. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0E0 32  SW_LOCK56       Software lock register for page 56. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0E4 32  SW_LOCK57       Software lock register for page 57. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0E8 32  SW_LOCK58       Software lock register for page 58. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0EC 32  SW_LOCK59       Software lock register for page 59. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0F0 32  SW_LOCK60       Software lock register for page 60. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0F4 32  SW_LOCK61       Software lock register for page 61. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0F8 32  SW_LOCK62       Software lock register for page 62. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x0FC 32  SW_LOCK63       Software lock register for page 63. Locks are initialised from the OTP lock pages at reset. This register can be written to further advance the lock state of each page (until next reset), and read to check the current lock state of a page.
//	0x100 32  SBPI_INSTR      Dispatch instructions to the SBPI interface, used for programming the OTP fuses.
//	0x104 32  SBPI_WDATA_0    SBPI write payload bytes 3..0
//	0x108 32  SBPI_WDATA_1    SBPI write payload bytes 7..4
//	0x10C 32  SBPI_WDATA_2    SBPI write payload bytes 11..8
//	0x110 32  SBPI_WDATA_3    SBPI write payload bytes 15..12
//	0x114 32  SBPI_RDATA_0    Read payload bytes 3..0. Once read, the data in the register will automatically clear to 0.
//	0x118 32  SBPI_RDATA_1    Read payload bytes 7..4. Once read, the data in the register will automatically clear to 0.
//	0x11C 32  SBPI_RDATA_2    Read payload bytes 11..8. Once read, the data in the register will automatically clear to 0.
//	0x120 32  SBPI_RDATA_3    Read payload bytes 15..12. Once read, the data in the register will automatically clear to 0.
//	0x124 32  SBPI_STATUS
//	0x128 32  USR             Controls for APB data read interface (USER interface)
//	0x12C 32  DBG             Debug for OTP power-on state machine
//	0x134 32  BIST            During BIST, count address locations that have at least one leaky bit
//	0x138 32  CRT_KEY_W0      Word 0 (bits 31..0) of the key. Write only, read returns 0x0
//	0x13C 32  CRT_KEY_W1      Word 1 (bits 63..32) of the key. Write only, read returns 0x0
//	0x140 32  CRT_KEY_W2      Word 2 (bits 95..64) of the key. Write only, read returns 0x0
//	0x144 32  CRT_KEY_W3      Word 3 (bits 127..96) of the key. Write only, read returns 0x0
//	0x148 32  CRITICAL        Quickly check values of critical flags read during boot up
//	0x14C 32  KEY_VALID       Which keys were valid (enrolled) at boot time
//	0x150 32  DEBUGEN         Enable a debug feature that has been disabled. Debug features are disabled if one of the relevant critical boot flags is set in OTP (DEBUG_DISABLE or SECURE_DEBUG_DISABLE), OR if a debug key is marked valid in OTP, and the matching key value has not been supplied over SWD. Specifically: - The DEBUG_DISABLE flag disables all debug features. This can be fully overridden by setting all bits of this register. - The SECURE_DEBUG_DISABLE flag disables secure processor debug. This can be fully overridden by setting the PROC0_SECURE and PROC1_SECURE bits of this register. - If a single debug key has been registered, and no matching key value has been supplied over SWD, then all debug features are disabled. This can be fully overridden by setting all bits of this register. - If both debug keys have been registered, and the Non-secure key's value (key 6) has been supplied over SWD, secure processor debug is disabled. This can be fully overridden by setting the PROC0_SECURE and PROC1_SECURE bits of this register. - If both debug keys have been registered, and the Secure key's value (key 5) has been supplied over SWD, then no debug features are disabled by the key mechanism. However, note that in this case debug features may still be disabled by the critical boot flags.
//	0x154 32  DEBUGEN_LOCK    Write 1s to lock corresponding bits in DEBUGEN. This register is reset by the processor cold reset.
//	0x158 32  ARCHSEL         Architecture select (Arm/RISC-V). The default and allowable values of this register are constrained by the critical boot flags. This register is reset by the earliest reset in the switched core power domain (before a processor cold reset). Cores sample their architecture select signal on a warm reset. The source of the warm reset could be the system power-up state machine, the watchdog timer, Arm SYSRESETREQ or from RISC-V hartresetreq. Note that when an Arm core is deselected, its cold reset domain is also held in reset, since in particular the SYSRESETREQ bit becomes inaccessible once the core is deselected. Note also the RISC-V cores do not have a cold reset domain, since their corresponding controls are located in the Debug Module.
//	0x15C 32  ARCHSEL_STATUS  Get the current architecture select state of each core. Cores sample the current value of the ARCHSEL register when their warm reset is released, at which point the corresponding bit in this register will also update.
//	0x160 32  BOOTDIS         Tell the bootrom to ignore scratch register boot vectors (both power manager and watchdog) on the next power up. If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk that Secure code running at a later stage can unlock the pages by performing a watchdog reset that resets the OTP. This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at a later stage from accessing OTP in its unlocked state. Should be used in conjunction with the power manager BOOTDIS register.
//	0x164 32  INTR            Raw Interrupts
//	0x168 32  INTE            Interrupt Enable
//	0x16C 32  INTF            Interrupt Force
//	0x170 32  INTS            Interrupt status after masking & forcing
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package otp

const (
	SEC          SW_LOCK0 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK0 = 0x00 << 0
	READ_ONLY    SW_LOCK0 = 0x01 << 0
	INACCESSIBLE SW_LOCK0 = 0x03 << 0
	NSEC         SW_LOCK0 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK0 = 0x00 << 2
	READ_ONLY    SW_LOCK0 = 0x01 << 2
	INACCESSIBLE SW_LOCK0 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK1 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK1 = 0x00 << 0
	READ_ONLY    SW_LOCK1 = 0x01 << 0
	INACCESSIBLE SW_LOCK1 = 0x03 << 0
	NSEC         SW_LOCK1 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK1 = 0x00 << 2
	READ_ONLY    SW_LOCK1 = 0x01 << 2
	INACCESSIBLE SW_LOCK1 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK2 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK2 = 0x00 << 0
	READ_ONLY    SW_LOCK2 = 0x01 << 0
	INACCESSIBLE SW_LOCK2 = 0x03 << 0
	NSEC         SW_LOCK2 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK2 = 0x00 << 2
	READ_ONLY    SW_LOCK2 = 0x01 << 2
	INACCESSIBLE SW_LOCK2 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK3 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK3 = 0x00 << 0
	READ_ONLY    SW_LOCK3 = 0x01 << 0
	INACCESSIBLE SW_LOCK3 = 0x03 << 0
	NSEC         SW_LOCK3 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK3 = 0x00 << 2
	READ_ONLY    SW_LOCK3 = 0x01 << 2
	INACCESSIBLE SW_LOCK3 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK4 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK4 = 0x00 << 0
	READ_ONLY    SW_LOCK4 = 0x01 << 0
	INACCESSIBLE SW_LOCK4 = 0x03 << 0
	NSEC         SW_LOCK4 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK4 = 0x00 << 2
	READ_ONLY    SW_LOCK4 = 0x01 << 2
	INACCESSIBLE SW_LOCK4 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK5 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK5 = 0x00 << 0
	READ_ONLY    SW_LOCK5 = 0x01 << 0
	INACCESSIBLE SW_LOCK5 = 0x03 << 0
	NSEC         SW_LOCK5 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK5 = 0x00 << 2
	READ_ONLY    SW_LOCK5 = 0x01 << 2
	INACCESSIBLE SW_LOCK5 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK6 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK6 = 0x00 << 0
	READ_ONLY    SW_LOCK6 = 0x01 << 0
	INACCESSIBLE SW_LOCK6 = 0x03 << 0
	NSEC         SW_LOCK6 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK6 = 0x00 << 2
	READ_ONLY    SW_LOCK6 = 0x01 << 2
	INACCESSIBLE SW_LOCK6 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK7 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK7 = 0x00 << 0
	READ_ONLY    SW_LOCK7 = 0x01 << 0
	INACCESSIBLE SW_LOCK7 = 0x03 << 0
	NSEC         SW_LOCK7 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK7 = 0x00 << 2
	READ_ONLY    SW_LOCK7 = 0x01 << 2
	INACCESSIBLE SW_LOCK7 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK8 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK8 = 0x00 << 0
	READ_ONLY    SW_LOCK8 = 0x01 << 0
	INACCESSIBLE SW_LOCK8 = 0x03 << 0
	NSEC         SW_LOCK8 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK8 = 0x00 << 2
	READ_ONLY    SW_LOCK8 = 0x01 << 2
	INACCESSIBLE SW_LOCK8 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK9 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK9 = 0x00 << 0
	READ_ONLY    SW_LOCK9 = 0x01 << 0
	INACCESSIBLE SW_LOCK9 = 0x03 << 0
	NSEC         SW_LOCK9 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK9 = 0x00 << 2
	READ_ONLY    SW_LOCK9 = 0x01 << 2
	INACCESSIBLE SW_LOCK9 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK10 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK10 = 0x00 << 0
	READ_ONLY    SW_LOCK10 = 0x01 << 0
	INACCESSIBLE SW_LOCK10 = 0x03 << 0
	NSEC         SW_LOCK10 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK10 = 0x00 << 2
	READ_ONLY    SW_LOCK10 = 0x01 << 2
	INACCESSIBLE SW_LOCK10 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK11 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK11 = 0x00 << 0
	READ_ONLY    SW_LOCK11 = 0x01 << 0
	INACCESSIBLE SW_LOCK11 = 0x03 << 0
	NSEC         SW_LOCK11 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK11 = 0x00 << 2
	READ_ONLY    SW_LOCK11 = 0x01 << 2
	INACCESSIBLE SW_LOCK11 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK12 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK12 = 0x00 << 0
	READ_ONLY    SW_LOCK12 = 0x01 << 0
	INACCESSIBLE SW_LOCK12 = 0x03 << 0
	NSEC         SW_LOCK12 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK12 = 0x00 << 2
	READ_ONLY    SW_LOCK12 = 0x01 << 2
	INACCESSIBLE SW_LOCK12 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK13 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK13 = 0x00 << 0
	READ_ONLY    SW_LOCK13 = 0x01 << 0
	INACCESSIBLE SW_LOCK13 = 0x03 << 0
	NSEC         SW_LOCK13 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK13 = 0x00 << 2
	READ_ONLY    SW_LOCK13 = 0x01 << 2
	INACCESSIBLE SW_LOCK13 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK14 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK14 = 0x00 << 0
	READ_ONLY    SW_LOCK14 = 0x01 << 0
	INACCESSIBLE SW_LOCK14 = 0x03 << 0
	NSEC         SW_LOCK14 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK14 = 0x00 << 2
	READ_ONLY    SW_LOCK14 = 0x01 << 2
	INACCESSIBLE SW_LOCK14 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK15 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK15 = 0x00 << 0
	READ_ONLY    SW_LOCK15 = 0x01 << 0
	INACCESSIBLE SW_LOCK15 = 0x03 << 0
	NSEC         SW_LOCK15 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK15 = 0x00 << 2
	READ_ONLY    SW_LOCK15 = 0x01 << 2
	INACCESSIBLE SW_LOCK15 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK16 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK16 = 0x00 << 0
	READ_ONLY    SW_LOCK16 = 0x01 << 0
	INACCESSIBLE SW_LOCK16 = 0x03 << 0
	NSEC         SW_LOCK16 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK16 = 0x00 << 2
	READ_ONLY    SW_LOCK16 = 0x01 << 2
	INACCESSIBLE SW_LOCK16 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK17 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK17 = 0x00 << 0
	READ_ONLY    SW_LOCK17 = 0x01 << 0
	INACCESSIBLE SW_LOCK17 = 0x03 << 0
	NSEC         SW_LOCK17 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK17 = 0x00 << 2
	READ_ONLY    SW_LOCK17 = 0x01 << 2
	INACCESSIBLE SW_LOCK17 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK18 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK18 = 0x00 << 0
	READ_ONLY    SW_LOCK18 = 0x01 << 0
	INACCESSIBLE SW_LOCK18 = 0x03 << 0
	NSEC         SW_LOCK18 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK18 = 0x00 << 2
	READ_ONLY    SW_LOCK18 = 0x01 << 2
	INACCESSIBLE SW_LOCK18 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK19 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK19 = 0x00 << 0
	READ_ONLY    SW_LOCK19 = 0x01 << 0
	INACCESSIBLE SW_LOCK19 = 0x03 << 0
	NSEC         SW_LOCK19 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK19 = 0x00 << 2
	READ_ONLY    SW_LOCK19 = 0x01 << 2
	INACCESSIBLE SW_LOCK19 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK20 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK20 = 0x00 << 0
	READ_ONLY    SW_LOCK20 = 0x01 << 0
	INACCESSIBLE SW_LOCK20 = 0x03 << 0
	NSEC         SW_LOCK20 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK20 = 0x00 << 2
	READ_ONLY    SW_LOCK20 = 0x01 << 2
	INACCESSIBLE SW_LOCK20 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK21 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK21 = 0x00 << 0
	READ_ONLY    SW_LOCK21 = 0x01 << 0
	INACCESSIBLE SW_LOCK21 = 0x03 << 0
	NSEC         SW_LOCK21 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK21 = 0x00 << 2
	READ_ONLY    SW_LOCK21 = 0x01 << 2
	INACCESSIBLE SW_LOCK21 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK22 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK22 = 0x00 << 0
	READ_ONLY    SW_LOCK22 = 0x01 << 0
	INACCESSIBLE SW_LOCK22 = 0x03 << 0
	NSEC         SW_LOCK22 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK22 = 0x00 << 2
	READ_ONLY    SW_LOCK22 = 0x01 << 2
	INACCESSIBLE SW_LOCK22 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK23 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK23 = 0x00 << 0
	READ_ONLY    SW_LOCK23 = 0x01 << 0
	INACCESSIBLE SW_LOCK23 = 0x03 << 0
	NSEC         SW_LOCK23 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK23 = 0x00 << 2
	READ_ONLY    SW_LOCK23 = 0x01 << 2
	INACCESSIBLE SW_LOCK23 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK24 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK24 = 0x00 << 0
	READ_ONLY    SW_LOCK24 = 0x01 << 0
	INACCESSIBLE SW_LOCK24 = 0x03 << 0
	NSEC         SW_LOCK24 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK24 = 0x00 << 2
	READ_ONLY    SW_LOCK24 = 0x01 << 2
	INACCESSIBLE SW_LOCK24 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK25 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK25 = 0x00 << 0
	READ_ONLY    SW_LOCK25 = 0x01 << 0
	INACCESSIBLE SW_LOCK25 = 0x03 << 0
	NSEC         SW_LOCK25 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK25 = 0x00 << 2
	READ_ONLY    SW_LOCK25 = 0x01 << 2
	INACCESSIBLE SW_LOCK25 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK26 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK26 = 0x00 << 0
	READ_ONLY    SW_LOCK26 = 0x01 << 0
	INACCESSIBLE SW_LOCK26 = 0x03 << 0
	NSEC         SW_LOCK26 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK26 = 0x00 << 2
	READ_ONLY    SW_LOCK26 = 0x01 << 2
	INACCESSIBLE SW_LOCK26 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK27 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK27 = 0x00 << 0
	READ_ONLY    SW_LOCK27 = 0x01 << 0
	INACCESSIBLE SW_LOCK27 = 0x03 << 0
	NSEC         SW_LOCK27 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK27 = 0x00 << 2
	READ_ONLY    SW_LOCK27 = 0x01 << 2
	INACCESSIBLE SW_LOCK27 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK28 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK28 = 0x00 << 0
	READ_ONLY    SW_LOCK28 = 0x01 << 0
	INACCESSIBLE SW_LOCK28 = 0x03 << 0
	NSEC         SW_LOCK28 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK28 = 0x00 << 2
	READ_ONLY    SW_LOCK28 = 0x01 << 2
	INACCESSIBLE SW_LOCK28 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK29 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK29 = 0x00 << 0
	READ_ONLY    SW_LOCK29 = 0x01 << 0
	INACCESSIBLE SW_LOCK29 = 0x03 << 0
	NSEC         SW_LOCK29 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK29 = 0x00 << 2
	READ_ONLY    SW_LOCK29 = 0x01 << 2
	INACCESSIBLE SW_LOCK29 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK30 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK30 = 0x00 << 0
	READ_ONLY    SW_LOCK30 = 0x01 << 0
	INACCESSIBLE SW_LOCK30 = 0x03 << 0
	NSEC         SW_LOCK30 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK30 = 0x00 << 2
	READ_ONLY    SW_LOCK30 = 0x01 << 2
	INACCESSIBLE SW_LOCK30 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK31 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK31 = 0x00 << 0
	READ_ONLY    SW_LOCK31 = 0x01 << 0
	INACCESSIBLE SW_LOCK31 = 0x03 << 0
	NSEC         SW_LOCK31 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK31 = 0x00 << 2
	READ_ONLY    SW_LOCK31 = 0x01 << 2
	INACCESSIBLE SW_LOCK31 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK32 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK32 = 0x00 << 0
	READ_ONLY    SW_LOCK32 = 0x01 << 0
	INACCESSIBLE SW_LOCK32 = 0x03 << 0
	NSEC         SW_LOCK32 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK32 = 0x00 << 2
	READ_ONLY    SW_LOCK32 = 0x01 << 2
	INACCESSIBLE SW_LOCK32 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK33 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK33 = 0x00 << 0
	READ_ONLY    SW_LOCK33 = 0x01 << 0
	INACCESSIBLE SW_LOCK33 = 0x03 << 0
	NSEC         SW_LOCK33 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK33 = 0x00 << 2
	READ_ONLY    SW_LOCK33 = 0x01 << 2
	INACCESSIBLE SW_LOCK33 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK34 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK34 = 0x00 << 0
	READ_ONLY    SW_LOCK34 = 0x01 << 0
	INACCESSIBLE SW_LOCK34 = 0x03 << 0
	NSEC         SW_LOCK34 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK34 = 0x00 << 2
	READ_ONLY    SW_LOCK34 = 0x01 << 2
	INACCESSIBLE SW_LOCK34 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK35 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK35 = 0x00 << 0
	READ_ONLY    SW_LOCK35 = 0x01 << 0
	INACCESSIBLE SW_LOCK35 = 0x03 << 0
	NSEC         SW_LOCK35 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK35 = 0x00 << 2
	READ_ONLY    SW_LOCK35 = 0x01 << 2
	INACCESSIBLE SW_LOCK35 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK36 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK36 = 0x00 << 0
	READ_ONLY    SW_LOCK36 = 0x01 << 0
	INACCESSIBLE SW_LOCK36 = 0x03 << 0
	NSEC         SW_LOCK36 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK36 = 0x00 << 2
	READ_ONLY    SW_LOCK36 = 0x01 << 2
	INACCESSIBLE SW_LOCK36 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK37 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK37 = 0x00 << 0
	READ_ONLY    SW_LOCK37 = 0x01 << 0
	INACCESSIBLE SW_LOCK37 = 0x03 << 0
	NSEC         SW_LOCK37 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK37 = 0x00 << 2
	READ_ONLY    SW_LOCK37 = 0x01 << 2
	INACCESSIBLE SW_LOCK37 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK38 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK38 = 0x00 << 0
	READ_ONLY    SW_LOCK38 = 0x01 << 0
	INACCESSIBLE SW_LOCK38 = 0x03 << 0
	NSEC         SW_LOCK38 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK38 = 0x00 << 2
	READ_ONLY    SW_LOCK38 = 0x01 << 2
	INACCESSIBLE SW_LOCK38 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK39 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK39 = 0x00 << 0
	READ_ONLY    SW_LOCK39 = 0x01 << 0
	INACCESSIBLE SW_LOCK39 = 0x03 << 0
	NSEC         SW_LOCK39 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK39 = 0x00 << 2
	READ_ONLY    SW_LOCK39 = 0x01 << 2
	INACCESSIBLE SW_LOCK39 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK40 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK40 = 0x00 << 0
	READ_ONLY    SW_LOCK40 = 0x01 << 0
	INACCESSIBLE SW_LOCK40 = 0x03 << 0
	NSEC         SW_LOCK40 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK40 = 0x00 << 2
	READ_ONLY    SW_LOCK40 = 0x01 << 2
	INACCESSIBLE SW_LOCK40 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK41 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK41 = 0x00 << 0
	READ_ONLY    SW_LOCK41 = 0x01 << 0
	INACCESSIBLE SW_LOCK41 = 0x03 << 0
	NSEC         SW_LOCK41 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK41 = 0x00 << 2
	READ_ONLY    SW_LOCK41 = 0x01 << 2
	INACCESSIBLE SW_LOCK41 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK42 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK42 = 0x00 << 0
	READ_ONLY    SW_LOCK42 = 0x01 << 0
	INACCESSIBLE SW_LOCK42 = 0x03 << 0
	NSEC         SW_LOCK42 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK42 = 0x00 << 2
	READ_ONLY    SW_LOCK42 = 0x01 << 2
	INACCESSIBLE SW_LOCK42 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK43 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK43 = 0x00 << 0
	READ_ONLY    SW_LOCK43 = 0x01 << 0
	INACCESSIBLE SW_LOCK43 = 0x03 << 0
	NSEC         SW_LOCK43 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK43 = 0x00 << 2
	READ_ONLY    SW_LOCK43 = 0x01 << 2
	INACCESSIBLE SW_LOCK43 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK44 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK44 = 0x00 << 0
	READ_ONLY    SW_LOCK44 = 0x01 << 0
	INACCESSIBLE SW_LOCK44 = 0x03 << 0
	NSEC         SW_LOCK44 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK44 = 0x00 << 2
	READ_ONLY    SW_LOCK44 = 0x01 << 2
	INACCESSIBLE SW_LOCK44 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK45 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK45 = 0x00 << 0
	READ_ONLY    SW_LOCK45 = 0x01 << 0
	INACCESSIBLE SW_LOCK45 = 0x03 << 0
	NSEC         SW_LOCK45 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK45 = 0x00 << 2
	READ_ONLY    SW_LOCK45 = 0x01 << 2
	INACCESSIBLE SW_LOCK45 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK46 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK46 = 0x00 << 0
	READ_ONLY    SW_LOCK46 = 0x01 << 0
	INACCESSIBLE SW_LOCK46 = 0x03 << 0
	NSEC         SW_LOCK46 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK46 = 0x00 << 2
	READ_ONLY    SW_LOCK46 = 0x01 << 2
	INACCESSIBLE SW_LOCK46 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK47 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK47 = 0x00 << 0
	READ_ONLY    SW_LOCK47 = 0x01 << 0
	INACCESSIBLE SW_LOCK47 = 0x03 << 0
	NSEC         SW_LOCK47 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK47 = 0x00 << 2
	READ_ONLY    SW_LOCK47 = 0x01 << 2
	INACCESSIBLE SW_LOCK47 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK48 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK48 = 0x00 << 0
	READ_ONLY    SW_LOCK48 = 0x01 << 0
	INACCESSIBLE SW_LOCK48 = 0x03 << 0
	NSEC         SW_LOCK48 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK48 = 0x00 << 2
	READ_ONLY    SW_LOCK48 = 0x01 << 2
	INACCESSIBLE SW_LOCK48 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK49 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK49 = 0x00 << 0
	READ_ONLY    SW_LOCK49 = 0x01 << 0
	INACCESSIBLE SW_LOCK49 = 0x03 << 0
	NSEC         SW_LOCK49 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK49 = 0x00 << 2
	READ_ONLY    SW_LOCK49 = 0x01 << 2
	INACCESSIBLE SW_LOCK49 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK50 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK50 = 0x00 << 0
	READ_ONLY    SW_LOCK50 = 0x01 << 0
	INACCESSIBLE SW_LOCK50 = 0x03 << 0
	NSEC         SW_LOCK50 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK50 = 0x00 << 2
	READ_ONLY    SW_LOCK50 = 0x01 << 2
	INACCESSIBLE SW_LOCK50 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK51 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK51 = 0x00 << 0
	READ_ONLY    SW_LOCK51 = 0x01 << 0
	INACCESSIBLE SW_LOCK51 = 0x03 << 0
	NSEC         SW_LOCK51 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK51 = 0x00 << 2
	READ_ONLY    SW_LOCK51 = 0x01 << 2
	INACCESSIBLE SW_LOCK51 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK52 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK52 = 0x00 << 0
	READ_ONLY    SW_LOCK52 = 0x01 << 0
	INACCESSIBLE SW_LOCK52 = 0x03 << 0
	NSEC         SW_LOCK52 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK52 = 0x00 << 2
	READ_ONLY    SW_LOCK52 = 0x01 << 2
	INACCESSIBLE SW_LOCK52 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK53 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK53 = 0x00 << 0
	READ_ONLY    SW_LOCK53 = 0x01 << 0
	INACCESSIBLE SW_LOCK53 = 0x03 << 0
	NSEC         SW_LOCK53 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK53 = 0x00 << 2
	READ_ONLY    SW_LOCK53 = 0x01 << 2
	INACCESSIBLE SW_LOCK53 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK54 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK54 = 0x00 << 0
	READ_ONLY    SW_LOCK54 = 0x01 << 0
	INACCESSIBLE SW_LOCK54 = 0x03 << 0
	NSEC         SW_LOCK54 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK54 = 0x00 << 2
	READ_ONLY    SW_LOCK54 = 0x01 << 2
	INACCESSIBLE SW_LOCK54 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK55 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK55 = 0x00 << 0
	READ_ONLY    SW_LOCK55 = 0x01 << 0
	INACCESSIBLE SW_LOCK55 = 0x03 << 0
	NSEC         SW_LOCK55 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK55 = 0x00 << 2
	READ_ONLY    SW_LOCK55 = 0x01 << 2
	INACCESSIBLE SW_LOCK55 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK56 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK56 = 0x00 << 0
	READ_ONLY    SW_LOCK56 = 0x01 << 0
	INACCESSIBLE SW_LOCK56 = 0x03 << 0
	NSEC         SW_LOCK56 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK56 = 0x00 << 2
	READ_ONLY    SW_LOCK56 = 0x01 << 2
	INACCESSIBLE SW_LOCK56 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK57 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK57 = 0x00 << 0
	READ_ONLY    SW_LOCK57 = 0x01 << 0
	INACCESSIBLE SW_LOCK57 = 0x03 << 0
	NSEC         SW_LOCK57 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK57 = 0x00 << 2
	READ_ONLY    SW_LOCK57 = 0x01 << 2
	INACCESSIBLE SW_LOCK57 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK58 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK58 = 0x00 << 0
	READ_ONLY    SW_LOCK58 = 0x01 << 0
	INACCESSIBLE SW_LOCK58 = 0x03 << 0
	NSEC         SW_LOCK58 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK58 = 0x00 << 2
	READ_ONLY    SW_LOCK58 = 0x01 << 2
	INACCESSIBLE SW_LOCK58 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK59 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK59 = 0x00 << 0
	READ_ONLY    SW_LOCK59 = 0x01 << 0
	INACCESSIBLE SW_LOCK59 = 0x03 << 0
	NSEC         SW_LOCK59 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK59 = 0x00 << 2
	READ_ONLY    SW_LOCK59 = 0x01 << 2
	INACCESSIBLE SW_LOCK59 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK60 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK60 = 0x00 << 0
	READ_ONLY    SW_LOCK60 = 0x01 << 0
	INACCESSIBLE SW_LOCK60 = 0x03 << 0
	NSEC         SW_LOCK60 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK60 = 0x00 << 2
	READ_ONLY    SW_LOCK60 = 0x01 << 2
	INACCESSIBLE SW_LOCK60 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK61 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK61 = 0x00 << 0
	READ_ONLY    SW_LOCK61 = 0x01 << 0
	INACCESSIBLE SW_LOCK61 = 0x03 << 0
	NSEC         SW_LOCK61 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK61 = 0x00 << 2
	READ_ONLY    SW_LOCK61 = 0x01 << 2
	INACCESSIBLE SW_LOCK61 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK62 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK62 = 0x00 << 0
	READ_ONLY    SW_LOCK62 = 0x01 << 0
	INACCESSIBLE SW_LOCK62 = 0x03 << 0
	NSEC         SW_LOCK62 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK62 = 0x00 << 2
	READ_ONLY    SW_LOCK62 = 0x01 << 2
	INACCESSIBLE SW_LOCK62 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SEC          SW_LOCK63 = 0x03 << 0 //+ Secure lock status. Writes are OR'd with the current value. This field is read-only to Non-secure code.
	READ_WRITE   SW_LOCK63 = 0x00 << 0
	READ_ONLY    SW_LOCK63 = 0x01 << 0
	INACCESSIBLE SW_LOCK63 = 0x03 << 0
	NSEC         SW_LOCK63 = 0x03 << 2 //+ Non-secure lock status. Writes are OR'd with the current value.
	READ_WRITE   SW_LOCK63 = 0x00 << 2
	READ_ONLY    SW_LOCK63 = 0x01 << 2
	INACCESSIBLE SW_LOCK63 = 0x03 << 2
)

const (
	SECn  = 0
	NSECn = 2
)

const (
	SHORT_WDATA     SBPI_INSTR = 0xFF << 0  //+ wdata to be used only when payload_size_m1=0
	CMD             SBPI_INSTR = 0xFF << 8  //+
	TARGET          SBPI_INSTR = 0xFF << 16 //+ Instruction target, it can be PMC (0x3a) or DAP (0x02)
	PAYLOAD_SIZE_M1 SBPI_INSTR = 0x0F << 24 //+ Instruction payload size in bytes minus 1
	HAS_PAYLOAD     SBPI_INSTR = 0x01 << 28 //+ Instruction has payload (data to be written or to be read)
	IS_WR           SBPI_INSTR = 0x01 << 29 //+ Payload type is write
	EXEC            SBPI_INSTR = 0x01 << 30 //+ Execute instruction
)

const (
	SHORT_WDATAn     = 0
	CMDn             = 8
	TARGETn          = 16
	PAYLOAD_SIZE_M1n = 24
	HAS_PAYLOADn     = 28
	IS_WRn           = 29
	EXECn            = 30
)

const (
	RDATA_VLD  SBPI_STATUS = 0x01 << 0  //+ Read command has returned data
	INSTR_DONE SBPI_STATUS = 0x01 << 4  //+ Last instruction done
	INSTR_MISS SBPI_STATUS = 0x01 << 8  //+ Last instruction missed (dropped), as the previous has not finished running
	FLAG       SBPI_STATUS = 0x01 << 12 //+ SBPI flag
	MISO       SBPI_STATUS = 0xFF << 16 //+ SBPI MISO (master in - slave out): response from SBPI
)

const (
	RDATA_VLDn  = 0
	INSTR_DONEn = 4
	INSTR_MISSn = 8
	FLAGn       = 12
	MISOn       = 16
)

const (
	DCTRL USR = 0x01 << 0 //+ 1 enables USER interface; 0 disables USER interface (enables SBPI). This bit must be cleared before performing any SBPI access, such as when programming the OTP. The APB data read interface (USER interface) will be inaccessible during this time, and will return a bus error if any read is attempted.
	PD    USR = 0x01 << 4 //+ Power-down; 1 disables current reference. Must be 0 to read data from the OTP.
)

const (
	DCTRLn = 0
	PDn    = 4
)

const (
	PSM_DONE          DBG = 0x01 << 0  //+ PSM done status flag
	BOOT_DONE         DBG = 0x01 << 1  //+ PSM boot done status flag
	ROSC_UP_SEEN      DBG = 0x01 << 2  //+ Ring oscillator was seen up and running
	ROSC_UP           DBG = 0x01 << 3  //+ Ring oscillator is up and running
	PSM_STATE         DBG = 0x0F << 4  //+ Monitor the PSM FSM's state
	CUSTOMER_RMA_FLAG DBG = 0x01 << 12 //+ The chip is in RMA mode
)

const (
	PSM_DONEn          = 0
	BOOT_DONEn         = 1
	ROSC_UP_SEENn      = 2
	ROSC_UPn           = 3
	PSM_STATEn         = 4
	CUSTOMER_RMA_FLAGn = 12
)

const (
	CNT      BIST = 0x1FFF << 0 //+ Number of locations that have at least one leaky bit. Note: This count is true only if the BIST was initiated without the fix option.
	CNT_MAX  BIST = 0xFFF << 16 //+ The cnt_fail flag will be set if the number of leaky locations exceeds this number
	CNT_ENA  BIST = 0x01 << 28  //+ Enable the counter before the BIST function is initiated
	CNT_CLR  BIST = 0x01 << 29  //+ Clear counter before use
	CNT_FAIL BIST = 0x01 << 30  //+ Flag if the count of address locations with at least one leaky bit exceeds cnt_max
)

const (
	CNTn      = 0
	CNT_MAXn  = 16
	CNT_ENAn  = 28
	CNT_CLRn  = 29
	CNT_FAILn = 30
)

const (
	SECURE_BOOT_ENABLE     CRITICAL = 0x01 << 0  //+
	SECURE_DEBUG_DISABLE   CRITICAL = 0x01 << 1  //+
	DEBUG_DISABLE          CRITICAL = 0x01 << 2  //+
	DEFAULT_ARCHSEL        CRITICAL = 0x01 << 3  //+
	GLITCH_DETECTOR_ENABLE CRITICAL = 0x01 << 4  //+
	GLITCH_DETECTOR_SENS   CRITICAL = 0x03 << 5  //+
	ARM_DISABLE            CRITICAL = 0x01 << 16 //+
	RISCV_DISABLE          CRITICAL = 0x01 << 17 //+
)

const (
	SECURE_BOOT_ENABLEn     = 0
	SECURE_DEBUG_DISABLEn   = 1
	DEBUG_DISABLEn          = 2
	DEFAULT_ARCHSELn        = 3
	GLITCH_DETECTOR_ENABLEn = 4
	GLITCH_DETECTOR_SENSn   = 5
	ARM_DISABLEn            = 16
	RISCV_DISABLEn          = 17
)

const (
	PROC0        DEBUGEN = 0x01 << 0 //+ Enable core 0's Mem-AP if it is currently disabled. The Mem-AP is disabled by default if either of the debug disable critical flags is set, or if at least one debug key has been enrolled and the least secure of these enrolled key values has not been provided over SWD. Note also that core Mem-APs are unconditionally disabled when a core is switched to RISC-V mode (by setting the ARCHSEL bit and performing a warm reset of the core).
	PROC0_SECURE DEBUGEN = 0x01 << 1 //+ Permit core 0's Mem-AP to generate Secure accesses, assuming it is enabled at all. Also enable secure debug of core 0 (SPIDEN and SPNIDEN). Secure debug of core 0 is disabled by default if the secure debug disable critical flag is set, or if at least one debug key has been enrolled and the most secure of these enrolled key values not yet provided over SWD. Note also that core Mem-APs are unconditionally disabled when a core is switched to RISC-V mode (by setting the ARCHSEL bit and performing a warm reset of the core).
	PROC1        DEBUGEN = 0x01 << 2 //+ Enable core 1's Mem-AP if it is currently disabled. The Mem-AP is disabled by default if either of the debug disable critical flags is set, or if at least one debug key has been enrolled and the least secure of these enrolled key values has not been provided over SWD.
	PROC1_SECURE DEBUGEN = 0x01 << 3 //+ Permit core 1's Mem-AP to generate Secure accesses, assuming it is enabled at all. Also enable secure debug of core 1 (SPIDEN and SPNIDEN). Secure debug of core 1 is disabled by default if the secure debug disable critical flag is set, or if at least one debug key has been enrolled and the most secure of these enrolled key values not yet provided over SWD.
	MISC         DEBUGEN = 0x01 << 8 //+ Enable other debug components. Specifically, the CTI, and the APB-AP used to access the RISC-V Debug Module. These components are disabled by default if either of the debug disable critical flags is set, or if at least one debug key has been enrolled and the least secure of these enrolled key values has not been provided over SWD.
)

const (
	PROC0n        = 0
	PROC0_SECUREn = 1
	PROC1n        = 2
	PROC1_SECUREn = 3
	MISCn         = 8
)

const (
	PROC0        DEBUGEN_LOCK = 0x01 << 0 //+ Write 1 to lock the PROC0 bit of DEBUGEN. Can't be cleared once set.
	PROC0_SECURE DEBUGEN_LOCK = 0x01 << 1 //+ Write 1 to lock the PROC0_SECURE bit of DEBUGEN. Can't be cleared once set.
	PROC1        DEBUGEN_LOCK = 0x01 << 2 //+ Write 1 to lock the PROC1 bit of DEBUGEN. Can't be cleared once set.
	PROC1_SECURE DEBUGEN_LOCK = 0x01 << 3 //+ Write 1 to lock the PROC1_SECURE bit of DEBUGEN. Can't be cleared once set.
	MISC         DEBUGEN_LOCK = 0x01 << 8 //+ Write 1 to lock the MISC bit of DEBUGEN. Can't be cleared once set.
)

const (
	PROC0n        = 0
	PROC0_SECUREn = 1
	PROC1n        = 2
	PROC1_SECUREn = 3
	MISCn         = 8
)

const (
	CORE0 ARCHSEL = 0x01 << 0 //+ Select architecture for core 0.
	ARM   ARCHSEL = 0x00 << 0 //  Switch core 0 to Arm (Cortex-M33)
	RISCV ARCHSEL = 0x01 << 0 //  Switch core 0 to RISC-V (Hazard3)
	CORE1 ARCHSEL = 0x01 << 1 //+ Select architecture for core 1.
	ARM   ARCHSEL = 0x00 << 1 //  Switch core 1 to Arm (Cortex-M33)
	RISCV ARCHSEL = 0x01 << 1 //  Switch core 1 to RISC-V (Hazard3)
)

const (
	CORE0n = 0
	CORE1n = 1
)

const (
	CORE0 ARCHSEL_STATUS = 0x01 << 0 //+ Current architecture for core 0. Updated on processor warm reset.
	ARM   ARCHSEL_STATUS = 0x00 << 0 //  Core 0 is currently Arm (Cortex-M33)
	RISCV ARCHSEL_STATUS = 0x01 << 0 //  Core 0 is currently RISC-V (Hazard3)
	CORE1 ARCHSEL_STATUS = 0x01 << 1 //+ Current architecture for core 0. Updated on processor warm reset.
	ARM   ARCHSEL_STATUS = 0x00 << 1 //  Core 1 is currently Arm (Cortex-M33)
	RISCV ARCHSEL_STATUS = 0x01 << 1 //  Core 1 is currently RISC-V (Hazard3)
)

const (
	CORE0n = 0
	CORE1n = 1
)

const (
	NOW  BOOTDIS = 0x01 << 0 //+ When the core is powered down, the current value of BOOTDIS_NEXT is OR'd into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared. The bootrom checks this flag before reading the boot scratch registers. If it is set, the bootrom clears it, and ignores the BOOT registers. This prevents Secure software from diverting the boot path before a bootloader has had the chance to soft lock OTP pages containing sensitive data.
	NEXT BOOTDIS = 0x01 << 1 //+ This flag always ORs writes into its current contents. It can be set but not cleared by software. The BOOTDIS_NEXT bit is OR'd into the BOOTDIS_NOW bit when the core is powered down. Simultaneously, the BOOTDIS_NEXT bit is cleared. Setting this bit means that the boot scratch registers will be ignored following the next core power down. This flag should be set by an early boot stage that has soft-locked OTP pages, to prevent later stages from unlocking it via watchdog reset.
)

const (
	NOWn  = 0
	NEXTn = 1
)

const (
	SBPI_FLAG_N      INTR = 0x01 << 0 //+
	SBPI_WR_FAIL     INTR = 0x01 << 1 //+
	APB_DCTRL_FAIL   INTR = 0x01 << 2 //+
	APB_RD_SEC_FAIL  INTR = 0x01 << 3 //+
	APB_RD_NSEC_FAIL INTR = 0x01 << 4 //+
)

const (
	SBPI_FLAG_Nn      = 0
	SBPI_WR_FAILn     = 1
	APB_DCTRL_FAILn   = 2
	APB_RD_SEC_FAILn  = 3
	APB_RD_NSEC_FAILn = 4
)

const (
	SBPI_FLAG_N      INTE = 0x01 << 0 //+
	SBPI_WR_FAIL     INTE = 0x01 << 1 //+
	APB_DCTRL_FAIL   INTE = 0x01 << 2 //+
	APB_RD_SEC_FAIL  INTE = 0x01 << 3 //+
	APB_RD_NSEC_FAIL INTE = 0x01 << 4 //+
)

const (
	SBPI_FLAG_Nn      = 0
	SBPI_WR_FAILn     = 1
	APB_DCTRL_FAILn   = 2
	APB_RD_SEC_FAILn  = 3
	APB_RD_NSEC_FAILn = 4
)

const (
	SBPI_FLAG_N      INTF = 0x01 << 0 //+
	SBPI_WR_FAIL     INTF = 0x01 << 1 //+
	APB_DCTRL_FAIL   INTF = 0x01 << 2 //+
	APB_RD_SEC_FAIL  INTF = 0x01 << 3 //+
	APB_RD_NSEC_FAIL INTF = 0x01 << 4 //+
)

const (
	SBPI_FLAG_Nn      = 0
	SBPI_WR_FAILn     = 1
	APB_DCTRL_FAILn   = 2
	APB_RD_SEC_FAILn  = 3
	APB_RD_NSEC_FAILn = 4
)

const (
	SBPI_FLAG_N      INTS = 0x01 << 0 //+
	SBPI_WR_FAIL     INTS = 0x01 << 1 //+
	APB_DCTRL_FAIL   INTS = 0x01 << 2 //+
	APB_RD_SEC_FAIL  INTS = 0x01 << 3 //+
	APB_RD_NSEC_FAIL INTS = 0x01 << 4 //+
)

const (
	SBPI_FLAG_Nn      = 0
	SBPI_WR_FAILn     = 1
	APB_DCTRL_FAILn   = 2
	APB_RD_SEC_FAILn  = 3
	APB_RD_NSEC_FAILn = 4
)
