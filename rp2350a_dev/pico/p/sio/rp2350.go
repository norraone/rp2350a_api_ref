// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package sio provides access to the registers of the SIO peripheral.
//
// Instances:
//
//	SIO     SIO_BASE     -  SIO_FIFO+,SIO_BELL+,SIO_FIFO_NS+,SIO_BELL_NS+,SIO_MTIMECMP+  Single-cycle IO block Provides core-local and inter-core hardware for the two processors, with single-cycle access.
//	SIO_NS  SIO_NS_BASE  -  SIO_FIFO+,SIO_BELL+,SIO_FIFO_NS+,SIO_BELL_NS+,SIO_MTIMECMP+  Single-cycle IO block Provides core-local and inter-core hardware for the two processors, with single-cycle access.
//
// Registers:
//
//	0x000 32  CPUID                          Processor core identifier
//	0x004 32  GPIO_IN                        Input value for GPIO0...31. In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero.
//	0x008 32  GPIO_HI_IN(uint32)             Input value on GPIO32...47, QSPI IOs and USB pins In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero.
//	0x010 32  GPIO_OUT                       GPIO0...31 output value
//	0x014 32  GPIO_HI_OUT(uint32)            Output value for GPIO32...47, QSPI IOs and USB pins. Write to set output level (1/0 -> high/low). Reading back gives the last value written, NOT the input value from the pins. If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register.
//	0x018 32  GPIO_OUT_SET                   GPIO0...31 output value set
//	0x01C 32  GPIO_HI_OUT_SET(uint32)        Output value set for GPIO32..47, QSPI IOs and USB pins. Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT |= wdata`
//	0x020 32  GPIO_OUT_CLR                   GPIO0...31 output value clear
//	0x024 32  GPIO_HI_OUT_CLR(uint32)        Output value clear for GPIO32..47, QSPI IOs and USB pins. Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT &= ~wdata`
//	0x028 32  GPIO_OUT_XOR                   GPIO0...31 output value XOR
//	0x02C 32  GPIO_HI_OUT_XOR(uint32)        Output value XOR for GPIO32..47, QSPI IOs and USB pins. Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT ^= wdata`
//	0x030 32  GPIO_OE                        GPIO0...31 output enable
//	0x034 32  GPIO_HI_OE(uint32)             Output enable value for GPIO32...47, QSPI IOs and USB pins. Write output enable (1/0 -> output/input). Reading back gives the last value written. If core 0 and core 1 both write to GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first, and the write from core 1 was then applied to that intermediate result. In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as zero. This is also true for SET/CLR/XOR aliases of this register.
//	0x038 32  GPIO_OE_SET                    GPIO0...31 output enable set
//	0x03C 32  GPIO_HI_OE_SET(uint32)         Output enable set for GPIO32...47, QSPI IOs and USB pins. Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE |= wdata`
//	0x040 32  GPIO_OE_CLR                    GPIO0...31 output enable clear
//	0x044 32  GPIO_HI_OE_CLR(uint32)         Output enable clear for GPIO32...47, QSPI IOs and USB pins. Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE &= ~wdata`
//	0x048 32  GPIO_OE_XOR                    GPIO0...31 output enable XOR
//	0x04C 32  GPIO_HI_OE_XOR(uint32)         Output enable XOR for GPIO32...47, QSPI IOs and USB pins. Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE ^= wdata`
//	0x050 32  FIFO_ST                        Status register for inter-core FIFOs (mailboxes). There is one FIFO in the core 0 -> core 1 direction, and one core 1 -> core 0. Both are 32 bits wide and 8 words deep. Core 0 can see the read side of the 1->0 FIFO (RX), and the write side of 0->1 FIFO (TX). Core 1 can see the read side of the 0->1 FIFO (RX), and the write side of 1->0 FIFO (TX). The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
//	0x054 32  FIFO_WR                        Write access to this core's TX FIFO
//	0x058 32  FIFO_RD                        Read access to this core's RX FIFO
//	0x05C 32  SPINLOCK_ST                    Spinlock state A bitmap containing the state of all 32 spinlocks (1=locked). Mainly intended for debugging.
//	0x080 32  INTERP0_ACCUM0                 Read/write access to accumulator 0
//	0x084 32  INTERP0_ACCUM1                 Read/write access to accumulator 1
//	0x088 32  INTERP0_BASE0                  Read/write access to BASE0 register.
//	0x08C 32  INTERP0_BASE1                  Read/write access to BASE1 register.
//	0x090 32  INTERP0_BASE2                  Read/write access to BASE2 register.
//	0x094 32  INTERP0_POP_LANE0              Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
//	0x098 32  INTERP0_POP_LANE1              Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
//	0x09C 32  INTERP0_POP_FULL               Read FULL result, and simultaneously write lane results to both accumulators (POP).
//	0x0A0 32  INTERP0_PEEK_LANE0             Read LANE0 result, without altering any internal state (PEEK).
//	0x0A4 32  INTERP0_PEEK_LANE1             Read LANE1 result, without altering any internal state (PEEK).
//	0x0A8 32  INTERP0_PEEK_FULL              Read FULL result, without altering any internal state (PEEK).
//	0x0AC 32  INTERP0_CTRL_LANE0(CTRL_LANE)  Control register for lane 0
//	0x0B0 32  INTERP0_CTRL_LANE1(CTRL_LANE)  Control register for lane 1
//	0x0B4 32  INTERP0_ACCUM0_ADD             Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added).
//	0x0B8 32  INTERP0_ACCUM1_ADD             Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added).
//	0x0BC 32  INTERP0_BASE_1AND0             On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
//	0x0C0 32  INTERP1_ACCUM0                 Read/write access to accumulator 0
//	0x0C4 32  INTERP1_ACCUM1                 Read/write access to accumulator 1
//	0x0C8 32  INTERP1_BASE0                  Read/write access to BASE0 register.
//	0x0CC 32  INTERP1_BASE1                  Read/write access to BASE1 register.
//	0x0D0 32  INTERP1_BASE2                  Read/write access to BASE2 register.
//	0x0D4 32  INTERP1_POP_LANE0              Read LANE0 result, and simultaneously write lane results to both accumulators (POP).
//	0x0D8 32  INTERP1_POP_LANE1              Read LANE1 result, and simultaneously write lane results to both accumulators (POP).
//	0x0DC 32  INTERP1_POP_FULL               Read FULL result, and simultaneously write lane results to both accumulators (POP).
//	0x0E0 32  INTERP1_PEEK_LANE0             Read LANE0 result, without altering any internal state (PEEK).
//	0x0E4 32  INTERP1_PEEK_LANE1             Read LANE1 result, without altering any internal state (PEEK).
//	0x0E8 32  INTERP1_PEEK_FULL              Read FULL result, without altering any internal state (PEEK).
//	0x0EC 32  INTERP1_CTRL_LANE0(CTRL_LANE)  Control register for lane 0
//	0x0F0 32  INTERP1_CTRL_LANE1(CTRL_LANE)  Control register for lane 1
//	0x0F4 32  INTERP1_ACCUM0_ADD             Values written here are atomically added to ACCUM0 Reading yields lane 0's raw shift and mask value (BASE0 not added).
//	0x0F8 32  INTERP1_ACCUM1_ADD             Values written here are atomically added to ACCUM1 Reading yields lane 1's raw shift and mask value (BASE1 not added).
//	0x0FC 32  INTERP1_BASE_1AND0             On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously. Each half is sign-extended to 32 bits if that lane's SIGNED flag is set.
//	0x100 32  SPINLOCK0[32]                  Reading from a spinlock address will: - Return 0 if lock is already locked - Otherwise return nonzero, and simultaneously claim the lock Writing (any value) releases the lock. If core 0 and core 1 attempt to claim the same lock simultaneously, core 0 wins. The value returned on success is 0x1 << lock number.
//	0x180 32  DOORBELL_OUT_SET               Trigger a doorbell interrupt on the opposite core. Write 1 to a bit to set the corresponding bit in DOORBELL_IN on the opposite core. This raises the opposite core's doorbell interrupt. Read to get the status of the doorbells currently asserted on the opposite core. This is equivalent to that core reading its own DOORBELL_IN status.
//	0x184 32  DOORBELL_OUT_CLR               Clear doorbells which have been posted to the opposite core. This register is intended for debugging and initialisation purposes. Writing 1 to a bit in DOORBELL_OUT_CLR clears the corresponding bit in DOORBELL_IN on the opposite core. Clearing all bits will cause that core's doorbell interrupt to deassert. Since the usual order of events is for software to send events using DOORBELL_OUT_SET, and acknowledge incoming events by writing to DOORBELL_IN_CLR, this register should be used with caution to avoid race conditions. Reading returns the status of the doorbells currently asserted on the other core, i.e. is equivalent to that core reading its own DOORBELL_IN status.
//	0x188 32  DOORBELL_IN_SET                Write 1s to trigger doorbell interrupts on this core. Read to get status of doorbells currently asserted on this core.
//	0x18C 32  DOORBELL_IN_CLR                Check and acknowledge doorbells posted to this core. This core's doorbell interrupt is asserted when any bit in this register is 1. Write 1 to each bit to clear that bit. The doorbell interrupt deasserts once all bits are cleared. Read to get status of doorbells currently asserted on this core.
//	0x190 32  PERI_NONSEC                    Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure software can use them. Attempting to access one of these peripherals from the Secure SIO when it is attached to the Non-secure SIO, or vice versa, will generate a bus error. This register is per-core, and is only present on the Secure SIO. Most SIO hardware is duplicated across the Secure and Non-secure SIO, so is not listed in this register.
//	0x1A0 32  RISCV_SOFTIRQ                  Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores. Unlike the RISC-V timer, this interrupt is not routed to a normal system-level interrupt line, so can not be used by the Arm cores. It is safe for both cores to write to this register on the same cycle. The set/clear effect is accumulated across both cores, and then applied. If a flag is both set and cleared on the same cycle, only the set takes effect.
//	0x1A4 32  MTIME_CTRL                     Control register for the RISC-V 64-bit Machine-mode timer. This timer is only present in the Secure SIO, so is only accessible to an Arm core in Secure mode or a RISC-V core in Machine mode. Note whilst this timer follows the RISC-V privileged specification, it is equally usable by the Arm cores. The interrupts are routed to normal system-level interrupt lines as well as to the MIP.MTIP inputs on the RISC-V cores.
//	0x1B0 32  MTIME                          Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.
//	0x1B4 32  MTIMEH                         Read/write access to the high half of RISC-V Machine-mode timer. This register is shared between both cores. If both cores write on the same cycle, core 1 takes precedence.
//	0x1B8 32  MTIMECMP                       Low half of RISC-V Machine-mode timer comparator. This register is core-local, i.e., each core gets a copy of this register, with the comparison result routed to its own interrupt line. The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values.
//	0x1BC 32  MTIMECMPH                      High half of RISC-V Machine-mode timer comparator. This register is core-local. The timer interrupt is asserted whenever MTIME is greater than or equal to MTIMECMP. This comparison is unsigned, and performed on the full 64-bit values.
//	0x1C0 32  TMDS_CTRL                      Control register for TMDS encoder.
//	0x1C4 32  TMDS_WDATA                     Write-only access to the TMDS colour data register.
//	0x1C8 32  TMDS_PEEK_SINGLE               Get the encoding of one pixel's worth of colour data, packed into a 32-bit value (3x10-bit symbols). The PEEK alias does not shift the colour register when read, but still advances the running DC balance state of each encoder. This is useful for pixel doubling.
//	0x1CC 32  TMDS_POP_SINGLE                Get the encoding of one pixel's worth of colour data, packed into a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane. This format is intended for shifting out with the HSTX peripheral on RP2350. The POP alias shifts the colour register when read, as well as advancing the running DC balance state of each encoder.
//	0x1D0 32  TMDS_PEEK_DOUBLE_L0            Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The PEEK alias does not shift the colour register when read, but still advances the lane 0 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane.
//	0x1D4 32  TMDS_POP_DOUBLE_L0             Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT.
//	0x1D8 32  TMDS_PEEK_DOUBLE_L1            Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The PEEK alias does not shift the colour register when read, but still advances the lane 1 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane.
//	0x1DC 32  TMDS_POP_DOUBLE_L1             Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT.
//	0x1E0 32  TMDS_PEEK_DOUBLE_L2            Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The PEEK alias does not shift the colour register when read, but still advances the lane 2 DC balance state. This is useful if all 3 lanes' worth of encode are to be read at once, rather than processing the entire scanline for one lane before moving to the next lane.
//	0x1E4 32  TMDS_POP_DOUBLE_L2             Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit TMDS symbols are packed at the bottom of a 32-bit word. The POP alias shifts the colour register when read, according to the values of PIX_SHIFT and PIX2_NOSHIFT.
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package sio

const (
	GPIO     uint32 = 0xFFFF << 0 //+ Input value on GPIO32...47
	USB_DP   uint32 = 0x01 << 24  //+ Input value on USB D+ pin
	USB_DM   uint32 = 0x01 << 25  //+ Input value on USB D- pin
	QSPI_SCK uint32 = 0x01 << 26  //+ Input value on QSPI SCK pin
	QSPI_CSN uint32 = 0x01 << 27  //+ Input value on QSPI CSn pin
	QSPI_SD  uint32 = 0x0F << 28  //+ Input value on QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins
)

const (
	GPIOn     = 0
	USB_DPn   = 24
	USB_DMn   = 25
	QSPI_SCKn = 26
	QSPI_CSNn = 27
	QSPI_SDn  = 28
)

const (
	VLD FIFO_ST = 0x01 << 0 //+ Value is 1 if this core's RX FIFO is not empty (i.e. if FIFO_RD is valid)
	RDY FIFO_ST = 0x01 << 1 //+ Value is 1 if this core's TX FIFO is not full (i.e. if FIFO_WR is ready for more data)
	WOF FIFO_ST = 0x01 << 2 //+ Sticky flag indicating the TX FIFO was written when full. This write was ignored by the FIFO.
	ROE FIFO_ST = 0x01 << 3 //+ Sticky flag indicating the RX FIFO was read when empty. This read was ignored by the FIFO.
)

const (
	VLDn = 0
	RDYn = 1
	WOFn = 2
	ROEn = 3
)

const (
	SHIFT        CTRL_LANE = 0x1F << 0  //+ Right-rotate applied to accumulator before masking. By appropriately configuring the masks, left and right shifts can be synthesised.
	MASK_LSB     CTRL_LANE = 0x1F << 5  //+ The least-significant bit allowed to pass by the mask (inclusive)
	MASK_MSB     CTRL_LANE = 0x1F << 10 //+ The most-significant bit allowed to pass by the mask (inclusive) Setting MSB < LSB may cause chip to turn inside-out
	SIGNED       CTRL_LANE = 0x01 << 15 //+ If SIGNED is set, the shifted and masked accumulator value is sign-extended to 32 bits before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits when read by processor.
	CROSS_INPUT  CTRL_LANE = 0x01 << 16 //+ If 1, feed the opposite lane's accumulator into this lane's shift + mask hardware. Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the shift+mask bypass)
	CROSS_RESULT CTRL_LANE = 0x01 << 17 //+ If 1, feed the opposite lane's result into this lane's accumulator on POP.
	ADD_RAW      CTRL_LANE = 0x01 << 18 //+ If 1, mask + shift is bypassed for LANE0 result. This does not affect FULL result.
	FORCE_MSB    CTRL_LANE = 0x03 << 19 //+ ORed into bits 29:28 of the lane result presented to the processor on the bus. No effect on the internal 32-bit datapath. Handy for using a lane to generate sequence of pointers into flash or SRAM.
	BLEND        CTRL_LANE = 0x01 << 21 //+ Only present on INTERP0 on each core. If BLEND mode is enabled: - LANE1 result is a linear interpolation between BASE0 and BASE1, controlled by the 8 LSBs of lane 1 shift and mask value (a fractional number between 0 and 255/256ths) - LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1 shift+mask value) - FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0 shift+mask) LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.
	CLAMP        CTRL_LANE = 0x01 << 22 //+ Only present on INTERP1 on each core. If CLAMP mode is enabled: - LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of BASE0 and an upper bound of BASE1. - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED
	OVERF0       CTRL_LANE = 0x01 << 23 //+ Indicates if any masked-off MSBs in ACCUM0 are set.
	OVERF1       CTRL_LANE = 0x01 << 24 //+ Indicates if any masked-off MSBs in ACCUM1 are set.
	OVERF        CTRL_LANE = 0x01 << 25 //+ Set if either OVERF0 or OVERF1 is set.
)

const (
	SHIFTn        = 0
	MASK_LSBn     = 5
	MASK_MSBn     = 10
	SIGNEDn       = 15
	CROSS_INPUTn  = 16
	CROSS_RESULTn = 17
	ADD_RAWn      = 18
	FORCE_MSBn    = 19
	BLENDn        = 21
	CLAMPn        = 22
	OVERF0n       = 23
	OVERF1n       = 24
	OVERFn        = 25
)

const (
	INTERP0 PERI_NONSEC = 0x01 << 0 //+ If 1, detach interpolator 0 (of this core) from the Secure SIO, and attach to the Non-secure SIO.
	INTERP1 PERI_NONSEC = 0x01 << 1 //+ If 1, detach interpolator 1 (of this core) from the Secure SIO, and attach to the Non-secure SIO.
	TMDS    PERI_NONSEC = 0x01 << 5 //+ IF 1, detach TMDS encoder (of this core) from the Secure SIO, and attach to the Non-secure SIO.
)

const (
	INTERP0n = 0
	INTERP1n = 1
	TMDSn    = 5
)

const (
	CORE0_SET RISCV_SOFTIRQ = 0x01 << 0 //+ Write 1 to atomically set the core 0 software interrupt flag. Read to get the status of this flag.
	CORE1_SET RISCV_SOFTIRQ = 0x01 << 1 //+ Write 1 to atomically set the core 1 software interrupt flag. Read to get the status of this flag.
	CORE0_CLR RISCV_SOFTIRQ = 0x01 << 8 //+ Write 1 to atomically clear the core 0 software interrupt flag. Read to get the status of this flag.
	CORE1_CLR RISCV_SOFTIRQ = 0x01 << 9 //+ Write 1 to atomically clear the core 1 software interrupt flag. Read to get the status of this flag.
)

const (
	CORE0_SETn = 0
	CORE1_SETn = 1
	CORE0_CLRn = 8
	CORE1_CLRn = 9
)

const (
	EN             MTIME_CTRL = 0x01 << 0 //+ Timer enable bit. When 0, the timer will not increment automatically.
	FULLSPEED      MTIME_CTRL = 0x01 << 1 //+ If 1, increment the timer every cycle (i.e. run directly from the system clock), rather than incrementing on the system-level timer tick input.
	DBGPAUSE_CORE0 MTIME_CTRL = 0x01 << 2 //+ If 1, the timer pauses when core 0 is in the debug halt state.
	DBGPAUSE_CORE1 MTIME_CTRL = 0x01 << 3 //+ If 1, the timer pauses when core 1 is in the debug halt state.
)

const (
	ENn             = 0
	FULLSPEEDn      = 1
	DBGPAUSE_CORE0n = 2
	DBGPAUSE_CORE1n = 3
)

const (
	L0_ROT        TMDS_CTRL = 0x0F << 0  //+ Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 0 (blue) colour data aligned with the MSB of the 8-bit encoder input. For example, for RGB565 (red most significant), blue is bits 4:0, so should be right-rotated by 13 to align with bits 7:3 of the encoder input.
	L1_ROT        TMDS_CTRL = 0x0F << 4  //+ Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 1 (green) colour data aligned with the MSB of the 8-bit encoder input. For example, for RGB565, green is bits 10:5, so should be right-rotated by 3 bits to align with bits 7:2 of the encoder input.
	L2_ROT        TMDS_CTRL = 0x0F << 8  //+ Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in order to get the MSB of the lane 2 (red) colour data aligned with the MSB of the 8-bit encoder input. For example, for RGB565 (red most significant), red is bits 15:11, so should be right-rotated by 8 bits to align with bits 7:3 of the encoder input.
	L0_NBITS      TMDS_CTRL = 0x07 << 12 //+ Number of valid colour MSBs for lane 0 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
	L1_NBITS      TMDS_CTRL = 0x07 << 15 //+ Number of valid colour MSBs for lane 1 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
	L2_NBITS      TMDS_CTRL = 0x07 << 18 //+ Number of valid colour MSBs for lane 2 (1-8 bits, encoded as 0 through 7). Remaining LSBs are masked to 0 after the rotate.
	INTERLEAVE    TMDS_CTRL = 0x01 << 23 //+ Enable lane interleaving for reads of PEEK_SINGLE/POP_SINGLE. When interleaving is disabled, each of the 3 symbols appears as a contiguous 10-bit field, with lane 0 being the least-significant and starting at bit 0 of the register. When interleaving is enabled, the symbols are packed into 5 chunks of 3 lanes times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol per lane, with lane 0 being the least significant.
	PIX_SHIFT     TMDS_CTRL = 0x07 << 24 //+ Shift applied to the colour data register with each read of a POP alias register. Reading from the POP_SINGLE register, or reading from the POP_DOUBLE register with PIX2_NOSHIFT set (for pixel doubling), shifts by the indicated amount. Reading from a POP_DOUBLE register when PIX2_NOSHIFT is clear will shift by double the indicated amount. (Shift by 32 means no shift.)
	PIX2_NOSHIFT  TMDS_CTRL = 0x01 << 27 //+ When encoding two pixels's worth of symbols in one cycle (a read of a PEEK/POP_DOUBLE register), the second encoder sees a shifted version of the colour data register. This control disables that shift, so that both encoder layers see the same pixel data. This is used for pixel doubling.
	CLEAR_BALANCE TMDS_CTRL = 0x01 << 28 //+ Clear the running DC balance state of the TMDS encoders. This bit should be written once at the beginning of each scanline.
)

const (
	L0_ROTn        = 0
	L1_ROTn        = 4
	L2_ROTn        = 8
	L0_NBITSn      = 12
	L1_NBITSn      = 15
	L2_NBITSn      = 18
	INTERLEAVEn    = 23
	PIX_SHIFTn     = 24
	PIX2_NOSHIFTn  = 27
	CLEAR_BALANCEn = 28
)
