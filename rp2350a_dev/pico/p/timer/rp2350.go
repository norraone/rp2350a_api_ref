// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package timer provides access to the registers of the TIMER peripheral.
//
// Instances:
//
//	TIMER0  TIMER0_BASE  -  TIMER0_0,TIMER0_1,TIMER0_2,TIMER0_3  Controls time and alarms time is a 64 bit value indicating the time since power-on timeh is the top 32 bits of time & timel is the bottom 32 bits to change time write to timelw before timehw to read time read from timelr before timehr An alarm is set by setting alarm_enable and writing to the corresponding alarm register When an alarm is pending, the corresponding alarm_running signal will be high An alarm can be cancelled before it has finished by clearing the alarm_enable When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared To clear the interrupt write a 1 to the corresponding alarm_irq The timer can be locked to prevent writing
//	TIMER1  TIMER1_BASE  -  TIMER1_0,TIMER1_1,TIMER1_2,TIMER1_3  Controls time and alarms time is a 64 bit value indicating the time since power-on timeh is the top 32 bits of time & timel is the bottom 32 bits to change time write to timelw before timehw to read time read from timelr before timehr An alarm is set by setting alarm_enable and writing to the corresponding alarm register When an alarm is pending, the corresponding alarm_running signal will be high An alarm can be cancelled before it has finished by clearing the alarm_enable When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared To clear the interrupt write a 1 to the corresponding alarm_irq The timer can be locked to prevent writing
//
// Registers:
//
//	0x000 32  TIMEHW    Write to bits 63:32 of time always write timelw before timehw
//	0x004 32  TIMELW    Write to bits 31:0 of time writes do not get copied to time until timehw is written
//	0x008 32  TIMEHR    Read from bits 63:32 of time always read timelr before timehr
//	0x00C 32  TIMELR    Read from bits 31:0 of time
//	0x010 32  ALARM0    Arm alarm 0, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM0 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
//	0x014 32  ALARM1    Arm alarm 1, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM1 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
//	0x018 32  ALARM2    Arm alarm 2, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM2 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
//	0x01C 32  ALARM3    Arm alarm 3, and configure the time it will fire. Once armed, the alarm fires when TIMER_ALARM3 == TIMELR. The alarm will disarm itself once it fires, and can be disarmed early using the ARMED status register.
//	0x020 32  ARMED     Indicates the armed/disarmed status of each alarm. A write to the corresponding ALARMx register arms the alarm. Alarms automatically disarm upon firing, but writing ones here will disarm immediately without waiting to fire.
//	0x024 32  TIMERAWH  Raw read from bits 63:32 of time (no side effects)
//	0x028 32  TIMERAWL  Raw read from bits 31:0 of time (no side effects)
//	0x02C 32  DBGPAUSE  Set bits high to enable pause when the corresponding debug ports are active
//	0x030 32  PAUSE     Set high to pause the timer
//	0x034 32  LOCKED    Set locked bit to disable write access to timer Once set, cannot be cleared (without a reset)
//	0x038 32  SOURCE    Selects the source for the timer. Defaults to the normal tick configured in the ticks block (typically configured to 1 microsecond). Writing to 1 will ignore the tick and count clk_sys cycles instead.
//	0x03C 32  INTR      Raw Interrupts
//	0x040 32  INTE      Interrupt Enable
//	0x044 32  INTF      Interrupt Force
//	0x048 32  INTS      Interrupt status after masking & forcing
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package timer

const (
	DBG0 DBGPAUSE = 0x01 << 1 //+ Pause when processor 0 is in debug mode
	DBG1 DBGPAUSE = 0x01 << 2 //+ Pause when processor 1 is in debug mode
)

const (
	DBG0n = 1
	DBG1n = 2
)

const (
	CLK_SYS SOURCE = 0x01 << 0 //+
	TICK    SOURCE = 0x00 << 0
	CLK_SYS SOURCE = 0x01 << 0
)

const (
	CLK_SYSn = 0
)

const (
	ALARM_0 INTR = 0x01 << 0 //+
	ALARM_1 INTR = 0x01 << 1 //+
	ALARM_2 INTR = 0x01 << 2 //+
	ALARM_3 INTR = 0x01 << 3 //+
)

const (
	ALARM_0n = 0
	ALARM_1n = 1
	ALARM_2n = 2
	ALARM_3n = 3
)

const (
	ALARM_0 INTE = 0x01 << 0 //+
	ALARM_1 INTE = 0x01 << 1 //+
	ALARM_2 INTE = 0x01 << 2 //+
	ALARM_3 INTE = 0x01 << 3 //+
)

const (
	ALARM_0n = 0
	ALARM_1n = 1
	ALARM_2n = 2
	ALARM_3n = 3
)

const (
	ALARM_0 INTF = 0x01 << 0 //+
	ALARM_1 INTF = 0x01 << 1 //+
	ALARM_2 INTF = 0x01 << 2 //+
	ALARM_3 INTF = 0x01 << 3 //+
)

const (
	ALARM_0n = 0
	ALARM_1n = 1
	ALARM_2n = 2
	ALARM_3n = 3
)

const (
	ALARM_0 INTS = 0x01 << 0 //+
	ALARM_1 INTS = 0x01 << 1 //+
	ALARM_2 INTS = 0x01 << 2 //+
	ALARM_3 INTS = 0x01 << 3 //+
)

const (
	ALARM_0n = 0
	ALARM_1n = 1
	ALARM_2n = 2
	ALARM_3n = 3
)
