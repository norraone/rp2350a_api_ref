// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package dma provides access to the registers of the DMA peripheral.
//
// Instances:
//
//	DMA0  DMA_BASE  -  DMA0_0,DMA0_1,DMA0_2,DMA0_3  DMA with separate read and write masters
//
// Registers:
//
//	0x000 32  CH{READ_ADDR,WRITE_ADDR,TRANS_COUNT,CTRL_TRIG(CTRL),AL1_CTRL(CTRL),AL1_READ_ADDR,AL1_WRITE_ADDR,AL1_TRANS_COUNT_TRIG(TRANS_COUNT),AL2_CTRL(CTRL),AL2_TRANS_COUNT(TRANS_COUNT),AL2_READ_ADDR,AL2_WRITE_ADDR_TRIG,AL3_CTRL(CTRL),AL3_WRITE_ADDR,AL3_TRANS_COUNT(TRANS_COUNT),AL3_READ_ADDR_TRIG}[16]  Channel status and control registers
//	0x400 32  INT{R,E,F,S}[4]                                                                                                                                                                                                                                                                                     Interrupt status and control registers
//	0x440 32  TIMER[4]                                                                                                                                                                                                                                                                                            Pacing (X/Y) fractional timer The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
//	0x450 32  MULTI_CHAN_TRIGGER                                                                                                                                                                                                                                                                                  Trigger one or more channels simultaneously
//	0x454 32  SNIFF_CTRL                                                                                                                                                                                                                                                                                          Sniffer Control
//	0x458 32  SNIFF_DATA                                                                                                                                                                                                                                                                                          Data accumulator for sniff hardware
//	0x460 32  FIFO_LEVELS                                                                                                                                                                                                                                                                                         Debug RAF, WAF, TDF levels
//	0x468 32  N_CHANNELS                                                                                                                                                                                                                                                                                          The number of channels this DMA instance is equipped with. This DMA supports up to 16 hardware channels, but can be configured with as few as one, to minimise silicon area.
//	0x480 32  SECCFG_CH[16]                                                                                                                                                                                                                                                                                       Security configuration for channel 0. Control whether this channel performs Secure/Non-secure and Privileged/Unprivileged bus accesses. If this channel generates bus accesses of some security level, an access of at least that level (in the order S+P > S+U > NS+P > NS+U) is required to program, trigger, abort, check the status of, interrupt on or acknowledge the interrupt of this channel. This register automatically locks down (becomes read-only) once software starts to configure the channel. This register is world-readable, but is writable only from a Secure, Privileged context.
//	0x4C0 32  SECCFG_IRQ[4]                                                                                                                                                                                                                                                                                       Security configuration for IRQ 0. Control whether the IRQ permits configuration by Non-secure/Unprivileged contexts, and whether it can observe Secure/Privileged channel interrupt flags.
//	0x4D0 32  SECCFG_MISC                                                                                                                                                                                                                                                                                         Miscellaneous security configuration
//	0x500 32  MPU_CTRL                                                                                                                                                                                                                                                                                            Control register for DMA MPU. Accessible only from a Privileged context.
//	0x504 32  MPU{BAR,LAR}[8]                                                                                                                                                                                                                                                                                     DMA Memory Protection Unit registers
//	0x800 32  CH_DBG{DBG_CTDREQ,DBG_TCR}[16]                                                                                                                                                                                                                                                                      Channel debug registers
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package dma

const (
	COUNT        TRANS_COUNT = 0xFFFFFFF << 0 //+ 28-bit transfer count (256 million transfers maximum). Program the number of bus transfers a channel will perform before halting. Note that, if transfers are larger than one byte in size, this is not equal to the number of bytes transferred (see CTRL_DATA_SIZE). When the channel is active, reading this register shows the number of transfers remaining, updating automatically each time a write transfer completes. Writing this register sets the RELOAD value for the transfer counter. Each time this channel is triggered, the RELOAD value is copied into the live transfer counter. The channel can be started multiple times, and will perform the same number of transfers each time, as programmed by most recent write. The RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the written value is used immediately as the length of the new transfer sequence, as well as being written to RELOAD.
	MODE         TRANS_COUNT = 0x0F << 28     //+ When MODE is 0x0, the transfer count decrements with each transfer until 0, and then the channel triggers the next channel indicated by CTRL_CHAIN_TO. When MODE is 0x1, the transfer count decrements with each transfer until 0, and then the channel re-triggers itself, in addition to the trigger indicated by CTRL_CHAIN_TO. This is useful for e.g. an endless ring-buffer DMA with periodic interrupts. When MODE is 0xf, the transfer count does not decrement. The DMA channel performs an endless sequence of transfers, never triggering other channels or raising interrupts, until an ABORT is raised. All other values are reserved.
	NORMAL       TRANS_COUNT = 0x00 << 28
	TRIGGER_SELF TRANS_COUNT = 0x01 << 28
	ENDLESS      TRANS_COUNT = 0x0F << 28
)

const (
	COUNTn = 0
	MODEn  = 28
)

const (
	EN             CTRL = 0x01 << 0 //+ DMA Channel Enable. When 1, the channel will respond to triggering events, which will cause it to become BUSY and start transferring data. When 0, the channel will ignore triggers, stop issuing transfers, and pause the current transfer sequence (i.e. BUSY will remain high if already high)
	HIGH_PRIORITY  CTRL = 0x01 << 1 //+ HIGH_PRIORITY gives a channel preferential treatment in issue scheduling: in each scheduling round, all high priority channels are considered first, and then only a single low priority channel, before returning to the high priority channels. This only affects the order in which the DMA schedules channels. The DMA's bus priority is not changed. If the DMA is not saturated then a low priority channel will see no loss of throughput.
	DATA_SIZE      CTRL = 0x03 << 2 //+ Set the size of each bus transfer (byte/halfword/word). READ_ADDR and WRITE_ADDR advance by this amount (1/2/4 bytes) with each transfer.
	SIZE_BYTE      CTRL = 0x00 << 2
	SIZE_HALFWORD  CTRL = 0x01 << 2
	SIZE_WORD      CTRL = 0x02 << 2
	INCR_READ      CTRL = 0x01 << 4 //+ If 1, the read address increments with each transfer. If 0, each read is directed to the same, initial address. Generally this should be disabled for peripheral-to-memory transfers.
	INCR_READ_REV  CTRL = 0x01 << 5 //+ If 1, and INCR_READ is 1, the read address is decremented rather than incremented with each transfer. If 1, and INCR_READ is 0, this otherwise-unused combination causes the read address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	INCR_WRITE     CTRL = 0x01 << 6 //+ If 1, the write address increments with each transfer. If 0, each write is directed to the same, initial address. Generally this should be disabled for memory-to-peripheral transfers.
	INCR_WRITE_REV CTRL = 0x01 << 7 //+ If 1, and INCR_WRITE is 1, the write address is decremented rather than incremented with each transfer. If 1, and INCR_WRITE is 0, this otherwise-unused combination causes the write address to be incremented by twice the transfer size, i.e. skipping over alternate addresses.
	RING_SIZE      CTRL = 0x0F << 8 //+ Size of address wrap region. If 0, don't wrap. For values n > 0, only the lower n bits of the address will change. This wraps the address on a (1 << n) byte boundary, facilitating access to naturally-aligned ring buffers. Ring sizes between 2 and 32768 bytes are possible. This can apply to either read or write addresses, based on value of RING_SEL.
	RING_NONE      CTRL = 0x00 << 8
	RING_SEL       CTRL = 0x01 << 12 //+ Select whether RING_SIZE applies to read or write addresses. If 0, read addresses are wrapped on a (1 << RING_SIZE) boundary. If 1, write addresses are wrapped.
	CHAIN_TO       CTRL = 0x0F << 13 //+ When this channel completes, it will trigger the channel indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this channel)_. Note this field resets to 0, so channels 1 and above will chain to channel 0 by default. Set this field to avoid this behaviour.
	TREQ_SEL       CTRL = 0x3F << 17 //+ Select a Transfer Request signal. The channel uses the transfer request signal to pace its data transfer rate. Sources for TREQ signals are internal (TIMERS) or external (DREQ, a Data Request from the system). 0x0 to 0x3a -> select DREQ n as TREQ
	PIO0_TX0       CTRL = 0x00 << 17 //  Select PIO0's TX FIFO 0 as TREQ
	PIO0_TX1       CTRL = 0x01 << 17 //  Select PIO0's TX FIFO 1 as TREQ
	PIO0_TX2       CTRL = 0x02 << 17 //  Select PIO0's TX FIFO 2 as TREQ
	PIO0_TX3       CTRL = 0x03 << 17 //  Select PIO0's TX FIFO 3 as TREQ
	PIO0_RX0       CTRL = 0x04 << 17 //  Select PIO0's RX FIFO 0 as TREQ
	PIO0_RX1       CTRL = 0x05 << 17 //  Select PIO0's RX FIFO 1 as TREQ
	PIO0_RX2       CTRL = 0x06 << 17 //  Select PIO0's RX FIFO 2 as TREQ
	PIO0_RX3       CTRL = 0x07 << 17 //  Select PIO0's RX FIFO 3 as TREQ
	PIO1_TX0       CTRL = 0x08 << 17 //  Select PIO1's TX FIFO 0 as TREQ
	PIO1_TX1       CTRL = 0x09 << 17 //  Select PIO1's TX FIFO 1 as TREQ
	PIO1_TX2       CTRL = 0x0A << 17 //  Select PIO1's TX FIFO 2 as TREQ
	PIO1_TX3       CTRL = 0x0B << 17 //  Select PIO1's TX FIFO 3 as TREQ
	PIO1_RX0       CTRL = 0x0C << 17 //  Select PIO1's RX FIFO 0 as TREQ
	PIO1_RX1       CTRL = 0x0D << 17 //  Select PIO1's RX FIFO 1 as TREQ
	PIO1_RX2       CTRL = 0x0E << 17 //  Select PIO1's RX FIFO 2 as TREQ
	PIO1_RX3       CTRL = 0x0F << 17 //  Select PIO1's RX FIFO 3 as TREQ
	PIO2_TX0       CTRL = 0x10 << 17 //  Select PIO2's TX FIFO 0 as TREQ
	PIO2_TX1       CTRL = 0x11 << 17 //  Select PIO2's TX FIFO 1 as TREQ
	PIO2_TX2       CTRL = 0x12 << 17 //  Select PIO2's TX FIFO 2 as TREQ
	PIO2_TX3       CTRL = 0x13 << 17 //  Select PIO2's TX FIFO 3 as TREQ
	PIO2_RX0       CTRL = 0x14 << 17 //  Select PIO2's RX FIFO 0 as TREQ
	PIO2_RX1       CTRL = 0x15 << 17 //  Select PIO2's RX FIFO 1 as TREQ
	PIO2_RX2       CTRL = 0x16 << 17 //  Select PIO2's RX FIFO 2 as TREQ
	PIO2_RX3       CTRL = 0x17 << 17 //  Select PIO2's RX FIFO 3 as TREQ
	SPI0_TX        CTRL = 0x18 << 17 //  Select SPI0's TX FIFO as TREQ
	SPI0_RX        CTRL = 0x19 << 17 //  Select SPI0's RX FIFO as TREQ
	SPI1_TX        CTRL = 0x1A << 17 //  Select SPI1's TX FIFO as TREQ
	SPI1_RX        CTRL = 0x1B << 17 //  Select SPI1's RX FIFO as TREQ
	UART0_TX       CTRL = 0x1C << 17 //  Select UART0's TX FIFO as TREQ
	UART0_RX       CTRL = 0x1D << 17 //  Select UART0's RX FIFO as TREQ
	UART1_TX       CTRL = 0x1E << 17 //  Select UART1's TX FIFO as TREQ
	UART1_RX       CTRL = 0x1F << 17 //  Select UART1's RX FIFO as TREQ
	PWM_WRAP0      CTRL = 0x20 << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP1      CTRL = 0x21 << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	PWM_WRAP2      CTRL = 0x22 << 17 //  Select PWM Counter 2's Wrap Value as TREQ
	PWM_WRAP3      CTRL = 0x23 << 17 //  Select PWM Counter 3's Wrap Value as TREQ
	PWM_WRAP4      CTRL = 0x24 << 17 //  Select PWM Counter 4's Wrap Value as TREQ
	PWM_WRAP5      CTRL = 0x25 << 17 //  Select PWM Counter 5's Wrap Value as TREQ
	PWM_WRAP6      CTRL = 0x26 << 17 //  Select PWM Counter 6's Wrap Value as TREQ
	PWM_WRAP7      CTRL = 0x27 << 17 //  Select PWM Counter 7's Wrap Value as TREQ
	PWM_WRAP8      CTRL = 0x28 << 17 //  Select PWM Counter 8's Wrap Value as TREQ
	PWM_WRAP9      CTRL = 0x29 << 17 //  Select PWM Counter 9's Wrap Value as TREQ
	PWM_WRAP10     CTRL = 0x2A << 17 //  Select PWM Counter 0's Wrap Value as TREQ
	PWM_WRAP11     CTRL = 0x2B << 17 //  Select PWM Counter 1's Wrap Value as TREQ
	I2C0_TX        CTRL = 0x2C << 17 //  Select I2C0's TX FIFO as TREQ
	I2C0_RX        CTRL = 0x2D << 17 //  Select I2C0's RX FIFO as TREQ
	I2C1_TX        CTRL = 0x2E << 17 //  Select I2C1's TX FIFO as TREQ
	I2C1_RX        CTRL = 0x2F << 17 //  Select I2C1's RX FIFO as TREQ
	ADC            CTRL = 0x30 << 17 //  Select the ADC as TREQ
	XIP_STREAM     CTRL = 0x31 << 17 //  Select the XIP Streaming FIFO as TREQ
	XIP_QMITX      CTRL = 0x32 << 17 //  Select XIP_QMITX as TREQ
	XIP_QMIRX      CTRL = 0x33 << 17 //  Select XIP_QMIRX as TREQ
	HSTX           CTRL = 0x34 << 17 //  Select HSTX as TREQ
	CORESIGHT      CTRL = 0x35 << 17 //  Select CORESIGHT as TREQ
	SHA256         CTRL = 0x36 << 17 //  Select SHA256 as TREQ
	TIMER0         CTRL = 0x3B << 17 //  Select Timer 0 as TREQ
	TIMER1         CTRL = 0x3C << 17 //  Select Timer 1 as TREQ
	TIMER2         CTRL = 0x3D << 17 //  Select Timer 2 as TREQ (Optional)
	TIMER3         CTRL = 0x3E << 17 //  Select Timer 3 as TREQ (Optional)
	PERMANENT      CTRL = 0x3F << 17 //  Permanent request, for unpaced transfers.
	IRQ_QUIET      CTRL = 0x01 << 23 //+ In QUIET mode, the channel does not generate IRQs at the end of every transfer block. Instead, an IRQ is raised when NULL is written to a trigger register, indicating the end of a control block chain. This reduces the number of interrupts to be serviced by the CPU when transferring a DMA chain of many small control blocks.
	BSWAP          CTRL = 0x01 << 24 //+ Apply byte-swap transformation to DMA data. For byte data, this has no effect. For halfword data, the two bytes of each halfword are swapped. For word data, the four bytes of each word are swapped to reverse order.
	SNIFF_EN       CTRL = 0x01 << 25 //+ If 1, this channel's data transfers are visible to the sniff hardware, and each transfer will advance the state of the checksum. This only applies if the sniff hardware is enabled, and has this channel selected. This allows checksum to be enabled or disabled on a per-control- block basis.
	BUSY           CTRL = 0x01 << 26 //+ This flag goes high when the channel starts a new transfer sequence, and low when the last transfer of that sequence completes. Clearing EN while BUSY is high pauses the channel, and BUSY will stay high while paused. To terminate a sequence early (and clear the BUSY flag), see CHAN_ABORT.
	WRITE_ERROR    CTRL = 0x01 << 29 //+ If 1, the channel received a write bus error. Write one to clear. WRITE_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 5 transfers later)
	READ_ERROR     CTRL = 0x01 << 30 //+ If 1, the channel received a read bus error. Write one to clear. READ_ADDR shows the approximate address where the bus error was encountered (will not be earlier, or more than 3 transfers later)
	AHB_ERROR      CTRL = 0x01 << 31 //+ Logical OR of the READ_ERROR and WRITE_ERROR flags. The channel halts when it encounters any bus error, and always raises its channel IRQ flag.
)

const (
	ENn             = 0
	HIGH_PRIORITYn  = 1
	DATA_SIZEn      = 2
	INCR_READn      = 4
	INCR_READ_REVn  = 5
	INCR_WRITEn     = 6
	INCR_WRITE_REVn = 7
	RING_SIZEn      = 8
	RING_SELn       = 12
	CHAIN_TOn       = 13
	TREQ_SELn       = 17
	IRQ_QUIETn      = 23
	BSWAPn          = 24
	SNIFF_ENn       = 25
	BUSYn           = 26
	WRITE_ERRORn    = 29
	READ_ERRORn     = 30
	AHB_ERRORn      = 31
)

const (
	Y TIMER = 0xFFFF << 0  //+ Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional timer.
	X TIMER = 0xFFFF << 16 //+ Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional timer.
)

const (
	Yn = 0
	Xn = 16
)

const (
	SEN     SNIFF_CTRL = 0x01 << 0  //+ Enable sniffer
	DMACH   SNIFF_CTRL = 0x0F << 1  //+ DMA channel for Sniffer to observe
	CALC    SNIFF_CTRL = 0x0F << 5  //+
	CRC32   SNIFF_CTRL = 0x00 << 5  //  Calculate a CRC-32 (IEEE802.3 polynomial)
	CRC32R  SNIFF_CTRL = 0x01 << 5  //  Calculate a CRC-32 (IEEE802.3 polynomial) with bit reversed data
	CRC16   SNIFF_CTRL = 0x02 << 5  //  Calculate a CRC-16-CCITT
	CRC16R  SNIFF_CTRL = 0x03 << 5  //  Calculate a CRC-16-CCITT with bit reversed data
	EVEN    SNIFF_CTRL = 0x0E << 5  //  XOR reduction over all data. == 1 if the total 1 population count is odd.
	SUM     SNIFF_CTRL = 0x0F << 5  //  Calculate a simple 32-bit checksum (addition with a 32 bit accumulator)
	SBSWAP  SNIFF_CTRL = 0x01 << 9  //+ Locally perform a byte reverse on the sniffed data, before feeding into checksum. Note that the sniff hardware is downstream of the DMA channel byteswap performed in the read master: if channel CTRL_BSWAP and SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the sniffer's point of view.
	OUT_REV SNIFF_CTRL = 0x01 << 10 //+ If set, the result appears bit-reversed when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
	OUT_INV SNIFF_CTRL = 0x01 << 11 //+ If set, the result appears inverted (bitwise complement) when read. This does not affect the way the checksum is calculated; the result is transformed on-the-fly between the result register and the bus.
)

const (
	SENn     = 0
	DMACHn   = 1
	CALCn    = 5
	SBSWAPn  = 9
	OUT_REVn = 10
	OUT_INVn = 11
)

const (
	TDF_LVL FIFO_LEVELS = 0xFF << 0  //+ Current Transfer-Data-FIFO fill level
	WAF_LVL FIFO_LEVELS = 0xFF << 8  //+ Current Write-Address-FIFO fill level
	RAF_LVL FIFO_LEVELS = 0xFF << 16 //+ Current Read-Address-FIFO fill level
)

const (
	TDF_LVLn = 0
	WAF_LVLn = 8
	RAF_LVLn = 16
)

const (
	PRI_CH SECCFG_CH = 0x01 << 0 //+ Privileged channel. If 1, this channel performs Privileged bus accesses. If 0, it performs Unprivileged bus accesses. If 1, this channel is controllable only from a Privileged context of the same Secure/Non-secure level, or any context of a higher Secure/Non-secure level.
	SEC_CH SECCFG_CH = 0x01 << 1 //+ Secure channel. If 1, this channel performs Secure bus accesses. If 0, it performs Non-secure bus accesses. If 1, this channel is controllable only from a Secure context.
	LOCK   SECCFG_CH = 0x01 << 2 //+ LOCK is 0 at reset, and is set to 1 automatically upon a successful write to this channel's control registers. That is, a write to CTRL, READ_ADDR, WRITE_ADDR, TRANS_COUNT and their aliases. Once its LOCK bit is set, this register becomes read-only. A failed write, for example due to the write's privilege being lower than that specified in the channel's SECCFG register, will not set the LOCK bit.
)

const (
	PRI_CHn = 0
	SEC_CHn = 1
	LOCKn   = 2
)

const (
	PRI_IRQ SECCFG_IRQ = 0x01 << 0 //+ Privileged IRQ. If 1, this IRQ's control registers can only be accessed from a Privileged context. If 0, this IRQ's control registers can be accessed from an Unprivileged context, but Privileged channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Privileged channels.
	SEC_IRQ SECCFG_IRQ = 0x01 << 1 //+ Secure IRQ. If 1, this IRQ's control registers can only be accessed from a Secure context. If 0, this IRQ's control registers can be accessed from a Non-secure context, but Secure channels (as per SECCFG_CHx) are masked from the IRQ status, and this IRQ's registers can not be used to acknowledge the channel interrupts of Secure channels.
)

const (
	PRI_IRQn = 0
	SEC_IRQn = 1
)

const (
	SNIFF_P  SECCFG_MISC = 0x01 << 0 //+ If 1, the sniffer can see data transfers from Privileged channels, and can itself only be accessed from a privileged context, or from a Secure context when SNIFF_S is 0. If 0, the sniffer can be accessed from either a Privileged or Unprivileged context (with sufficient security level) but can not see transfers from Privileged channels.
	SNIFF_S  SECCFG_MISC = 0x01 << 1 //+ If 1, the sniffer can see data transfers from Secure channels, and can itself only be accessed from a Secure context. If 0, the sniffer can be accessed from either a Secure or Non-secure context, but can not see data transfers of Secure channels.
	TIMER0_P SECCFG_MISC = 0x01 << 2 //+ If 1, the TIMER0 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 0 is only visible to Privileged (or more Secure) channels.
	TIMER0_S SECCFG_MISC = 0x01 << 3 //+ If 1, the TIMER0 register is only accessible from a Secure context, and timer DREQ 0 is only visible to Secure channels.
	TIMER1_P SECCFG_MISC = 0x01 << 4 //+ If 1, the TIMER1 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 1 is only visible to Privileged (or more Secure) channels.
	TIMER1_S SECCFG_MISC = 0x01 << 5 //+ If 1, the TIMER1 register is only accessible from a Secure context, and timer DREQ 1 is only visible to Secure channels.
	TIMER2_P SECCFG_MISC = 0x01 << 6 //+ If 1, the TIMER2 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 2 is only visible to Privileged (or more Secure) channels.
	TIMER2_S SECCFG_MISC = 0x01 << 7 //+ If 1, the TIMER2 register is only accessible from a Secure context, and timer DREQ 2 is only visible to Secure channels.
	TIMER3_P SECCFG_MISC = 0x01 << 8 //+ If 1, the TIMER3 register is only accessible from a Privileged (or more Secure) context, and timer DREQ 3 is only visible to Privileged (or more Secure) channels.
	TIMER3_S SECCFG_MISC = 0x01 << 9 //+ If 1, the TIMER3 register is only accessible from a Secure context, and timer DREQ 3 is only visible to Secure channels.
)

const (
	SNIFF_Pn  = 0
	SNIFF_Sn  = 1
	TIMER0_Pn = 2
	TIMER0_Sn = 3
	TIMER1_Pn = 4
	TIMER1_Sn = 5
	TIMER2_Pn = 6
	TIMER2_Sn = 7
	TIMER3_Pn = 8
	TIMER3_Sn = 9
)

const (
	DEF_PRI      MPU_CTRL = 0x01 << 1 //+ Determine whether an address not covered by an active MPU region is Privileged (1) or Unprivileged (0)
	DEF_SEC      MPU_CTRL = 0x01 << 2 //+ Determine whether an address not covered by an active MPU region is Secure (1) or Non-secure (0)
	NS_HIDE_ADDR MPU_CTRL = 0x01 << 3 //+ By default, when a region's S bit is clear, Non-secure-Privileged reads can see the region's base address and limit address. Set this bit to make the addresses appear as 0 to Non-secure reads, even when the region is Non-secure, to avoid leaking information about the processor SAU map.
)

const (
	DEF_PRIn      = 1
	DEF_SECn      = 2
	NS_HIDE_ADDRn = 3
)

const (
	REN  LAR = 0x01 << 0      //+ Region enable. If 1, any address within range specified by the base address (BAR_ADDR) and limit address (LAR_ADDR) has the attributes specified by S and P.
	RPRI LAR = 0x01 << 1      //+ Determines the Privileged/Unprivileged (=1/0) status of addresses matching this region, if this region is enabled. Writable from any Privileged context, if and only if the S bit is clear. Otherwise, writable only from a Secure, Privileged context.
	RSEC LAR = 0x01 << 2      //+ Determines the Secure/Non-secure (=1/0) status of addresses matching this region, if this region is enabled.
	ADDR LAR = 0x7FFFFFF << 5 //+ Limit address bits 31:5. Readable from any Privileged context, if and only if this region's S bit is clear, and MPU_CTRL_NS_HIDE_ADDR is clear. Otherwise readable only from a Secure, Privileged context.
)

const (
	RENn  = 0
	RPRIn = 1
	RSECn = 2
	ADDRn = 5
)
