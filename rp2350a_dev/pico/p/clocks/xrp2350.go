// Code generated by xgen -g; DO NOT EDIT.

//go:build rp2350

package clocks

import (
	"embedded/mmio"
	"structs"
	"unsafe"

	"github.com/embeddedgo/pico/p/mmap"
)

type Periph struct {
	_ structs.HostLayout

	CLK              [10]SCLK
	DFT_XOSC_CTRL    mmio.R32[DFT_OSC_CTRL]
	DFT_ROSC_CTRL    mmio.R32[DFT_OSC_CTRL]
	DFT_LPOSC_CTRL   mmio.R32[DFT_OSC_CTRL]
	SYS_RESUS_CTRL   mmio.R32[SYS_RESUS_CTRL]
	SYS_RESUS_STATUS mmio.R32[uint32]
	FC0_REF_KHZ      mmio.R32[uint32]
	FC0_MIN_KHZ      mmio.R32[uint32]
	FC0_MAX_KHZ      mmio.R32[uint32]
	FC0_DELAY        mmio.R32[uint32]
	FC0_INTERVAL     mmio.R32[uint32]
	FC0_SRC          mmio.R32[FC0_SRC]
	FC0_STATUS       mmio.R32[FC0_STATUS]
	FC0_RESULT       mmio.R32[uint32]
	WAKE_EN0         mmio.R32[CLK0_EN]
	WAKE_EN1         mmio.R32[CLK_EN1]
	SLEEP_EN0        mmio.R32[CLK0_EN]
	SLEEP_EN1        mmio.R32[CLK1_EN]
	ENABLED0         mmio.R32[CLK0_EN]
	ENABLED1         mmio.R32[CLK1_EN]
	INTR             mmio.R32[uint32]
	INTE             mmio.R32[uint32]
	INTF             mmio.R32[uint32]
	INTS             mmio.R32[uint32]
}

func CLOCKS() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.CLOCKS_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type SCLK struct {
	_ structs.HostLayout

	CTRL     mmio.R32[CTRL]
	DIV      mmio.R32[DIV]
	SELECTED mmio.R32[uint32]
}

type CTRL uint32

func GPOUT_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_AUXSRC}
}
func GPOUT_KILL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_KILL}
}
func GPOUT_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_ENABLE}
}
func GPOUT_DC50_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_DC50}
}
func GPOUT_PHASE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_PHASE}
}
func GPOUT_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_NUDGE}
}
func GPOUT_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: GPOUT_ENABLED}
}
func REF_SRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: REF_SRC}
}
func REF_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: REF_AUXSRC}
}
func SYS_SRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: SYS_SRC}
}
func SYS_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: SYS_AUXSRC}
}
func PERI_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: PERI_AUXSRC}
}
func PERI_KILL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: PERI_KILL}
}
func PERI_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: PERI_ENABLE}
}
func PERI_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: PERI_ENABLED}
}
func HSTX_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: HSTX_AUXSRC}
}
func HSTX_KILL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: HSTX_KILL}
}
func HSTX_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: HSTX_ENABLE}
}
func HSTX_PHASE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: HSTX_PHASE}
}
func HSTX_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: HSTX_NUDGE}
}
func HSTX_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: HSTX_ENABLED}
}
func USB_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: USB_AUXSRC}
}
func USB_KILL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: USB_KILL}
}
func USB_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: USB_ENABLE}
}
func USB_PHASE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: USB_PHASE}
}
func USB_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: USB_NUDGE}
}
func USB_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: USB_ENABLED}
}
func ADC_AUXSRC_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: ADC_AUXSRC}
}
func ADC_KILL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: ADC_KILL}
}
func ADC_ENABLE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: ADC_ENABLE}
}
func ADC_PHASE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: ADC_PHASE}
}
func ADC_NUDGE_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: ADC_NUDGE}
}
func ADC_ENABLED_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.CLK[i].CTRL, Mask: ADC_ENABLED}
}

type DIV uint32

func GPOUT_FRAC_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: GPOUT_FRAC}
}
func GPOUT_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: GPOUT_INT}
}
func REF_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: REF_INT}
}
func SYS_FRAC_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: SYS_FRAC}
}
func SYS_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: SYS_INT}
}
func PERI_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: PERI_INT}
}
func HSTX_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: HSTX_INT}
}
func USB_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: USB_INT}
}
func ADC_INT_(p *Periph, i int) mmio.RM32[DIV] {
	return mmio.RM32[DIV]{R: &p.CLK[i].DIV, Mask: ADC_INT}
}

type DFT_OSC_CTRL uint32

type SYS_RESUS_CTRL uint32

func TIMEOUT_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{R: &p.SYS_RESUS_CTRL, Mask: TIMEOUT}
}
func ENABLE_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{R: &p.SYS_RESUS_CTRL, Mask: ENABLE}
}
func FRCE_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{R: &p.SYS_RESUS_CTRL, Mask: FRCE}
}
func CLEAR_(p *Periph) mmio.RM32[SYS_RESUS_CTRL] {
	return mmio.RM32[SYS_RESUS_CTRL]{R: &p.SYS_RESUS_CTRL, Mask: CLEAR}
}

type FC0_SRC uint32

func FC0_SOURCE_(p *Periph) mmio.RM32[FC0_SRC] {
	return mmio.RM32[FC0_SRC]{R: &p.FC0_SRC, Mask: FC0_SOURCE}
}

type FC0_STATUS uint32

func PASS_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: PASS}
}
func DONE_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: DONE}
}
func RUNNING_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: RUNNING}
}
func WAITING_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: WAITING}
}
func FAIL_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: FAIL}
}
func SLOW_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: SLOW}
}
func FAST_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: FAST}
}
func DIED_(p *Periph) mmio.RM32[FC0_STATUS] {
	return mmio.RM32[FC0_STATUS]{R: &p.FC0_STATUS, Mask: DIED}
}

type CLK0_EN uint32

type CLK_EN1 uint32

type CLK1_EN uint32
