// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package clocks provides access to the registers of the CLOCKS peripheral.
//
// Instances:
//
//	CLOCKS  CLOCKS_BASE  -  CLOCKS
//
// Registers:
//
//	0x000 32  CLK{CTRL,DIV,SELECTED}[10]    Clock control, can be changed on-the-fly (except for auxsrc)
//	0x078 32  DFT_XOSC_CTRL(DFT_OSC_CTRL)
//	0x07C 32  DFT_ROSC_CTRL(DFT_OSC_CTRL)
//	0x080 32  DFT_LPOSC_CTRL(DFT_OSC_CTRL)
//	0x084 32  SYS_RESUS_CTRL
//	0x088 32  SYS_RESUS_STATUS
//	0x08C 32  FC0_REF_KHZ                   Reference clock frequency in kHz
//	0x090 32  FC0_MIN_KHZ                   Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using the pass/fail flags
//	0x094 32  FC0_MAX_KHZ                   Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are not using the pass/fail flags
//	0x098 32  FC0_DELAY                     Delays the start of frequency counting to allow the mux to settle Delay is measured in multiples of the reference clock period
//	0x09C 32  FC0_INTERVAL                  The test interval is 0.98us * 2**interval, but let's call it 1us * 2**interval The default gives a test interval of 250us
//	0x0A0 32  FC0_SRC                       Clock sent to frequency counter, set to 0 when not required Writing to this register initiates the frequency count
//	0x0A4 32  FC0_STATUS                    Frequency counter status
//	0x0A8 32  FC0_RESULT(uint32)            Result of frequency measurement, only valid when status_done=1
//	0x0AC 32  WAKE_EN0(CLK0_EN)             enable clock in wake mode
//	0x0B0 32  WAKE_EN1(CLK_EN1)             enable clock in wake mode
//	0x0B4 32  SLEEP_EN0(CLK0_EN)            enable clock in sleep mode
//	0x0B8 32  SLEEP_EN1(CLK1_EN)            enable clock in sleep mode
//	0x0BC 32  ENABLED0(CLK0_EN)             indicates the state of the clock enable
//	0x0C0 32  ENABLED1(CLK1_EN)             indicates the state of the clock enable
//	0x0C4 32  INTR                          Raw Interrupts
//	0x0C8 32  INTE                          Interrupt Enable
//	0x0CC 32  INTF                          Interrupt Force
//	0x0D0 32  INTS                          Interrupt status after masking & forcing
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package clocks

const (
	GPOUT0 int = 0x00 << 0 //+ Index to the GPOUT0 register in the CLK array
	GPOUT1 int = 0x01 << 0 //+ Index to the GPOUT1 register in the CLK array
	GPOUT2 int = 0x02 << 0 //+ Index to the GPOUT2 register in the CLK array
	GPOUT3 int = 0x03 << 0 //+ Index to the GPOUT3 register in the CLK array
	REF    int = 0x04 << 0 //+ Index to the REF register in the CLK array
	SYS    int = 0x05 << 0 //+ Index to the SYS register in the CLK array
	PERI   int = 0x06 << 0 //+ Index to the PERI register in the CLK array
	HSTX   int = 0x07 << 0 //+ Index to the HSTX register in the CLK array
	USB    int = 0x08 << 0 //+ Index to the USB register in the CLK array
	ADC    int = 0x09 << 0 //+ Index to the ADC register in the CLK array
)

const (
	GPOUT_AUXSRC                          CTRL = 0x0F << 5 //+ Selects the auxiliary clock source, will glitch when switching
	GPOUT_CLKSRC_PLL_SYS                  CTRL = 0x00 << 5
	GPOUT_CLKSRC_GPIN0                    CTRL = 0x01 << 5
	GPOUT_CLKSRC_GPIN1                    CTRL = 0x02 << 5
	GPOUT_CLKSRC_PLL_USB                  CTRL = 0x03 << 5
	GPOUT_CLKSRC_PLL_USB_PRIMARY_REF_OPCG CTRL = 0x04 << 5
	GPOUT_ROSC_CLKSRC                     CTRL = 0x05 << 5
	GPOUT_XOSC_CLKSRC                     CTRL = 0x06 << 5
	GPOUT_LPOSC_CLKSRC                    CTRL = 0x07 << 5
	GPOUT_CLK_SYS                         CTRL = 0x08 << 5
	GPOUT_CLK_USB                         CTRL = 0x09 << 5
	GPOUT_CLK_ADC                         CTRL = 0x0A << 5
	GPOUT_CLK_REF                         CTRL = 0x0B << 5
	GPOUT_CLK_PERI                        CTRL = 0x0C << 5
	GPOUT_CLK_HSTX                        CTRL = 0x0D << 5
	GPOUT_OTP_CLK2FC                      CTRL = 0x0E << 5
	GPOUT_KILL                            CTRL = 0x01 << 10 //+ Asynchronously kills the clock generator, enable must be set low before deasserting kill
	GPOUT_ENABLE                          CTRL = 0x01 << 11 //+ Starts and stops the clock generator cleanly
	GPOUT_DC50                            CTRL = 0x01 << 12 //+ Enables duty cycle correction for odd divisors, can be changed on-the-fly
	GPOUT_PHASE                           CTRL = 0x03 << 16 //+ This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	GPOUT_NUDGE                           CTRL = 0x01 << 20 //+ An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
	GPOUT_ENABLED                         CTRL = 0x01 << 28 //+ clock generator is enabled
	REF_SRC                               CTRL = 0x03 << 0  //+ Selects the clock source glitchlessly, can be changed on-the-fly
	REF_ROSC_CLKSRC_PH                    CTRL = 0x00 << 0
	REF_CLKSRC_CLK_REF_AUX                CTRL = 0x01 << 0
	REF_XOSC_CLKSRC                       CTRL = 0x02 << 0
	REF_LPOSC_CLKSRC                      CTRL = 0x03 << 0
	REF_AUXSRC                            CTRL = 0x03 << 5 //+ Selects the auxiliary clock source, will glitch when switching
	REF_CLKSRC_PLL_USB                    CTRL = 0x00 << 5
	REF_CLKSRC_GPIN0                      CTRL = 0x01 << 5
	REF_CLKSRC_GPIN1                      CTRL = 0x02 << 5
	REF_CLKSRC_PLL_USB_PRIMARY_REF_OPCG   CTRL = 0x03 << 5
	SYS_SRC                               CTRL = 0x01 << 0 //+ Selects the clock source glitchlessly, can be changed on-the-fly
	SYS_CLK_REF                           CTRL = 0x00 << 0
	SYS_CLKSRC_CLK_SYS_AUX                CTRL = 0x01 << 0
	SYS_AUXSRC                            CTRL = 0x07 << 5 //+ Selects the auxiliary clock source, will glitch when switching
	SYS_CLKSRC_PLL_SYS                    CTRL = 0x00 << 5
	SYS_CLKSRC_PLL_USB                    CTRL = 0x01 << 5
	SYS_ROSC_CLKSRC                       CTRL = 0x02 << 5
	SYS_XOSC_CLKSRC                       CTRL = 0x03 << 5
	SYS_CLKSRC_GPIN0                      CTRL = 0x04 << 5
	SYS_CLKSRC_GPIN1                      CTRL = 0x05 << 5
	PERI_AUXSRC                           CTRL = 0x07 << 5 //+ Selects the auxiliary clock source, will glitch when switching
	PERI_CLK_SYS                          CTRL = 0x00 << 5
	PERI_CLKSRC_PLL_SYS                   CTRL = 0x01 << 5
	PERI_CLKSRC_PLL_USB                   CTRL = 0x02 << 5
	PERI_ROSC_CLKSRC_PH                   CTRL = 0x03 << 5
	PERI_XOSC_CLKSRC                      CTRL = 0x04 << 5
	PERI_CLKSRC_GPIN0                     CTRL = 0x05 << 5
	PERI_CLKSRC_GPIN1                     CTRL = 0x06 << 5
	PERI_KILL                             CTRL = 0x01 << 10 //+ Asynchronously kills the clock generator, enable must be set low before deasserting kill
	PERI_ENABLE                           CTRL = 0x01 << 11 //+ Starts and stops the clock generator cleanly
	PERI_ENABLED                          CTRL = 0x01 << 28 //+ clock generator is enabled
	HSTX_AUXSRC                           CTRL = 0x07 << 5  //+ Selects the auxiliary clock source, will glitch when switching
	HSTX_CLK_SYS                          CTRL = 0x00 << 5
	HSTX_CLKSRC_PLL_SYS                   CTRL = 0x01 << 5
	HSTX_CLKSRC_PLL_USB                   CTRL = 0x02 << 5
	HSTX_CLKSRC_GPIN0                     CTRL = 0x03 << 5
	HSTX_CLKSRC_GPIN1                     CTRL = 0x04 << 5
	HSTX_KILL                             CTRL = 0x01 << 10 //+ Asynchronously kills the clock generator, enable must be set low before deasserting kill
	HSTX_ENABLE                           CTRL = 0x01 << 11 //+ Starts and stops the clock generator cleanly
	HSTX_PHASE                            CTRL = 0x03 << 16 //+ This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	HSTX_NUDGE                            CTRL = 0x01 << 20 //+ An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
	HSTX_ENABLED                          CTRL = 0x01 << 28 //+ clock generator is enabled
	USB_AUXSRC                            CTRL = 0x07 << 5  //+ Selects the auxiliary clock source, will glitch when switching
	USB_CLKSRC_PLL_USB                    CTRL = 0x00 << 5
	USB_CLKSRC_PLL_SYS                    CTRL = 0x01 << 5
	USB_ROSC_CLKSRC_PH                    CTRL = 0x02 << 5
	USB_XOSC_CLKSRC                       CTRL = 0x03 << 5
	USB_CLKSRC_GPIN0                      CTRL = 0x04 << 5
	USB_CLKSRC_GPIN1                      CTRL = 0x05 << 5
	USB_KILL                              CTRL = 0x01 << 10 //+ Asynchronously kills the clock generator, enable must be set low before deasserting kill
	USB_ENABLE                            CTRL = 0x01 << 11 //+ Starts and stops the clock generator cleanly
	USB_PHASE                             CTRL = 0x03 << 16 //+ This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	USB_NUDGE                             CTRL = 0x01 << 20 //+ An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
	USB_ENABLED                           CTRL = 0x01 << 28 //+ clock generator is enabled
	ADC_AUXSRC                            CTRL = 0x07 << 5  //+ Selects the auxiliary clock source, will glitch when switching
	ADC_CLKSRC_PLL_USB                    CTRL = 0x00 << 5
	ADC_CLKSRC_PLL_SYS                    CTRL = 0x01 << 5
	ADC_ROSC_CLKSRC_PH                    CTRL = 0x02 << 5
	ADC_XOSC_CLKSRC                       CTRL = 0x03 << 5
	ADC_CLKSRC_GPIN0                      CTRL = 0x04 << 5
	ADC_CLKSRC_GPIN1                      CTRL = 0x05 << 5
	ADC_KILL                              CTRL = 0x01 << 10 //+ Asynchronously kills the clock generator, enable must be set low before deasserting kill
	ADC_ENABLE                            CTRL = 0x01 << 11 //+ Starts and stops the clock generator cleanly
	ADC_PHASE                             CTRL = 0x03 << 16 //+ This delays the enable signal by up to 3 cycles of the input clock This must be set before the clock is enabled to have any effect
	ADC_NUDGE                             CTRL = 0x01 << 20 //+ An edge on this signal shifts the phase of the output by 1 cycle of the input clock This can be done at any time
	ADC_ENABLED                           CTRL = 0x01 << 28 //+ clock generator is enabled
)

const (
	GPOUT_AUXSRCn  = 5
	GPOUT_KILLn    = 10
	GPOUT_ENABLEn  = 11
	GPOUT_DC50n    = 12
	GPOUT_PHASEn   = 16
	GPOUT_NUDGEn   = 20
	GPOUT_ENABLEDn = 28
	REF_SRCn       = 0
	REF_AUXSRCn    = 5
	SYS_SRCn       = 0
	SYS_AUXSRCn    = 5
	PERI_AUXSRCn   = 5
	PERI_KILLn     = 10
	PERI_ENABLEn   = 11
	PERI_ENABLEDn  = 28
	HSTX_AUXSRCn   = 5
	HSTX_KILLn     = 10
	HSTX_ENABLEn   = 11
	HSTX_PHASEn    = 16
	HSTX_NUDGEn    = 20
	HSTX_ENABLEDn  = 28
	USB_AUXSRCn    = 5
	USB_KILLn      = 10
	USB_ENABLEn    = 11
	USB_PHASEn     = 16
	USB_NUDGEn     = 20
	USB_ENABLEDn   = 28
	ADC_AUXSRCn    = 5
	ADC_KILLn      = 10
	ADC_ENABLEn    = 11
	ADC_PHASEn     = 16
	ADC_NUDGEn     = 20
	ADC_ENABLEDn   = 28
)

const (
	GPOUT_FRAC DIV = 0xFFFF << 0  //+ Fractional component of the divisor, can be changed on-the-fly
	GPOUT_INT  DIV = 0xFFFF << 16 //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
	REF_INT    DIV = 0xFF << 16   //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
	SYS_FRAC   DIV = 0xFFFF << 0  //+ Fractional component of the divisor, can be changed on-the-fly
	SYS_INT    DIV = 0xFFFF << 16 //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
	PERI_INT   DIV = 0x03 << 16   //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
	HSTX_INT   DIV = 0x03 << 16   //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
	USB_INT    DIV = 0x0F << 16   //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
	ADC_INT    DIV = 0x0F << 16   //+ Integer part of clock divisor, 0 -> max+1, can be changed on-the-fly
)

const (
	GPOUT_FRACn = 0
	GPOUT_INTn  = 16
	REF_INTn    = 16
	SYS_FRACn   = 0
	SYS_INTn    = 16
	PERI_INTn   = 16
	HSTX_INTn   = 16
	USB_INTn    = 16
	ADC_INTn    = 16
)

const (
	CLKSRC             DFT_OSC_CTRL = 0x03 << 0 //+
	CLKSRC_NULL        DFT_OSC_CTRL = 0x00 << 0
	CLKSRC_PLL_PRIMARY DFT_OSC_CTRL = 0x01 << 0
	CLKSRC_GPIN        DFT_OSC_CTRL = 0x02 << 0
)

const (
	CLKSRCn = 0
)

const (
	TIMEOUT SYS_RESUS_CTRL = 0xFF << 0  //+ This is expressed as a number of clk_ref cycles and must be >= 2x clk_ref_freq/min_clk_tst_freq
	ENABLE  SYS_RESUS_CTRL = 0x01 << 8  //+ Enable resus
	FRCE    SYS_RESUS_CTRL = 0x01 << 12 //+ Force a resus, for test purposes only
	CLEAR   SYS_RESUS_CTRL = 0x01 << 16 //+ For clearing the resus after the fault that triggered it has been corrected
)

const (
	TIMEOUTn = 0
	ENABLEn  = 8
	FRCEn    = 12
	CLEARn   = 16
)

const (
	FC0_SOURCE                     FC0_SRC = 0xFF << 0 //+
	FC0_NULL                       FC0_SRC = 0x00 << 0
	FC0_PLL_SYS_CLKSRC_PRIMARY     FC0_SRC = 0x01 << 0
	FC0_PLL_USB_CLKSRC_PRIMARY     FC0_SRC = 0x02 << 0
	FC0_ROSC_CLKSRC                FC0_SRC = 0x03 << 0
	FC0_ROSC_CLKSRC_PH             FC0_SRC = 0x04 << 0
	FC0_XOSC_CLKSRC                FC0_SRC = 0x05 << 0
	FC0_CLKSRC_GPIN0               FC0_SRC = 0x06 << 0
	FC0_CLKSRC_GPIN1               FC0_SRC = 0x07 << 0
	FC0_CLK_REF                    FC0_SRC = 0x08 << 0
	FC0_CLK_SYS                    FC0_SRC = 0x09 << 0
	FC0_CLK_PERI                   FC0_SRC = 0x0A << 0
	FC0_CLK_USB                    FC0_SRC = 0x0B << 0
	FC0_CLK_ADC                    FC0_SRC = 0x0C << 0
	FC0_CLK_HSTX                   FC0_SRC = 0x0D << 0
	FC0_LPOSC_CLKSRC               FC0_SRC = 0x0E << 0
	FC0_OTP_CLK2FC                 FC0_SRC = 0x0F << 0
	FC0_PLL_USB_CLKSRC_PRIMARY_DFT FC0_SRC = 0x10 << 0
)

const (
	FC0_SOURCEn = 0
)

const (
	PASS    FC0_STATUS = 0x01 << 0  //+ Test passed
	DONE    FC0_STATUS = 0x01 << 4  //+ Test complete
	RUNNING FC0_STATUS = 0x01 << 8  //+ Test running
	WAITING FC0_STATUS = 0x01 << 12 //+ Waiting for test clock to start
	FAIL    FC0_STATUS = 0x01 << 16 //+ Test failed
	SLOW    FC0_STATUS = 0x01 << 20 //+ Test clock slower than expected, only valid when status_done=1
	FAST    FC0_STATUS = 0x01 << 24 //+ Test clock faster than expected, only valid when status_done=1
	DIED    FC0_STATUS = 0x01 << 28 //+ Test clock stopped during test
)

const (
	PASSn    = 0
	DONEn    = 4
	RUNNINGn = 8
	WAITINGn = 12
	FAILn    = 16
	SLOWn    = 20
	FASTn    = 24
	DIEDn    = 28
)

const (
	FC0_RESULT_FRAC uint32 = 0x1F << 0      //+
	FC0_RESULT_KHZ  uint32 = 0x1FFFFFF << 5 //+
)

const (
	FC0_RESULT_FRACn = 0
	FC0_RESULT_KHZn  = 5
)

const (
	SYS_CLOCKS_EN          CLK0_EN = 0x01 << 0  //+
	SYS_ACCESSCTRL_EN      CLK0_EN = 0x01 << 1  //+
	ADC_EN                 CLK0_EN = 0x01 << 2  //+
	SYS_ADC_EN             CLK0_EN = 0x01 << 3  //+
	SYS_BOOTRAM_EN         CLK0_EN = 0x01 << 4  //+
	SYS_BUSCTRL_EN         CLK0_EN = 0x01 << 5  //+
	SYS_BUSFABRIC_EN       CLK0_EN = 0x01 << 6  //+
	SYS_DMA_EN             CLK0_EN = 0x01 << 7  //+
	SYS_GLITCH_DETECTOR_EN CLK0_EN = 0x01 << 8  //+
	HSTX_EN                CLK0_EN = 0x01 << 9  //+
	SYS_HSTX_EN            CLK0_EN = 0x01 << 10 //+
	SYS_I2C0_EN            CLK0_EN = 0x01 << 11 //+
	SYS_I2C1_EN            CLK0_EN = 0x01 << 12 //+
	SYS_IO_EN              CLK0_EN = 0x01 << 13 //+
	SYS_JTAG_EN            CLK0_EN = 0x01 << 14 //+
	REF_OTP_EN             CLK0_EN = 0x01 << 15 //+
	SYS_OTP_EN             CLK0_EN = 0x01 << 16 //+
	SYS_PADS_EN            CLK0_EN = 0x01 << 17 //+
	SYS_PIO0_EN            CLK0_EN = 0x01 << 18 //+
	SYS_PIO1_EN            CLK0_EN = 0x01 << 19 //+
	SYS_PIO2_EN            CLK0_EN = 0x01 << 20 //+
	SYS_PLL_SYS_EN         CLK0_EN = 0x01 << 21 //+
	SYS_PLL_USB_EN         CLK0_EN = 0x01 << 22 //+
	REF_POWMAN_EN          CLK0_EN = 0x01 << 23 //+
	SYS_POWMAN_EN          CLK0_EN = 0x01 << 24 //+
	SYS_PWM_EN             CLK0_EN = 0x01 << 25 //+
	SYS_RESETS_EN          CLK0_EN = 0x01 << 26 //+
	SYS_ROM_EN             CLK0_EN = 0x01 << 27 //+
	SYS_ROSC_EN            CLK0_EN = 0x01 << 28 //+
	SYS_PSM_EN             CLK0_EN = 0x01 << 29 //+
	SYS_SHA256_EN          CLK0_EN = 0x01 << 30 //+
	SYS_SIO_EN             CLK0_EN = 0x01 << 31 //+
)

const (
	SYS_CLOCKS_ENn          = 0
	SYS_ACCESSCTRL_ENn      = 1
	ADC_ENn                 = 2
	SYS_ADC_ENn             = 3
	SYS_BOOTRAM_ENn         = 4
	SYS_BUSCTRL_ENn         = 5
	SYS_BUSFABRIC_ENn       = 6
	SYS_DMA_ENn             = 7
	SYS_GLITCH_DETECTOR_ENn = 8
	HSTX_ENn                = 9
	SYS_HSTX_ENn            = 10
	SYS_I2C0_ENn            = 11
	SYS_I2C1_ENn            = 12
	SYS_IO_ENn              = 13
	SYS_JTAG_ENn            = 14
	REF_OTP_ENn             = 15
	SYS_OTP_ENn             = 16
	SYS_PADS_ENn            = 17
	SYS_PIO0_ENn            = 18
	SYS_PIO1_ENn            = 19
	SYS_PIO2_ENn            = 20
	SYS_PLL_SYS_ENn         = 21
	SYS_PLL_USB_ENn         = 22
	REF_POWMAN_ENn          = 23
	SYS_POWMAN_ENn          = 24
	SYS_PWM_ENn             = 25
	SYS_RESETS_ENn          = 26
	SYS_ROM_ENn             = 27
	SYS_ROSC_ENn            = 28
	SYS_PSM_ENn             = 29
	SYS_SHA256_ENn          = 30
	SYS_SIO_ENn             = 31
)

const (
	PERI_SPI0_EN    CLK_EN1 = 0x01 << 0  //+
	SYS_SPI0_EN     CLK_EN1 = 0x01 << 1  //+
	PERI_SPI1_EN    CLK_EN1 = 0x01 << 2  //+
	SYS_SPI1_EN     CLK_EN1 = 0x01 << 3  //+
	SYS_SRAM0_EN    CLK_EN1 = 0x01 << 4  //+
	SYS_SRAM1_EN    CLK_EN1 = 0x01 << 5  //+
	SYS_SRAM2_EN    CLK_EN1 = 0x01 << 6  //+
	SYS_SRAM3_EN    CLK_EN1 = 0x01 << 7  //+
	SYS_SRAM4_EN    CLK_EN1 = 0x01 << 8  //+
	SYS_SRAM5_EN    CLK_EN1 = 0x01 << 9  //+
	SYS_SRAM6_EN    CLK_EN1 = 0x01 << 10 //+
	SYS_SRAM7_EN    CLK_EN1 = 0x01 << 11 //+
	SYS_SRAM8_EN    CLK_EN1 = 0x01 << 12 //+
	SYS_SRAM9_EN    CLK_EN1 = 0x01 << 13 //+
	SYS_SYSCFG_EN   CLK_EN1 = 0x01 << 14 //+
	SYS_SYSINFO_EN  CLK_EN1 = 0x01 << 15 //+
	SYS_TBMAN_EN    CLK_EN1 = 0x01 << 16 //+
	REF_TICKS_EN    CLK_EN1 = 0x01 << 17 //+
	SYS_TICKS_EN    CLK_EN1 = 0x01 << 18 //+
	SYS_TIMER0_EN   CLK_EN1 = 0x01 << 19 //+
	SYS_TIMER1_EN   CLK_EN1 = 0x01 << 20 //+
	SYS_TRNG_EN     CLK_EN1 = 0x01 << 21 //+
	PERI_UART0_EN   CLK_EN1 = 0x01 << 22 //+
	SYS_UART0_EN    CLK_EN1 = 0x01 << 23 //+
	PERI_UART1_EN   CLK_EN1 = 0x01 << 24 //+
	SYS_UART1_EN    CLK_EN1 = 0x01 << 25 //+
	SYS_USBCTRL_EN  CLK_EN1 = 0x01 << 26 //+
	USB_EN          CLK_EN1 = 0x01 << 27 //+
	SYS_WATCHDOG_EN CLK_EN1 = 0x01 << 28 //+
	SYS_XIP_EN      CLK_EN1 = 0x01 << 29 //+
	SYS_XOSC_EN     CLK_EN1 = 0x01 << 30 //+
)

const (
	PERI_SPI0_ENn    = 0
	SYS_SPI0_ENn     = 1
	PERI_SPI1_ENn    = 2
	SYS_SPI1_ENn     = 3
	SYS_SRAM0_ENn    = 4
	SYS_SRAM1_ENn    = 5
	SYS_SRAM2_ENn    = 6
	SYS_SRAM3_ENn    = 7
	SYS_SRAM4_ENn    = 8
	SYS_SRAM5_ENn    = 9
	SYS_SRAM6_ENn    = 10
	SYS_SRAM7_ENn    = 11
	SYS_SRAM8_ENn    = 12
	SYS_SRAM9_ENn    = 13
	SYS_SYSCFG_ENn   = 14
	SYS_SYSINFO_ENn  = 15
	SYS_TBMAN_ENn    = 16
	REF_TICKS_ENn    = 17
	SYS_TICKS_ENn    = 18
	SYS_TIMER0_ENn   = 19
	SYS_TIMER1_ENn   = 20
	SYS_TRNG_ENn     = 21
	PERI_UART0_ENn   = 22
	SYS_UART0_ENn    = 23
	PERI_UART1_ENn   = 24
	SYS_UART1_ENn    = 25
	SYS_USBCTRL_ENn  = 26
	USB_ENn          = 27
	SYS_WATCHDOG_ENn = 28
	SYS_XIP_ENn      = 29
	SYS_XOSC_ENn     = 30
)
