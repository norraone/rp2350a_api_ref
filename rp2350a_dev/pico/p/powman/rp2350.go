// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package powman provides access to the registers of the POWMAN peripheral.
//
// Instances:
//
//	POWMAN  POWMAN_BASE  -  POWMAN_POW,POWMAN_TIMER  Controls vreg, bor, lposc, chip resets & xosc startup, powman and provides scratch register for general use and for bootcode use
//
// Registers:
//
//	0x000 32  BADPASSWD            Indicates a bad password has been used
//	0x004 32  VREG_CTRL            Voltage Regulator Control
//	0x008 32  VREG_STS             Voltage Regulator Status
//	0x00C 32  VREG                 Voltage Regulator Settings
//	0x010 32  VREG_LP_ENTRY        Voltage Regulator Low Power Entry Settings
//	0x014 32  VREG_LP_EXIT         Voltage Regulator Low Power Exit Settings
//	0x018 32  BOD_CTRL             Brown-out Detection Control
//	0x01C 32  BOD                  Brown-out Detection Settings
//	0x020 32  BOD_LP_ENTRY         Brown-out Detection Low Power Entry Settings
//	0x024 32  BOD_LP_EXIT          Brown-out Detection Low Power Exit Settings
//	0x028 32  LPOSC                Low power oscillator control register.
//	0x02C 32  CHIP_RESET           Chip reset control and status
//	0x030 32  WDSEL                Allows a watchdog reset to reset the internal state of powman in addition to the power-on state machine (PSM). Note that powman ignores watchdog resets that do not select at least the CLOCKS stage or earlier stages in the PSM. If using these bits, it's recommended to set PSM_WDSEL to all-ones in addition to the desired bits in this register. Failing to select CLOCKS or earlier will result in the POWMAN_WDSEL register having no effect.
//	0x034 32  SEQ_CFG              For configuration of the power sequencer Writes are ignored while POWMAN_STATE_CHANGING=1
//	0x038 32  STATE                This register controls the power state of the 4 power domains. The current power state is indicated in POWMAN_STATE_CURRENT which is read-only. To change the state, write to POWMAN_STATE_REQ. The coding of POWMAN_STATE_CURRENT & POWMAN_STATE_REQ corresponds to the power states defined in the datasheet: bit 3 = SWCORE bit 2 = XIP cache bit 1 = SRAM0 bit 0 = SRAM1 0 = powered up 1 = powered down When POWMAN_STATE_REQ is written, the POWMAN_STATE_WAITING flag is set while the Power Manager determines what is required. If an invalid transition is requested the Power Manager will still register the request in POWMAN_STATE_REQ but will also set the POWMAN_BAD_REQ flag. It will then implement the power-up requests and ignore the power down requests. To do nothing would risk entering an unrecoverable lock-up state. Invalid requests are: any combination of power up and power down requests any request that results in swcore boing powered and xip unpowered If the request is to power down the switched-core domain then POWMAN_STATE_WAITING stays active until the processors halt. During this time the POWMAN_STATE_REQ field can be re-written to change or cancel the request. When the power state transition begins the POWMAN_STATE_WAITING_flag is cleared, the POWMAN_STATE_CHANGING flag is set and POWMAN register writes are ignored until the transition completes.
//	0x03C 32  POW_FASTDIV
//	0x040 32  POW_DELAY            power state machine delays
//	0x044 32  EXT_CTRL0            Configures a gpio as a power mode aware control output
//	0x048 32  EXT_CTRL1            Configures a gpio as a power mode aware control output
//	0x04C 32  EXT_TIME_REF         Select a GPIO to use as a time reference, the source can be used to drive the low power clock at 32kHz, or to provide a 1ms tick to the timer, or provide a 1Hz tick to the timer. The tick selection is controlled by the POWMAN_TIMER register.
//	0x050 32  LPOSC_FREQ_KHZ_INT   Informs the AON Timer of the integer component of the clock frequency when running off the LPOSC.
//	0x054 32  LPOSC_FREQ_KHZ_FRAC  Informs the AON Timer of the fractional component of the clock frequency when running off the LPOSC.
//	0x058 32  XOSC_FREQ_KHZ_INT    Informs the AON Timer of the integer component of the clock frequency when running off the XOSC.
//	0x05C 32  XOSC_FREQ_KHZ_FRAC   Informs the AON Timer of the fractional component of the clock frequency when running off the XOSC.
//	0x060 32  SET_TIME_63TO48
//	0x064 32  SET_TIME_47TO32
//	0x068 32  SET_TIME_31TO16
//	0x06C 32  SET_TIME_15TO0
//	0x070 32  READ_TIME_UPPER
//	0x074 32  READ_TIME_LOWER
//	0x078 32  ALARM_TIME_63TO48
//	0x07C 32  ALARM_TIME_47TO32
//	0x080 32  ALARM_TIME_31TO16
//	0x084 32  ALARM_TIME_15TO0
//	0x088 32  TIMER
//	0x08C 32  PWRUP0               4 GPIO powerup events can be configured to wake the chip up from a low power state. The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event The number of gpios available depends on the package option. An invalid selection will be ignored source = 0 selects gpio0 . . source = 47 selects gpio47 source = 48 selects qspi_ss source = 49 selects qspi_sd0 source = 50 selects qspi_sd1 source = 51 selects qspi_sd2 source = 52 selects qspi_sd3 source = 53 selects qspi_sclk level = 0 triggers the pwrup when the source is low level = 1 triggers the pwrup when the source is high
//	0x090 32  PWRUP1               4 GPIO powerup events can be configured to wake the chip up from a low power state. The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event The number of gpios available depends on the package option. An invalid selection will be ignored source = 0 selects gpio0 . . source = 47 selects gpio47 source = 48 selects qspi_ss source = 49 selects qspi_sd0 source = 50 selects qspi_sd1 source = 51 selects qspi_sd2 source = 52 selects qspi_sd3 source = 53 selects qspi_sclk level = 0 triggers the pwrup when the source is low level = 1 triggers the pwrup when the source is high
//	0x094 32  PWRUP2               4 GPIO powerup events can be configured to wake the chip up from a low power state. The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event The number of gpios available depends on the package option. An invalid selection will be ignored source = 0 selects gpio0 . . source = 47 selects gpio47 source = 48 selects qspi_ss source = 49 selects qspi_sd0 source = 50 selects qspi_sd1 source = 51 selects qspi_sd2 source = 52 selects qspi_sd3 source = 53 selects qspi_sclk level = 0 triggers the pwrup when the source is low level = 1 triggers the pwrup when the source is high
//	0x098 32  PWRUP3               4 GPIO powerup events can be configured to wake the chip up from a low power state. The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event The number of gpios available depends on the package option. An invalid selection will be ignored source = 0 selects gpio0 . . source = 47 selects gpio47 source = 48 selects qspi_ss source = 49 selects qspi_sd0 source = 50 selects qspi_sd1 source = 51 selects qspi_sd2 source = 52 selects qspi_sd3 source = 53 selects qspi_sclk level = 0 triggers the pwrup when the source is low level = 1 triggers the pwrup when the source is high
//	0x09C 32  CURRENT_PWRUP_REQ    Indicates current powerup request state pwrup events can be cleared by removing the enable from the pwrup register. The alarm pwrup req can be cleared by clearing timer.alarm_enab 0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET 1 = pwrup0 2 = pwrup1 3 = pwrup2 4 = pwrup3 5 = coresight_pwrup 6 = alarm_pwrup
//	0x0A0 32  LAST_SWCORE_PWRUP    Indicates which pwrup source triggered the last switched-core power up 0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET 1 = pwrup0 2 = pwrup1 3 = pwrup2 4 = pwrup3 5 = coresight_pwrup 6 = alarm_pwrup
//	0x0A4 32  DBG_PWRCFG
//	0x0A8 32  BOOTDIS              Tell the bootrom to ignore the BOOT0..3 registers following the next RSM reset (e.g. the next core power down/up). If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk that Secure code running at a later stage can unlock the pages by powering the core up and down. This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at a later stage from accessing OTP in its unlocked state. Should be used in conjunction with the OTP BOOTDIS register.
//	0x0AC 32  DBGCONFIG
//	0x0B0 32  SCRATCH0             Scratch register. Information persists in low power mode
//	0x0B4 32  SCRATCH1             Scratch register. Information persists in low power mode
//	0x0B8 32  SCRATCH2             Scratch register. Information persists in low power mode
//	0x0BC 32  SCRATCH3             Scratch register. Information persists in low power mode
//	0x0C0 32  SCRATCH4             Scratch register. Information persists in low power mode
//	0x0C4 32  SCRATCH5             Scratch register. Information persists in low power mode
//	0x0C8 32  SCRATCH6             Scratch register. Information persists in low power mode
//	0x0CC 32  SCRATCH7             Scratch register. Information persists in low power mode
//	0x0D0 32  BOOT0                Scratch register. Information persists in low power mode
//	0x0D4 32  BOOT1                Scratch register. Information persists in low power mode
//	0x0D8 32  BOOT2                Scratch register. Information persists in low power mode
//	0x0DC 32  BOOT3                Scratch register. Information persists in low power mode
//	0x0E0 32  INTR                 Raw Interrupts
//	0x0E4 32  INTE                 Interrupt Enable
//	0x0E8 32  INTF                 Interrupt Force
//	0x0EC 32  INTS                 Interrupt status after masking & forcing
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package powman

const (
	HT_TH                 VREG_CTRL = 0x07 << 4  //+ high temperature protection threshold regulator power transistors are disabled when junction temperature exceeds threshold 000 - 100C 001 - 105C 010 - 110C 011 - 115C 100 - 120C 101 - 125C 110 - 135C 111 - 150C
	DISABLE_VOLTAGE_LIMIT VREG_CTRL = 0x01 << 8  //+ 0=not disabled, 1=enabled
	ISOLATE               VREG_CTRL = 0x01 << 12 //+ isolates the VREG control interface 0 - not isolated (default) 1 - isolated
	UNLOCK                VREG_CTRL = 0x01 << 13 //+ unlocks the VREG control interface after power up 0 - Locked (default) 1 - Unlocked It cannot be relocked when it is unlocked.
	RST_N                 VREG_CTRL = 0x01 << 15 //+ returns the regulator to its startup settings 0 - reset 1 - not reset (default)
)

const (
	HT_THn                 = 4
	DISABLE_VOLTAGE_LIMITn = 8
	ISOLATEn               = 12
	UNLOCKn                = 13
	RST_Nn                 = 15
)

const (
	STARTUP VREG_STS = 0x01 << 0 //+ startup status 0=startup complete, 1=starting up
	VOUT_OK VREG_STS = 0x01 << 4 //+ output regulation status 0=not in regulation, 1=in regulation
)

const (
	STARTUPn = 0
	VOUT_OKn = 4
)

const (
	HIZ                VREG = 0x01 << 1  //+ high impedance mode select 0=not in high impedance mode, 1=in high impedance mode
	VSEL               VREG = 0x1F << 4  //+ output voltage select the regulator output voltage is limited to 1.3V unless the voltage limit is disabled using the disable_voltage_limit field in the vreg_ctrl register 00000 - 0.55V 00001 - 0.60V 00010 - 0.65V 00011 - 0.70V 00100 - 0.75V 00101 - 0.80V 00110 - 0.85V 00111 - 0.90V 01000 - 0.95V 01001 - 1.00V 01010 - 1.05V 01011 - 1.10V (default) 01100 - 1.15V 01101 - 1.20V 01110 - 1.25V 01111 - 1.30V 10000 - 1.35V 10001 - 1.40V 10010 - 1.50V 10011 - 1.60V 10100 - 1.65V 10101 - 1.70V 10110 - 1.80V 10111 - 1.90V 11000 - 2.00V 11001 - 2.35V 11010 - 2.50V 11011 - 2.65V 11100 - 2.80V 11101 - 3.00V 11110 - 3.15V 11111 - 3.30V
	UPDATE_IN_PROGRESS VREG = 0x01 << 15 //+ regulator state is being updated writes to the vreg register will be ignored when this field is set
)

const (
	HIZn                = 1
	VSELn               = 4
	UPDATE_IN_PROGRESSn = 15
)

const (
	HIZ  VREG_LP_ENTRY = 0x01 << 1 //+ high impedance mode select 0=not in high impedance mode, 1=in high impedance mode
	MODE VREG_LP_ENTRY = 0x01 << 2 //+ selects either normal (switching) mode or low power (linear) mode low power mode can only be selected for output voltages up to 1.3V 0 = normal mode (switching) 1 = low power mode (linear)
	VSEL VREG_LP_ENTRY = 0x1F << 4 //+ output voltage select the regulator output voltage is limited to 1.3V unless the voltage limit is disabled using the disable_voltage_limit field in the vreg_ctrl register 00000 - 0.55V 00001 - 0.60V 00010 - 0.65V 00011 - 0.70V 00100 - 0.75V 00101 - 0.80V 00110 - 0.85V 00111 - 0.90V 01000 - 0.95V 01001 - 1.00V 01010 - 1.05V 01011 - 1.10V (default) 01100 - 1.15V 01101 - 1.20V 01110 - 1.25V 01111 - 1.30V 10000 - 1.35V 10001 - 1.40V 10010 - 1.50V 10011 - 1.60V 10100 - 1.65V 10101 - 1.70V 10110 - 1.80V 10111 - 1.90V 11000 - 2.00V 11001 - 2.35V 11010 - 2.50V 11011 - 2.65V 11100 - 2.80V 11101 - 3.00V 11110 - 3.15V 11111 - 3.30V
)

const (
	HIZn  = 1
	MODEn = 2
	VSELn = 4
)

const (
	HIZ  VREG_LP_EXIT = 0x01 << 1 //+ high impedance mode select 0=not in high impedance mode, 1=in high impedance mode
	MODE VREG_LP_EXIT = 0x01 << 2 //+ selects either normal (switching) mode or low power (linear) mode low power mode can only be selected for output voltages up to 1.3V 0 = normal mode (switching) 1 = low power mode (linear)
	VSEL VREG_LP_EXIT = 0x1F << 4 //+ output voltage select the regulator output voltage is limited to 1.3V unless the voltage limit is disabled using the disable_voltage_limit field in the vreg_ctrl register 00000 - 0.55V 00001 - 0.60V 00010 - 0.65V 00011 - 0.70V 00100 - 0.75V 00101 - 0.80V 00110 - 0.85V 00111 - 0.90V 01000 - 0.95V 01001 - 1.00V 01010 - 1.05V 01011 - 1.10V (default) 01100 - 1.15V 01101 - 1.20V 01110 - 1.25V 01111 - 1.30V 10000 - 1.35V 10001 - 1.40V 10010 - 1.50V 10011 - 1.60V 10100 - 1.65V 10101 - 1.70V 10110 - 1.80V 10111 - 1.90V 11000 - 2.00V 11001 - 2.35V 11010 - 2.50V 11011 - 2.65V 11100 - 2.80V 11101 - 3.00V 11110 - 3.15V 11111 - 3.30V
)

const (
	HIZn  = 1
	MODEn = 2
	VSELn = 4
)

const (
	ISOLATE BOD_CTRL = 0x01 << 12 //+ isolates the brown-out detection control interface 0 - not isolated (default) 1 - isolated
)

const (
	ISOLATEn = 12
)

const (
	EN   BOD = 0x01 << 0 //+ enable brown-out detection 0=not enabled, 1=enabled
	VSEL BOD = 0x1F << 4 //+ threshold select 00000 - 0.473V 00001 - 0.516V 00010 - 0.559V 00011 - 0.602V 00100 - 0.645VS 00101 - 0.688V 00110 - 0.731V 00111 - 0.774V 01000 - 0.817V 01001 - 0.860V (default) 01010 - 0.903V 01011 - 0.946V 01100 - 0.989V 01101 - 1.032V 01110 - 1.075V 01111 - 1.118V 10000 - 1.161 10001 - 1.204V
)

const (
	ENn   = 0
	VSELn = 4
)

const (
	EN   BOD_LP_ENTRY = 0x01 << 0 //+ enable brown-out detection 0=not enabled, 1=enabled
	VSEL BOD_LP_ENTRY = 0x1F << 4 //+ threshold select 00000 - 0.473V 00001 - 0.516V 00010 - 0.559V 00011 - 0.602V 00100 - 0.645VS 00101 - 0.688V 00110 - 0.731V 00111 - 0.774V 01000 - 0.817V 01001 - 0.860V (default) 01010 - 0.903V 01011 - 0.946V 01100 - 0.989V 01101 - 1.032V 01110 - 1.075V 01111 - 1.118V 10000 - 1.161 10001 - 1.204V
)

const (
	ENn   = 0
	VSELn = 4
)

const (
	EN   BOD_LP_EXIT = 0x01 << 0 //+ enable brown-out detection 0=not enabled, 1=enabled
	VSEL BOD_LP_EXIT = 0x1F << 4 //+ threshold select 00000 - 0.473V 00001 - 0.516V 00010 - 0.559V 00011 - 0.602V 00100 - 0.645VS 00101 - 0.688V 00110 - 0.731V 00111 - 0.774V 01000 - 0.817V 01001 - 0.860V (default) 01010 - 0.903V 01011 - 0.946V 01100 - 0.989V 01101 - 1.032V 01110 - 1.075V 01111 - 1.118V 10000 - 1.161 10001 - 1.204V
)

const (
	ENn   = 0
	VSELn = 4
)

const (
	MODE LPOSC = 0x03 << 0 //+ This feature has been removed
	TRIM LPOSC = 0x3F << 4 //+ Frequency trim - the trim step is typically 1% of the reset frequency, but can be up to 3%
)

const (
	MODEn = 0
	TRIMn = 4
)

const (
	DOUBLE_TAP                      CHIP_RESET = 0x01 << 0  //+ This flag is set by double-tapping RUN. It tells bootcode to go into the bootloader.
	RESCUE_FLAG                     CHIP_RESET = 0x01 << 4  //+ This is set by a rescue reset from the RP-AP. Its purpose is to halt before the bootrom before booting from flash in order to recover from a boot lock-up. The debugger can then attach once the bootrom has been halted and flash some working code that does not lock up.
	HAD_POR                         CHIP_RESET = 0x01 << 16 //+ Last reset was from the power-on reset This resets: double_tap flag yes DP yes RPAP yes rescue_flag yes timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_BOR                         CHIP_RESET = 0x01 << 17 //+ Last reset was from the brown-out detection block This resets: double_tap flag yes DP yes RPAP yes rescue_flag yes timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_RUN_LOW                     CHIP_RESET = 0x01 << 18 //+ Last reset was from the RUN pin This resets: double_tap flag no DP yes RPAP yes rescue_flag yes timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_DP_RESET_REQ                CHIP_RESET = 0x01 << 19 //+ Last reset was an reset request from the arm debugger This resets: double_tap flag no DP no RPAP no rescue_flag yes timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_RESCUE                      CHIP_RESET = 0x01 << 21 //+ Last reset was a rescue reset from the debugger This resets: double_tap flag no DP no RPAP no rescue_flag no, it sets this flag timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_WATCHDOG_RESET_POWMAN_ASYNC CHIP_RESET = 0x01 << 22 //+ Last reset was a watchdog timeout which was configured to reset the power manager asynchronously This resets: double_tap flag no DP no RPAP no rescue_flag no timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_WATCHDOG_RESET_POWMAN       CHIP_RESET = 0x01 << 23 //+ Last reset was a watchdog timeout which was configured to reset the power manager This resets: double_tap flag no DP no RPAP no rescue_flag no timer yes powman yes swcore yes psm yes then starts the power sequencer
	HAD_WATCHDOG_RESET_SWCORE       CHIP_RESET = 0x01 << 24 //+ Last reset was a watchdog timeout which was configured to reset the switched-core This resets: double_tap flag no DP no RPAP no rescue_flag no timer no powman no swcore yes psm yes then starts the power sequencer
	HAD_SWCORE_PD                   CHIP_RESET = 0x01 << 25 //+ Last reset was a switched core powerdown This resets: double_tap flag no DP no RPAP no rescue_flag no timer no powman no swcore yes psm yes then starts the power sequencer
	HAD_GLITCH_DETECT               CHIP_RESET = 0x01 << 26 //+ Last reset was due to a power supply glitch This resets: double_tap flag no DP no RPAP no rescue_flag no timer no powman no swcore no psm yes and does not change the power state
	HAD_HZD_SYS_RESET_REQ           CHIP_RESET = 0x01 << 27 //+ Last reset was a system reset from the hazard debugger This resets: double_tap flag no DP no RPAP no rescue_flag no timer no powman no swcore no psm yes and does not change the power state
	HAD_WATCHDOG_RESET_RSM          CHIP_RESET = 0x01 << 28 //+ Last reset was a watchdog timeout which was configured to reset the power-on state machine This resets: double_tap flag no DP no RPAP no rescue_flag no timer no powman no swcore no psm yes and does not change the power state
)

const (
	DOUBLE_TAPn                      = 0
	RESCUE_FLAGn                     = 4
	HAD_PORn                         = 16
	HAD_BORn                         = 17
	HAD_RUN_LOWn                     = 18
	HAD_DP_RESET_REQn                = 19
	HAD_RESCUEn                      = 21
	HAD_WATCHDOG_RESET_POWMAN_ASYNCn = 22
	HAD_WATCHDOG_RESET_POWMANn       = 23
	HAD_WATCHDOG_RESET_SWCOREn       = 24
	HAD_SWCORE_PDn                   = 25
	HAD_GLITCH_DETECTn               = 26
	HAD_HZD_SYS_RESET_REQn           = 27
	HAD_WATCHDOG_RESET_RSMn          = 28
)

const (
	RESET_POWMAN_ASYNC WDSEL = 0x01 << 0  //+ If set to 1, a watchdog reset will restore powman defaults, reset the timer, reset the switched core domain and run the full power-on state machine (PSM) sequence This does not rely on clk_ref running
	RESET_POWMAN       WDSEL = 0x01 << 4  //+ If set to 1, a watchdog reset will restore powman defaults, reset the timer, reset the switched core power domain and run the full power-on state machine (PSM) sequence This relies on clk_ref running. Use reset_powman_async if that may not be true
	RESET_SWCORE       WDSEL = 0x01 << 8  //+ If set to 1, a watchdog reset will reset the switched core power domain and run the full power-on state machine (PSM) sequence From a user perspective it is the same as setting RSM_WDSEL_PROC_COLD From a hardware debug perspective it has the same effect as a power-on reset for the switched core power domain
	RESET_RSM          WDSEL = 0x01 << 12 //+ If set to 1, a watchdog reset will run the full power-on state machine (PSM) sequence From a user perspective it is the same as setting RSM_WDSEL_PROC_COLD From a hardware debug perspective it has the same effect as a reset from a glitch detector
)

const (
	RESET_POWMAN_ASYNCn = 0
	RESET_POWMANn       = 4
	RESET_SWCOREn       = 8
	RESET_RSMn          = 12
)

const (
	HW_PWRUP_SRAM1   SEQ_CFG = 0x01 << 0  //+ Specifies the power state of SRAM1 when powering up swcore from a low power state (P1.xxx) to a high power state (P0.0xx). 0=power-up 1=no change
	HW_PWRUP_SRAM0   SEQ_CFG = 0x01 << 1  //+ Specifies the power state of SRAM0 when powering up swcore from a low power state (P1.xxx) to a high power state (P0.0xx). 0=power-up 1=no change
	USE_VREG_LP      SEQ_CFG = 0x01 << 4  //+ Set to 0 to prevent automatic switching to vreg low power mode when switched-core is powered down This setting takes effect when the swcore is next powered down
	USE_VREG_HP      SEQ_CFG = 0x01 << 5  //+ Set to 0 to prevent automatic switching to vreg high power mode when switched-core is powered up This setting takes effect when the swcore is next powered up
	USE_BOD_LP       SEQ_CFG = 0x01 << 6  //+ Set to 0 to prevent automatic switching to bod low power mode when switched-core is powered down This setting takes effect when the swcore is next powered down
	USE_BOD_HP       SEQ_CFG = 0x01 << 7  //+ Set to 0 to prevent automatic switching to bod high power mode when switched-core is powered up This setting takes effect when the swcore is next powered up
	RUN_LPOSC_IN_LP  SEQ_CFG = 0x01 << 8  //+ Set to 0 to stop the low power osc when the switched-core is powered down, which is unwise if using it to clock the timer This setting takes effect when the swcore is next powered down
	USE_FAST_POWCK   SEQ_CFG = 0x01 << 12 //+ selects the reference clock (clk_ref) as the source of the POWMAN clock when switched-core is powered. The POWMAN clock always switches to the slow clock (lposc) when switched-core is powered down because the fast clock stops running. 0 always run the POWMAN clock from the slow clock (lposc) 1 run the POWMAN clock from the fast clock when available This setting takes effect when a power up sequence is next run
	USING_VREG_LP    SEQ_CFG = 0x01 << 16 //+ Indicates the voltage regulator (VREG) mode 0 = VREG high power mode which is the default 1 = VREG low power mode
	USING_BOD_LP     SEQ_CFG = 0x01 << 17 //+ Indicates the brown-out detector (BOD) mode 0 = BOD high power mode which is the default 1 = BOD low power mode
	USING_FAST_POWCK SEQ_CFG = 0x01 << 20 //+ 0 indicates the POWMAN clock is running from the low power oscillator (32kHz) 1 indicates the POWMAN clock is running from the reference clock (2-50MHz)
)

const (
	HW_PWRUP_SRAM1n   = 0
	HW_PWRUP_SRAM0n   = 1
	USE_VREG_LPn      = 4
	USE_VREG_HPn      = 5
	USE_BOD_LPn       = 6
	USE_BOD_HPn       = 7
	RUN_LPOSC_IN_LPn  = 8
	USE_FAST_POWCKn   = 12
	USING_VREG_LPn    = 16
	USING_BOD_LPn     = 17
	USING_FAST_POWCKn = 20
)

const (
	CURRENT             STATE = 0x0F << 0  //+
	REQ                 STATE = 0x0F << 4  //+
	REQ_IGNORED         STATE = 0x01 << 8  //+
	PWRUP_WHILE_WAITING STATE = 0x01 << 9  //+ Request ignored because of a pending pwrup request. See current_pwrup_req. Note this blocks powering up AND powering down.
	BAD_SW_REQ          STATE = 0x01 << 10 //+ Bad software initiated state request. No action taken.
	BAD_HW_REQ          STATE = 0x01 << 11 //+ Bad hardware initiated state request. Went back to state 0 (i.e. everything powered up)
	WAITING             STATE = 0x01 << 12 //+
	CHANGING            STATE = 0x01 << 13 //+
)

const (
	CURRENTn             = 0
	REQn                 = 4
	REQ_IGNOREDn         = 8
	PWRUP_WHILE_WAITINGn = 9
	BAD_SW_REQn          = 10
	BAD_HW_REQn          = 11
	WAITINGn             = 12
	CHANGINGn            = 13
)

const (
	SWCORE_STEP POW_DELAY = 0x0F << 0 //+ timing between the swcore power state machine steps measured in units of the lposc period, 0 gives a delay of 1 unit
	XIP_STEP    POW_DELAY = 0x0F << 4 //+ timing between the xip power state machine steps measured in units of the lposc period, 0 gives a delay of 1 unit
	SRAM_STEP   POW_DELAY = 0xFF << 8 //+ timing between the sram0 and sram1 power state machine steps measured in units of the powman tick period (>=1us), 0 gives a delay of 1 unit
)

const (
	SWCORE_STEPn = 0
	XIP_STEPn    = 4
	SRAM_STEPn   = 8
)

const (
	GPIO_SELECT    EXT_CTRL0 = 0x3F << 0  //+ selects from gpio 0->30 set to 31 to disable this feature
	INIT           EXT_CTRL0 = 0x01 << 8  //+
	INIT_STATE     EXT_CTRL0 = 0x01 << 12 //+
	LP_ENTRY_STATE EXT_CTRL0 = 0x01 << 13 //+ output level when entering the low power state
	LP_EXIT_STATE  EXT_CTRL0 = 0x01 << 14 //+ output level when exiting the low power state
)

const (
	GPIO_SELECTn    = 0
	INITn           = 8
	INIT_STATEn     = 12
	LP_ENTRY_STATEn = 13
	LP_EXIT_STATEn  = 14
)

const (
	GPIO_SELECT    EXT_CTRL1 = 0x3F << 0  //+ selects from gpio 0->30 set to 31 to disable this feature
	INIT           EXT_CTRL1 = 0x01 << 8  //+
	INIT_STATE     EXT_CTRL1 = 0x01 << 12 //+
	LP_ENTRY_STATE EXT_CTRL1 = 0x01 << 13 //+ output level when entering the low power state
	LP_EXIT_STATE  EXT_CTRL1 = 0x01 << 14 //+ output level when exiting the low power state
)

const (
	GPIO_SELECTn    = 0
	INITn           = 8
	INIT_STATEn     = 12
	LP_ENTRY_STATEn = 13
	LP_EXIT_STATEn  = 14
)

const (
	SOURCE_SEL EXT_TIME_REF = 0x03 << 0 //+ 0 -> gpio12 1 -> gpio20 2 -> gpio14 3 -> gpio22
	DRIVE_LPCK EXT_TIME_REF = 0x01 << 4 //+ Use the selected GPIO to drive the 32kHz low power clock, in place of LPOSC. This field must only be written when POWMAN_TIMER_RUN=0
)

const (
	SOURCE_SELn = 0
	DRIVE_LPCKn = 4
)

const (
	NONSEC_WRITE    TIMER = 0x01 << 0  //+ Control whether Non-secure software can write to the timer registers. All other registers are hardwired to be inaccessible to Non-secure.
	RUN             TIMER = 0x01 << 1  //+ Timer enable. Setting this bit causes the timer to begin counting up from its current value. Clearing this bit stops the timer from counting. Before enabling the timer, set the POWMAN_LPOSC_FREQ* and POWMAN_XOSC_FREQ* registers to configure the count rate, and initialise the current time by writing to SET_TIME_63TO48 through SET_TIME_15TO0. You must not write to the SET_TIME_x registers when the timer is running. Once configured, start the timer by setting POWMAN_TIMER_RUN=1. This will start the timer running from the LPOSC. When the XOSC is available switch the reference clock to XOSC then select it as the timer clock by setting POWMAN_TIMER_USE_XOSC=1
	CLEAR           TIMER = 0x01 << 2  //+ Clears the timer, does not disable the timer and does not affect the alarm. This control can be written at any time.
	ALARM_ENAB      TIMER = 0x01 << 4  //+ Enables the alarm. The alarm must be disabled while writing the alarm time.
	PWRUP_ON_ALARM  TIMER = 0x01 << 5  //+ Alarm wakes the chip from low power mode
	ALARM           TIMER = 0x01 << 6  //+ Alarm has fired. Write to 1 to clear the alarm.
	USE_LPOSC       TIMER = 0x01 << 8  //+ Switch to lposc as the source of the 1kHz timer tick
	USE_XOSC        TIMER = 0x01 << 9  //+ switch to xosc as the source of the 1kHz timer tick
	USE_GPIO_1KHZ   TIMER = 0x01 << 10 //+ switch to gpio as the source of the 1kHz timer tick
	USE_GPIO_1HZ    TIMER = 0x01 << 13 //+ Selects the gpio source as the reference for the sec counter. The msec counter will continue to use the lposc or xosc reference.
	USING_XOSC      TIMER = 0x01 << 16 //+ Timer is running from xosc
	USING_LPOSC     TIMER = 0x01 << 17 //+ Timer is running from lposc
	USING_GPIO_1KHZ TIMER = 0x01 << 18 //+ Timer is running from a 1khz gpio source
	USING_GPIO_1HZ  TIMER = 0x01 << 19 //+ Timer is synchronised to a 1hz gpio source
)

const (
	NONSEC_WRITEn    = 0
	RUNn             = 1
	CLEARn           = 2
	ALARM_ENABn      = 4
	PWRUP_ON_ALARMn  = 5
	ALARMn           = 6
	USE_LPOSCn       = 8
	USE_XOSCn        = 9
	USE_GPIO_1KHZn   = 10
	USE_GPIO_1HZn    = 13
	USING_XOSCn      = 16
	USING_LPOSCn     = 17
	USING_GPIO_1KHZn = 18
	USING_GPIO_1HZn  = 19
)

const (
	SOURCE      PWRUP0 = 0x3F << 0 //+
	ENABLE      PWRUP0 = 0x01 << 6 //+ Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event. If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.
	DIRECTION   PWRUP0 = 0x01 << 7 //+
	LOW_FALLING PWRUP0 = 0x00 << 7
	HIGH_RISING PWRUP0 = 0x01 << 7
	MODE        PWRUP0 = 0x01 << 8 //+ Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
	LEVEL       PWRUP0 = 0x00 << 8
	EDGE        PWRUP0 = 0x01 << 8
	STATUS      PWRUP0 = 0x01 << 9  //+ Status of gpio wakeup. Write to 1 to clear a latched edge detect.
	RAW_STATUS  PWRUP0 = 0x01 << 10 //+ Value of selected gpio pin (only if enable == 1)
)

const (
	SOURCEn     = 0
	ENABLEn     = 6
	DIRECTIONn  = 7
	MODEn       = 8
	STATUSn     = 9
	RAW_STATUSn = 10
)

const (
	SOURCE      PWRUP1 = 0x3F << 0 //+
	ENABLE      PWRUP1 = 0x01 << 6 //+ Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event. If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.
	DIRECTION   PWRUP1 = 0x01 << 7 //+
	LOW_FALLING PWRUP1 = 0x00 << 7
	HIGH_RISING PWRUP1 = 0x01 << 7
	MODE        PWRUP1 = 0x01 << 8 //+ Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
	LEVEL       PWRUP1 = 0x00 << 8
	EDGE        PWRUP1 = 0x01 << 8
	STATUS      PWRUP1 = 0x01 << 9  //+ Status of gpio wakeup. Write to 1 to clear a latched edge detect.
	RAW_STATUS  PWRUP1 = 0x01 << 10 //+ Value of selected gpio pin (only if enable == 1)
)

const (
	SOURCEn     = 0
	ENABLEn     = 6
	DIRECTIONn  = 7
	MODEn       = 8
	STATUSn     = 9
	RAW_STATUSn = 10
)

const (
	SOURCE      PWRUP2 = 0x3F << 0 //+
	ENABLE      PWRUP2 = 0x01 << 6 //+ Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event. If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.
	DIRECTION   PWRUP2 = 0x01 << 7 //+
	LOW_FALLING PWRUP2 = 0x00 << 7
	HIGH_RISING PWRUP2 = 0x01 << 7
	MODE        PWRUP2 = 0x01 << 8 //+ Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
	LEVEL       PWRUP2 = 0x00 << 8
	EDGE        PWRUP2 = 0x01 << 8
	STATUS      PWRUP2 = 0x01 << 9  //+ Status of gpio wakeup. Write to 1 to clear a latched edge detect.
	RAW_STATUS  PWRUP2 = 0x01 << 10 //+ Value of selected gpio pin (only if enable == 1)
)

const (
	SOURCEn     = 0
	ENABLEn     = 6
	DIRECTIONn  = 7
	MODEn       = 8
	STATUSn     = 9
	RAW_STATUSn = 10
)

const (
	SOURCE      PWRUP3 = 0x3F << 0 //+
	ENABLE      PWRUP3 = 0x01 << 6 //+ Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup source and clear a pending wakeup event. If using edge detect a latched edge needs to be cleared by writing 1 to the status register also.
	DIRECTION   PWRUP3 = 0x01 << 7 //+
	LOW_FALLING PWRUP3 = 0x00 << 7
	HIGH_RISING PWRUP3 = 0x01 << 7
	MODE        PWRUP3 = 0x01 << 8 //+ Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0 transition). Level will detect a 1 or 0. Both types of event get latched into the current_pwrup_req register.
	LEVEL       PWRUP3 = 0x00 << 8
	EDGE        PWRUP3 = 0x01 << 8
	STATUS      PWRUP3 = 0x01 << 9  //+ Status of gpio wakeup. Write to 1 to clear a latched edge detect.
	RAW_STATUS  PWRUP3 = 0x01 << 10 //+ Value of selected gpio pin (only if enable == 1)
)

const (
	SOURCEn     = 0
	ENABLEn     = 6
	DIRECTIONn  = 7
	MODEn       = 8
	STATUSn     = 9
	RAW_STATUSn = 10
)

const (
	NOW  BOOTDIS = 0x01 << 0 //+ When powman resets the RSM, the current value of BOOTDIS_NEXT is OR'd into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared. The bootrom checks this flag before reading the BOOT0..3 registers. If it is set, the bootrom clears it, and ignores the BOOT registers. This prevents Secure software from diverting the boot path before a bootloader has had the chance to soft lock OTP pages containing sensitive data.
	NEXT BOOTDIS = 0x01 << 1 //+ This flag always ORs writes into its current contents. It can be set but not cleared by software. The BOOTDIS_NEXT bit is OR'd into the BOOTDIS_NOW bit when the core is powered down. Simultaneously, the BOOTDIS_NEXT bit is cleared. Setting this bit means that the BOOT0..3 registers will be ignored following the next reset of the RSM by powman. This flag should be set by an early boot stage that has soft-locked OTP pages, to prevent later stages from unlocking it by power cycling.
)

const (
	NOWn  = 0
	NEXTn = 1
)

const (
	VREG_OUTPUT_LOW     INTR = 0x01 << 0 //+
	TIMER               INTR = 0x01 << 1 //+
	STATE_REQ_IGNORED   INTR = 0x01 << 2 //+ Source is state.req_ignored
	PWRUP_WHILE_WAITING INTR = 0x01 << 3 //+ Source is state.pwrup_while_waiting
)

const (
	VREG_OUTPUT_LOWn     = 0
	TIMERn               = 1
	STATE_REQ_IGNOREDn   = 2
	PWRUP_WHILE_WAITINGn = 3
)

const (
	VREG_OUTPUT_LOW     INTE = 0x01 << 0 //+
	TIMER               INTE = 0x01 << 1 //+
	STATE_REQ_IGNORED   INTE = 0x01 << 2 //+ Source is state.req_ignored
	PWRUP_WHILE_WAITING INTE = 0x01 << 3 //+ Source is state.pwrup_while_waiting
)

const (
	VREG_OUTPUT_LOWn     = 0
	TIMERn               = 1
	STATE_REQ_IGNOREDn   = 2
	PWRUP_WHILE_WAITINGn = 3
)

const (
	VREG_OUTPUT_LOW     INTF = 0x01 << 0 //+
	TIMER               INTF = 0x01 << 1 //+
	STATE_REQ_IGNORED   INTF = 0x01 << 2 //+ Source is state.req_ignored
	PWRUP_WHILE_WAITING INTF = 0x01 << 3 //+ Source is state.pwrup_while_waiting
)

const (
	VREG_OUTPUT_LOWn     = 0
	TIMERn               = 1
	STATE_REQ_IGNOREDn   = 2
	PWRUP_WHILE_WAITINGn = 3
)

const (
	VREG_OUTPUT_LOW     INTS = 0x01 << 0 //+
	TIMER               INTS = 0x01 << 1 //+
	STATE_REQ_IGNORED   INTS = 0x01 << 2 //+ Source is state.req_ignored
	PWRUP_WHILE_WAITING INTS = 0x01 << 3 //+ Source is state.pwrup_while_waiting
)

const (
	VREG_OUTPUT_LOWn     = 0
	TIMERn               = 1
	STATE_REQ_IGNOREDn   = 2
	PWRUP_WHILE_WAITINGn = 3
)
