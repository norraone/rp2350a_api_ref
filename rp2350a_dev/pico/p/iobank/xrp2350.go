// Code generated by xgen -g; DO NOT EDIT.

//go:build rp2350

package iobank

import (
	"embedded/mmio"
	"structs"
	"unsafe"

	"github.com/embeddedgo/pico/p/mmap"
)

type Periph struct {
	_ structs.HostLayout

	GPIO                              [48]SGPIO
	_                                 [32]uint32
	IRQSUMMARY_PROC0_SECURE           [2]mmio.R32[uint32]
	IRQSUMMARY_PROC0_NONSECURE        [2]mmio.R32[uint32]
	IRQSUMMARY_PROC1_SECURE           [2]mmio.R32[uint32]
	IRQSUMMARY_PROC1_NONSECURE        [2]mmio.R32[uint32]
	IRQSUMMARY_DORMANT_WAKE_SECURE    [2]mmio.R32[uint32]
	IRQSUMMARY_DORMANT_WAKE_NONSECURE [2]mmio.R32[uint32]
	INTR                              [6]mmio.R32[uint32]
	PROC0_INTE                        [6]mmio.R32[uint32]
	PROC0_INTF                        [6]mmio.R32[uint32]
	PROC0_INTS                        [6]mmio.R32[uint32]
	PROC1_INTE                        [6]mmio.R32[uint32]
	PROC1_INTF                        [6]mmio.R32[uint32]
	PROC1_INTS                        [6]mmio.R32[uint32]
	DORMANT_WAKE_INTE                 [6]mmio.R32[uint32]
	DORMANT_WAKE_INTF                 [6]mmio.R32[uint32]
	DORMANT_WAKE_INTS                 [6]mmio.R32[uint32]
}

func IO_BANK0() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.IO_BANK0_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type SGPIO struct {
	_ structs.HostLayout

	STATUS mmio.R32[STATUS]
	CTRL   mmio.R32[CTRL]
}

type STATUS uint32

func OUTTOPAD_(p *Periph, i int) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.GPIO[i].STATUS, Mask: OUTTOPAD}
}
func OETOPAD_(p *Periph, i int) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.GPIO[i].STATUS, Mask: OETOPAD}
}
func INFROMPAD_(p *Periph, i int) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.GPIO[i].STATUS, Mask: INFROMPAD}
}
func IRQTOPROC_(p *Periph, i int) mmio.RM32[STATUS] {
	return mmio.RM32[STATUS]{R: &p.GPIO[i].STATUS, Mask: IRQTOPROC}
}

type CTRL uint32

func FUNCSEL_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.GPIO[i].CTRL, Mask: FUNCSEL}
}
func OUTOVER_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.GPIO[i].CTRL, Mask: OUTOVER}
}
func OEOVER_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.GPIO[i].CTRL, Mask: OEOVER}
}
func INOVER_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.GPIO[i].CTRL, Mask: INOVER}
}
func IRQOVER_(p *Periph, i int) mmio.RM32[CTRL] {
	return mmio.RM32[CTRL]{R: &p.GPIO[i].CTRL, Mask: IRQOVER}
}
