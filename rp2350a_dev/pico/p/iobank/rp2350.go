// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package iobank provides access to the registers of the IO_BANK peripheral.
//
// Instances:
//
//	IO_BANK0  IO_BANK0_BASE  -  IO_BANK0,IO_BANK0_NS
//
// Registers:
//
//	0x000 32  GPIO{STATUS,CTRL}[48]
//	0x200 32  IRQSUMMARY_PROC0_SECURE[2]
//	0x208 32  IRQSUMMARY_PROC0_NONSECURE[2]
//	0x210 32  IRQSUMMARY_PROC1_SECURE[2]
//	0x218 32  IRQSUMMARY_PROC1_NONSECURE[2]
//	0x220 32  IRQSUMMARY_DORMANT_WAKE_SECURE[2]
//	0x228 32  IRQSUMMARY_DORMANT_WAKE_NONSECURE[2]
//	0x230 32  INTR[6]                               Raw Interrupts
//	0x248 32  PROC0_INTE[6]                         Interrupt Enable for proc0
//	0x260 32  PROC0_INTF[6]                         Interrupt Force for proc0
//	0x278 32  PROC0_INTS[6]                         Interrupt status after masking & forcing for proc0
//	0x290 32  PROC1_INTE[6]                         Interrupt Enable for proc1
//	0x2A8 32  PROC1_INTF[6]                         Interrupt Force for proc1
//	0x2C0 32  PROC1_INTS[6]                         Interrupt status after masking & forcing for proc1
//	0x2D8 32  DORMANT_WAKE_INTE[6]                  Interrupt Enable for dormant_wake
//	0x2F0 32  DORMANT_WAKE_INTF[6]                  Interrupt Force for dormant_wake
//	0x308 32  DORMANT_WAKE_INTS[6]                  Interrupt status after masking & forcing for dormant_wake
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package iobank

const (
	OUTTOPAD  STATUS = 0x01 << 9  //+ output signal to pad after register override is applied
	OETOPAD   STATUS = 0x01 << 13 //+ output enable to pad after register override is applied
	INFROMPAD STATUS = 0x01 << 17 //+ input signal from pad, before filtering and override are applied
	IRQTOPROC STATUS = 0x01 << 26 //+ interrupt to processors, after override is applied
)

const (
	OUTTOPADn  = 9
	OETOPADn   = 13
	INFROMPADn = 17
	IRQTOPROCn = 26
)

const (
	FUNCSEL    CTRL = 0x1F << 0 //+ 0-31 -> selects pin function according to the gpio table 31 == NULL
	F0         CTRL = 0x00 << 0
	F1_SPI     CTRL = 0x01 << 0
	F2_UART    CTRL = 0x02 << 0
	F3_I2C     CTRL = 0x03 << 0
	F4_PWM     CTRL = 0x04 << 0
	F5_SIO     CTRL = 0x05 << 0
	F6_PIO0    CTRL = 0x06 << 0
	F7_PIO1    CTRL = 0x07 << 0
	F8_PIO2    CTRL = 0x08 << 0
	F9         CTRL = 0x09 << 0
	F10_USB    CTRL = 0x0A << 0
	NULL       CTRL = 0x1F << 0
	OUTOVER    CTRL = 0x03 << 12 //+
	OUT_NORMAL CTRL = 0x00 << 12 //  drive output from peripheral signal selected by funcsel
	OUT_INVERT CTRL = 0x01 << 12 //  drive output from inverse of peripheral signal selected by funcsel
	OUT_LOW    CTRL = 0x02 << 12 //  drive output low
	OUT_HIGH   CTRL = 0x03 << 12 //  drive output high
	OEOVER     CTRL = 0x03 << 14 //+
	OE_NORMAL  CTRL = 0x00 << 14 //  drive output enable from peripheral signal selected by funcsel
	OE_INVERT  CTRL = 0x01 << 14 //  drive output enable from inverse of peripheral signal selected by funcsel
	OE_DISABLE CTRL = 0x02 << 14 //  disable output
	OE_ENABLE  CTRL = 0x03 << 14 //  enable output
	INOVER     CTRL = 0x03 << 16 //+
	IN_NORMAL  CTRL = 0x00 << 16 //  don't invert the peri input
	IN_INVERT  CTRL = 0x01 << 16 //  invert the peri input
	IN_LOW     CTRL = 0x02 << 16 //  drive peri input low
	IN_HIGH    CTRL = 0x03 << 16 //  drive peri input high
	IRQOVER    CTRL = 0x03 << 28 //+
	IRQ_NORMAL CTRL = 0x00 << 28 //  don't invert the interrupt
	IRQ_INVERT CTRL = 0x01 << 28 //  invert the interrupt
	IRQ_LOW    CTRL = 0x02 << 28 //  drive interrupt low
	IRQ_HIGH   CTRL = 0x03 << 28 //  drive interrupt high
)

const (
	FUNCSELn = 0
	OUTOVERn = 12
	OEOVERn  = 14
	INOVERn  = 16
	IRQOVERn = 28
)
