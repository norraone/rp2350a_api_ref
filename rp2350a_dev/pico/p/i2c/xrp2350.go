// Code generated by xgen -g; DO NOT EDIT.

//go:build rp2350

package i2c

import (
	"embedded/mmio"
	"structs"
	"unsafe"

	"github.com/embeddedgo/pico/p/mmap"
)

type Periph struct {
	_ structs.HostLayout

	CON                mmio.R32[CON]
	TAR                mmio.R32[TAR]
	SAR                mmio.R32[uint32]
	_                  uint32
	DATA_CMD           mmio.R32[DATA_CMD]
	SS_SCL_HCNT        mmio.R32[uint32]
	SS_SCL_LCNT        mmio.R32[uint32]
	FS_SCL_HCNT        mmio.R32[uint32]
	FS_SCL_LCNT        mmio.R32[uint32]
	_                  [2]uint32
	INTR_STAT          mmio.R32[INTR_STAT]
	INTR_MASK          mmio.R32[INTR_MASK]
	RAW_INTR_STAT      mmio.R32[RAW_INTR_STAT]
	RX_TL              mmio.R32[uint32]
	TX_TL              mmio.R32[uint32]
	CLR_INTR           mmio.R32[uint32]
	CLR_RX_UNDER       mmio.R32[uint32]
	CLR_RX_OVER        mmio.R32[uint32]
	CLR_TX_OVER        mmio.R32[uint32]
	CLR_RD_REQ         mmio.R32[uint32]
	CLR_TX_ABRT        mmio.R32[uint32]
	CLR_RX_DONE        mmio.R32[uint32]
	CLR_ACTIVITY       mmio.R32[uint32]
	CLR_STOP_DET       mmio.R32[uint32]
	CLR_START_DET      mmio.R32[uint32]
	CLR_GEN_CALL       mmio.R32[uint32]
	ENABLE             mmio.R32[ENABLE]
	STATUS             mmio.R32[STATUS]
	TXFLR              mmio.R32[uint32]
	RXFLR              mmio.R32[uint32]
	SDA_HOLD           mmio.R32[SDA_HOLD]
	TX_ABRT_SOURCE     mmio.R32[TX_ABRT_SOURCE]
	SLV_DATA_NACK_ONLY mmio.R32[SLV_DATA_NACK_ONLY]
	DMA_CR             mmio.R32[DMA_CR]
	DMA_TDLR           mmio.R32[uint32]
	DMA_RDLR           mmio.R32[uint32]
	SDA_SETUP          mmio.R32[uint32]
	ACK_GENERAL_CALL   mmio.R32[ACK_GENERAL_CALL]
	ENABLE_STATUS      mmio.R32[ENABLE_STATUS]
	FS_SPKLEN          mmio.R32[uint32]
	_                  uint32
	CLR_RESTART_DET    mmio.R32[uint32]
	_                  [18]uint32
	COMP_PARAM_1       mmio.R32[COMP_PARAM_1]
	COMP_VERSION       mmio.R32[uint32]
	COMP_TYPE          mmio.R32[uint32]
}

func I2C0() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.I2C0_BASE))) }
func I2C1() *Periph { return (*Periph)(unsafe.Pointer(uintptr(mmap.I2C1_BASE))) }

func (p *Periph) BaseAddr() uintptr {
	return uintptr(unsafe.Pointer(p))
}

type CON uint32

func MASTER_MODE_(p *Periph) mmio.RM32[CON] { return mmio.RM32[CON]{R: &p.CON, Mask: MASTER_MODE} }
func SPEED_(p *Periph) mmio.RM32[CON]       { return mmio.RM32[CON]{R: &p.CON, Mask: SPEED} }
func SLAVE_10BITADDR_(p *Periph) mmio.RM32[CON] {
	return mmio.RM32[CON]{R: &p.CON, Mask: SLAVE_10BITADDR}
}
func MASTER_10BITADDR_(p *Periph) mmio.RM32[CON] {
	return mmio.RM32[CON]{R: &p.CON, Mask: MASTER_10BITADDR}
}
func RESTART_EN_(p *Periph) mmio.RM32[CON]    { return mmio.RM32[CON]{R: &p.CON, Mask: RESTART_EN} }
func SLAVE_DISABLE_(p *Periph) mmio.RM32[CON] { return mmio.RM32[CON]{R: &p.CON, Mask: SLAVE_DISABLE} }
func STOP_DET_IFADDRESSED_(p *Periph) mmio.RM32[CON] {
	return mmio.RM32[CON]{R: &p.CON, Mask: STOP_DET_IFADDRESSED}
}
func TX_EMPTY_CTRL_(p *Periph) mmio.RM32[CON] { return mmio.RM32[CON]{R: &p.CON, Mask: TX_EMPTY_CTRL} }
func RX_FIFO_FULL_HLD_CTRL_(p *Periph) mmio.RM32[CON] {
	return mmio.RM32[CON]{R: &p.CON, Mask: RX_FIFO_FULL_HLD_CTRL}
}
func STOP_DET_IF_MASTER_ACTIVE_(p *Periph) mmio.RM32[CON] {
	return mmio.RM32[CON]{R: &p.CON, Mask: STOP_DET_IF_MASTER_ACTIVE}
}

type TAR uint32

func ADDR_(p *Periph) mmio.RM32[TAR]        { return mmio.RM32[TAR]{R: &p.TAR, Mask: ADDR} }
func GC_OR_START_(p *Periph) mmio.RM32[TAR] { return mmio.RM32[TAR]{R: &p.TAR, Mask: GC_OR_START} }
func SPECIAL_(p *Periph) mmio.RM32[TAR]     { return mmio.RM32[TAR]{R: &p.TAR, Mask: SPECIAL} }

type DATA_CMD uint32

func DAT_(p *Periph) mmio.RM32[DATA_CMD]  { return mmio.RM32[DATA_CMD]{R: &p.DATA_CMD, Mask: DAT} }
func CMD_(p *Periph) mmio.RM32[DATA_CMD]  { return mmio.RM32[DATA_CMD]{R: &p.DATA_CMD, Mask: CMD} }
func STOP_(p *Periph) mmio.RM32[DATA_CMD] { return mmio.RM32[DATA_CMD]{R: &p.DATA_CMD, Mask: STOP} }
func RESTART_(p *Periph) mmio.RM32[DATA_CMD] {
	return mmio.RM32[DATA_CMD]{R: &p.DATA_CMD, Mask: RESTART}
}
func FIRST_DATA_BYTE_(p *Periph) mmio.RM32[DATA_CMD] {
	return mmio.RM32[DATA_CMD]{R: &p.DATA_CMD, Mask: FIRST_DATA_BYTE}
}

type INTR_STAT uint32

func R_RX_UNDER_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_RX_UNDER}
}
func R_RX_OVER_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_RX_OVER}
}
func R_RX_FULL_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_RX_FULL}
}
func R_TX_OVER_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_TX_OVER}
}
func R_TX_EMPTY_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_TX_EMPTY}
}
func R_RD_REQ_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_RD_REQ}
}
func R_TX_ABRT_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_TX_ABRT}
}
func R_RX_DONE_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_RX_DONE}
}
func R_ACTIVITY_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_ACTIVITY}
}
func R_STOP_DET_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_STOP_DET}
}
func R_START_DET_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_START_DET}
}
func R_GEN_CALL_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_GEN_CALL}
}
func R_RESTART_DET_(p *Periph) mmio.RM32[INTR_STAT] {
	return mmio.RM32[INTR_STAT]{R: &p.INTR_STAT, Mask: R_RESTART_DET}
}

type INTR_MASK uint32

func M_RX_UNDER_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_RX_UNDER}
}
func M_RX_OVER_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_RX_OVER}
}
func M_RX_FULL_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_RX_FULL}
}
func M_TX_OVER_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_TX_OVER}
}
func M_TX_EMPTY_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_TX_EMPTY}
}
func M_RD_REQ_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_RD_REQ}
}
func M_TX_ABRT_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_TX_ABRT}
}
func M_RX_DONE_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_RX_DONE}
}
func M_ACTIVITY_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_ACTIVITY}
}
func M_STOP_DET_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_STOP_DET}
}
func M_START_DET_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_START_DET}
}
func M_GEN_CALL_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_GEN_CALL}
}
func M_RESTART_DET_(p *Periph) mmio.RM32[INTR_MASK] {
	return mmio.RM32[INTR_MASK]{R: &p.INTR_MASK, Mask: M_RESTART_DET}
}

type RAW_INTR_STAT uint32

func RX_UNDER_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: RX_UNDER}
}
func RX_OVER_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: RX_OVER}
}
func RX_FULL_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: RX_FULL}
}
func TX_OVER_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: TX_OVER}
}
func TX_EMPTY_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: TX_EMPTY}
}
func RD_REQ_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: RD_REQ}
}
func TX_ABRT_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: TX_ABRT}
}
func RX_DONE_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: RX_DONE}
}
func ACTIVITY_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: ACTIVITY}
}
func STOP_DET_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: STOP_DET}
}
func START_DET_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: START_DET}
}
func GEN_CALL_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: GEN_CALL}
}
func RESTART_DET_(p *Periph) mmio.RM32[RAW_INTR_STAT] {
	return mmio.RM32[RAW_INTR_STAT]{R: &p.RAW_INTR_STAT, Mask: RESTART_DET}
}

type ENABLE uint32

func EN_(p *Periph) mmio.RM32[ENABLE]    { return mmio.RM32[ENABLE]{R: &p.ENABLE, Mask: EN} }
func ABORT_(p *Periph) mmio.RM32[ENABLE] { return mmio.RM32[ENABLE]{R: &p.ENABLE, Mask: ABORT} }
func TX_CMD_BLOCK_(p *Periph) mmio.RM32[ENABLE] {
	return mmio.RM32[ENABLE]{R: &p.ENABLE, Mask: TX_CMD_BLOCK}
}

type STATUS uint32

func ACT_(p *Periph) mmio.RM32[STATUS]     { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: ACT} }
func TFNF_(p *Periph) mmio.RM32[STATUS]    { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: TFNF} }
func TFE_(p *Periph) mmio.RM32[STATUS]     { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: TFE} }
func RFNE_(p *Periph) mmio.RM32[STATUS]    { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: RFNE} }
func RFF_(p *Periph) mmio.RM32[STATUS]     { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: RFF} }
func MST_ACT_(p *Periph) mmio.RM32[STATUS] { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: MST_ACT} }
func SLV_ACT_(p *Periph) mmio.RM32[STATUS] { return mmio.RM32[STATUS]{R: &p.STATUS, Mask: SLV_ACT} }

type SDA_HOLD uint32

func SDA_TX_HOLD_(p *Periph) mmio.RM32[SDA_HOLD] {
	return mmio.RM32[SDA_HOLD]{R: &p.SDA_HOLD, Mask: SDA_TX_HOLD}
}
func SDA_RX_HOLD_(p *Periph) mmio.RM32[SDA_HOLD] {
	return mmio.RM32[SDA_HOLD]{R: &p.SDA_HOLD, Mask: SDA_RX_HOLD}
}

type TX_ABRT_SOURCE uint32

func ABRT_7B_ADDR_NOACK_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_7B_ADDR_NOACK}
}
func ABRT_10ADDR1_NOACK_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_10ADDR1_NOACK}
}
func ABRT_10ADDR2_NOACK_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_10ADDR2_NOACK}
}
func ABRT_TXDATA_NOACK_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_TXDATA_NOACK}
}
func ABRT_GCALL_NOACK_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_GCALL_NOACK}
}
func ABRT_GCALL_READ_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_GCALL_READ}
}
func ABRT_HS_ACKDET_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_HS_ACKDET}
}
func ABRT_SBYTE_ACKDET_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_SBYTE_ACKDET}
}
func ABRT_HS_NORSTRT_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_HS_NORSTRT}
}
func ABRT_SBYTE_NORSTRT_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_SBYTE_NORSTRT}
}
func ABRT_10B_RD_NORSTRT_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_10B_RD_NORSTRT}
}
func ABRT_MASTER_DIS_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_MASTER_DIS}
}
func ARB_LOST_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ARB_LOST}
}
func ABRT_SLVFLUSH_TXFIFO_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_SLVFLUSH_TXFIFO}
}
func ABRT_SLV_ARBLOST_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_SLV_ARBLOST}
}
func ABRT_SLVRD_INTX_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_SLVRD_INTX}
}
func ABRT_USER_ABRT_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: ABRT_USER_ABRT}
}
func TX_FLUSH_CNT_(p *Periph) mmio.RM32[TX_ABRT_SOURCE] {
	return mmio.RM32[TX_ABRT_SOURCE]{R: &p.TX_ABRT_SOURCE, Mask: TX_FLUSH_CNT}
}

type SLV_DATA_NACK_ONLY uint32

func NACK_(p *Periph) mmio.RM32[SLV_DATA_NACK_ONLY] {
	return mmio.RM32[SLV_DATA_NACK_ONLY]{R: &p.SLV_DATA_NACK_ONLY, Mask: NACK}
}

type DMA_CR uint32

func RDMAE_(p *Periph) mmio.RM32[DMA_CR] { return mmio.RM32[DMA_CR]{R: &p.DMA_CR, Mask: RDMAE} }
func TDMAE_(p *Periph) mmio.RM32[DMA_CR] { return mmio.RM32[DMA_CR]{R: &p.DMA_CR, Mask: TDMAE} }

type ACK_GENERAL_CALL uint32

func ACK_GEN_CALL_(p *Periph) mmio.RM32[ACK_GENERAL_CALL] {
	return mmio.RM32[ACK_GENERAL_CALL]{R: &p.ACK_GENERAL_CALL, Mask: ACK_GEN_CALL}
}

type ENABLE_STATUS uint32

func ENABLED_(p *Periph) mmio.RM32[ENABLE_STATUS] {
	return mmio.RM32[ENABLE_STATUS]{R: &p.ENABLE_STATUS, Mask: ENABLED}
}
func SLV_DISABLED_WHILE_BUSY_(p *Periph) mmio.RM32[ENABLE_STATUS] {
	return mmio.RM32[ENABLE_STATUS]{R: &p.ENABLE_STATUS, Mask: SLV_DISABLED_WHILE_BUSY}
}
func SLV_RX_DATA_LOST_(p *Periph) mmio.RM32[ENABLE_STATUS] {
	return mmio.RM32[ENABLE_STATUS]{R: &p.ENABLE_STATUS, Mask: SLV_RX_DATA_LOST}
}

type COMP_PARAM_1 uint32

func APB_DATA_WIDTH_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: APB_DATA_WIDTH}
}
func MAX_SPEED_MODE_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: MAX_SPEED_MODE}
}
func HC_COUNT_VALUES_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: HC_COUNT_VALUES}
}
func INTR_IO_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: INTR_IO}
}
func HAS_DMA_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: HAS_DMA}
}
func ADD_ENCODED_PARAMS_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: ADD_ENCODED_PARAMS}
}
func RX_BUFFER_DEPTH_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: RX_BUFFER_DEPTH}
}
func TX_BUFFER_DEPTH_(p *Periph) mmio.RM32[COMP_PARAM_1] {
	return mmio.RM32[COMP_PARAM_1]{R: &p.COMP_PARAM_1, Mask: TX_BUFFER_DEPTH}
}
