// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package pwm provides access to the registers of the PWM peripheral.
//
// Instances:
//
//	PWM  PWM_BASE  -  PWM_WRAP_0,PWM_WRAP_1  Simple PWM
//
// Registers:
//
//	0x000 32  CH0_CSR    Control and status register
//	0x004 32  CH0_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x008 32  CH0_CTR    Direct access to the PWM counter
//	0x00C 32  CH0_CC     Counter compare values
//	0x010 32  CH0_TOP    Counter wrap value
//	0x014 32  CH1_CSR    Control and status register
//	0x018 32  CH1_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x01C 32  CH1_CTR    Direct access to the PWM counter
//	0x020 32  CH1_CC     Counter compare values
//	0x024 32  CH1_TOP    Counter wrap value
//	0x028 32  CH2_CSR    Control and status register
//	0x02C 32  CH2_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x030 32  CH2_CTR    Direct access to the PWM counter
//	0x034 32  CH2_CC     Counter compare values
//	0x038 32  CH2_TOP    Counter wrap value
//	0x03C 32  CH3_CSR    Control and status register
//	0x040 32  CH3_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x044 32  CH3_CTR    Direct access to the PWM counter
//	0x048 32  CH3_CC     Counter compare values
//	0x04C 32  CH3_TOP    Counter wrap value
//	0x050 32  CH4_CSR    Control and status register
//	0x054 32  CH4_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x058 32  CH4_CTR    Direct access to the PWM counter
//	0x05C 32  CH4_CC     Counter compare values
//	0x060 32  CH4_TOP    Counter wrap value
//	0x064 32  CH5_CSR    Control and status register
//	0x068 32  CH5_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x06C 32  CH5_CTR    Direct access to the PWM counter
//	0x070 32  CH5_CC     Counter compare values
//	0x074 32  CH5_TOP    Counter wrap value
//	0x078 32  CH6_CSR    Control and status register
//	0x07C 32  CH6_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x080 32  CH6_CTR    Direct access to the PWM counter
//	0x084 32  CH6_CC     Counter compare values
//	0x088 32  CH6_TOP    Counter wrap value
//	0x08C 32  CH7_CSR    Control and status register
//	0x090 32  CH7_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x094 32  CH7_CTR    Direct access to the PWM counter
//	0x098 32  CH7_CC     Counter compare values
//	0x09C 32  CH7_TOP    Counter wrap value
//	0x0A0 32  CH8_CSR    Control and status register
//	0x0A4 32  CH8_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x0A8 32  CH8_CTR    Direct access to the PWM counter
//	0x0AC 32  CH8_CC     Counter compare values
//	0x0B0 32  CH8_TOP    Counter wrap value
//	0x0B4 32  CH9_CSR    Control and status register
//	0x0B8 32  CH9_DIV    INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x0BC 32  CH9_CTR    Direct access to the PWM counter
//	0x0C0 32  CH9_CC     Counter compare values
//	0x0C4 32  CH9_TOP    Counter wrap value
//	0x0C8 32  CH10_CSR   Control and status register
//	0x0CC 32  CH10_DIV   INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x0D0 32  CH10_CTR   Direct access to the PWM counter
//	0x0D4 32  CH10_CC    Counter compare values
//	0x0D8 32  CH10_TOP   Counter wrap value
//	0x0DC 32  CH11_CSR   Control and status register
//	0x0E0 32  CH11_DIV   INT and FRAC form a fixed-point fractional number. Counting rate is system clock frequency divided by this number. Fractional division uses simple 1st-order sigma-delta.
//	0x0E4 32  CH11_CTR   Direct access to the PWM counter
//	0x0E8 32  CH11_CC    Counter compare values
//	0x0EC 32  CH11_TOP   Counter wrap value
//	0x0F0 32  EN         This register aliases the CSR_EN bits for all channels. Writing to this register allows multiple channels to be enabled or disabled simultaneously, so they can run in perfect sync. For each channel, there is only one physical EN register bit, which can be accessed through here or CHx_CSR.
//	0x0F4 32  INTR       Raw Interrupts
//	0x0F8 32  IRQ0_INTE  Interrupt Enable for irq0
//	0x0FC 32  IRQ0_INTF  Interrupt Force for irq0
//	0x100 32  IRQ0_INTS  Interrupt status after masking & forcing for irq0
//	0x104 32  IRQ1_INTE  Interrupt Enable for irq1
//	0x108 32  IRQ1_INTF  Interrupt Force for irq1
//	0x10C 32  IRQ1_INTS  Interrupt status after masking & forcing for irq1
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package pwm

const (
	EN         CH0_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH0_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH0_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH0_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH0_CSR = 0x03 << 4 //+
	DIV        CH0_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH0_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH0_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH0_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH0_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH0_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH0_DIV = 0x0F << 0 //+
	INT  CH0_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH0_CC = 0xFFFF << 0  //+
	B CH0_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH1_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH1_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH1_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH1_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH1_CSR = 0x03 << 4 //+
	DIV        CH1_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH1_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH1_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH1_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH1_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH1_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH1_DIV = 0x0F << 0 //+
	INT  CH1_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH1_CC = 0xFFFF << 0  //+
	B CH1_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH2_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH2_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH2_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH2_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH2_CSR = 0x03 << 4 //+
	DIV        CH2_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH2_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH2_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH2_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH2_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH2_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH2_DIV = 0x0F << 0 //+
	INT  CH2_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH2_CC = 0xFFFF << 0  //+
	B CH2_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH3_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH3_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH3_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH3_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH3_CSR = 0x03 << 4 //+
	DIV        CH3_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH3_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH3_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH3_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH3_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH3_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH3_DIV = 0x0F << 0 //+
	INT  CH3_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH3_CC = 0xFFFF << 0  //+
	B CH3_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH4_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH4_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH4_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH4_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH4_CSR = 0x03 << 4 //+
	DIV        CH4_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH4_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH4_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH4_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH4_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH4_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH4_DIV = 0x0F << 0 //+
	INT  CH4_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH4_CC = 0xFFFF << 0  //+
	B CH4_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH5_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH5_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH5_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH5_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH5_CSR = 0x03 << 4 //+
	DIV        CH5_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH5_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH5_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH5_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH5_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH5_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH5_DIV = 0x0F << 0 //+
	INT  CH5_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH5_CC = 0xFFFF << 0  //+
	B CH5_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH6_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH6_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH6_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH6_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH6_CSR = 0x03 << 4 //+
	DIV        CH6_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH6_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH6_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH6_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH6_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH6_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH6_DIV = 0x0F << 0 //+
	INT  CH6_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH6_CC = 0xFFFF << 0  //+
	B CH6_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH7_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH7_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH7_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH7_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH7_CSR = 0x03 << 4 //+
	DIV        CH7_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH7_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH7_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH7_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH7_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH7_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH7_DIV = 0x0F << 0 //+
	INT  CH7_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH7_CC = 0xFFFF << 0  //+
	B CH7_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH8_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH8_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH8_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH8_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH8_CSR = 0x03 << 4 //+
	DIV        CH8_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH8_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH8_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH8_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH8_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH8_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH8_DIV = 0x0F << 0 //+
	INT  CH8_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH8_CC = 0xFFFF << 0  //+
	B CH8_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH9_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH9_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH9_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH9_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH9_CSR = 0x03 << 4 //+
	DIV        CH9_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH9_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH9_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH9_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH9_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH9_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH9_DIV = 0x0F << 0 //+
	INT  CH9_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH9_CC = 0xFFFF << 0  //+
	B CH9_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH10_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH10_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH10_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH10_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH10_CSR = 0x03 << 4 //+
	DIV        CH10_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH10_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH10_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH10_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH10_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH10_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH10_DIV = 0x0F << 0 //+
	INT  CH10_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH10_CC = 0xFFFF << 0  //+
	B CH10_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	EN         CH11_CSR = 0x01 << 0 //+ Enable the PWM channel.
	PH_CORRECT CH11_CSR = 0x01 << 1 //+ 1: Enable phase-correct modulation. 0: Trailing-edge
	A_INV      CH11_CSR = 0x01 << 2 //+ Invert output A
	B_INV      CH11_CSR = 0x01 << 3 //+ Invert output B
	DIVMODE    CH11_CSR = 0x03 << 4 //+
	DIV        CH11_CSR = 0x00 << 4 //  Free-running counting at rate dictated by fractional divider
	LEVEL      CH11_CSR = 0x01 << 4 //  Fractional divider operation is gated by the PWM B pin.
	RISE       CH11_CSR = 0x02 << 4 //  Counter advances with each rising edge of the PWM B pin.
	FALL       CH11_CSR = 0x03 << 4 //  Counter advances with each falling edge of the PWM B pin.
	PH_RET     CH11_CSR = 0x01 << 6 //+ Retard the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running.
	PH_ADV     CH11_CSR = 0x01 << 7 //+ Advance the phase of the counter by 1 count, while it is running. Self-clearing. Write a 1, and poll until low. Counter must be running at less than full speed (div_int + div_frac / 16 > 1)
)

const (
	ENn         = 0
	PH_CORRECTn = 1
	A_INVn      = 2
	B_INVn      = 3
	DIVMODEn    = 4
	PH_RETn     = 6
	PH_ADVn     = 7
)

const (
	FRAC CH11_DIV = 0x0F << 0 //+
	INT  CH11_DIV = 0xFF << 4 //+
)

const (
	FRACn = 0
	INTn  = 4
)

const (
	A CH11_CC = 0xFFFF << 0  //+
	B CH11_CC = 0xFFFF << 16 //+
)

const (
	An = 0
	Bn = 16
)

const (
	CH0  EN = 0x01 << 0  //+
	CH1  EN = 0x01 << 1  //+
	CH2  EN = 0x01 << 2  //+
	CH3  EN = 0x01 << 3  //+
	CH4  EN = 0x01 << 4  //+
	CH5  EN = 0x01 << 5  //+
	CH6  EN = 0x01 << 6  //+
	CH7  EN = 0x01 << 7  //+
	CH8  EN = 0x01 << 8  //+
	CH9  EN = 0x01 << 9  //+
	CH10 EN = 0x01 << 10 //+
	CH11 EN = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  INTR = 0x01 << 0  //+
	CH1  INTR = 0x01 << 1  //+
	CH2  INTR = 0x01 << 2  //+
	CH3  INTR = 0x01 << 3  //+
	CH4  INTR = 0x01 << 4  //+
	CH5  INTR = 0x01 << 5  //+
	CH6  INTR = 0x01 << 6  //+
	CH7  INTR = 0x01 << 7  //+
	CH8  INTR = 0x01 << 8  //+
	CH9  INTR = 0x01 << 9  //+
	CH10 INTR = 0x01 << 10 //+
	CH11 INTR = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  IRQ0_INTE = 0x01 << 0  //+
	CH1  IRQ0_INTE = 0x01 << 1  //+
	CH2  IRQ0_INTE = 0x01 << 2  //+
	CH3  IRQ0_INTE = 0x01 << 3  //+
	CH4  IRQ0_INTE = 0x01 << 4  //+
	CH5  IRQ0_INTE = 0x01 << 5  //+
	CH6  IRQ0_INTE = 0x01 << 6  //+
	CH7  IRQ0_INTE = 0x01 << 7  //+
	CH8  IRQ0_INTE = 0x01 << 8  //+
	CH9  IRQ0_INTE = 0x01 << 9  //+
	CH10 IRQ0_INTE = 0x01 << 10 //+
	CH11 IRQ0_INTE = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  IRQ0_INTF = 0x01 << 0  //+
	CH1  IRQ0_INTF = 0x01 << 1  //+
	CH2  IRQ0_INTF = 0x01 << 2  //+
	CH3  IRQ0_INTF = 0x01 << 3  //+
	CH4  IRQ0_INTF = 0x01 << 4  //+
	CH5  IRQ0_INTF = 0x01 << 5  //+
	CH6  IRQ0_INTF = 0x01 << 6  //+
	CH7  IRQ0_INTF = 0x01 << 7  //+
	CH8  IRQ0_INTF = 0x01 << 8  //+
	CH9  IRQ0_INTF = 0x01 << 9  //+
	CH10 IRQ0_INTF = 0x01 << 10 //+
	CH11 IRQ0_INTF = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  IRQ0_INTS = 0x01 << 0  //+
	CH1  IRQ0_INTS = 0x01 << 1  //+
	CH2  IRQ0_INTS = 0x01 << 2  //+
	CH3  IRQ0_INTS = 0x01 << 3  //+
	CH4  IRQ0_INTS = 0x01 << 4  //+
	CH5  IRQ0_INTS = 0x01 << 5  //+
	CH6  IRQ0_INTS = 0x01 << 6  //+
	CH7  IRQ0_INTS = 0x01 << 7  //+
	CH8  IRQ0_INTS = 0x01 << 8  //+
	CH9  IRQ0_INTS = 0x01 << 9  //+
	CH10 IRQ0_INTS = 0x01 << 10 //+
	CH11 IRQ0_INTS = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  IRQ1_INTE = 0x01 << 0  //+
	CH1  IRQ1_INTE = 0x01 << 1  //+
	CH2  IRQ1_INTE = 0x01 << 2  //+
	CH3  IRQ1_INTE = 0x01 << 3  //+
	CH4  IRQ1_INTE = 0x01 << 4  //+
	CH5  IRQ1_INTE = 0x01 << 5  //+
	CH6  IRQ1_INTE = 0x01 << 6  //+
	CH7  IRQ1_INTE = 0x01 << 7  //+
	CH8  IRQ1_INTE = 0x01 << 8  //+
	CH9  IRQ1_INTE = 0x01 << 9  //+
	CH10 IRQ1_INTE = 0x01 << 10 //+
	CH11 IRQ1_INTE = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  IRQ1_INTF = 0x01 << 0  //+
	CH1  IRQ1_INTF = 0x01 << 1  //+
	CH2  IRQ1_INTF = 0x01 << 2  //+
	CH3  IRQ1_INTF = 0x01 << 3  //+
	CH4  IRQ1_INTF = 0x01 << 4  //+
	CH5  IRQ1_INTF = 0x01 << 5  //+
	CH6  IRQ1_INTF = 0x01 << 6  //+
	CH7  IRQ1_INTF = 0x01 << 7  //+
	CH8  IRQ1_INTF = 0x01 << 8  //+
	CH9  IRQ1_INTF = 0x01 << 9  //+
	CH10 IRQ1_INTF = 0x01 << 10 //+
	CH11 IRQ1_INTF = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)

const (
	CH0  IRQ1_INTS = 0x01 << 0  //+
	CH1  IRQ1_INTS = 0x01 << 1  //+
	CH2  IRQ1_INTS = 0x01 << 2  //+
	CH3  IRQ1_INTS = 0x01 << 3  //+
	CH4  IRQ1_INTS = 0x01 << 4  //+
	CH5  IRQ1_INTS = 0x01 << 5  //+
	CH6  IRQ1_INTS = 0x01 << 6  //+
	CH7  IRQ1_INTS = 0x01 << 7  //+
	CH8  IRQ1_INTS = 0x01 << 8  //+
	CH9  IRQ1_INTS = 0x01 << 9  //+
	CH10 IRQ1_INTS = 0x01 << 10 //+
	CH11 IRQ1_INTS = 0x01 << 11 //+
)

const (
	CH0n  = 0
	CH1n  = 1
	CH2n  = 2
	CH3n  = 3
	CH4n  = 4
	CH5n  = 5
	CH6n  = 6
	CH7n  = 7
	CH8n  = 8
	CH9n  = 9
	CH10n = 10
	CH11n = 11
)
