// Code generated by svdxgen; DO NOT EDIT.

//go:build rp2350

// Package qmi provides access to the registers of the QMI peripheral.
//
// Instances:
//
//	QMI  QMI_BASE  -  -  QSPI Memory Interface. Provides a memory-mapped interface to up to two SPI/DSPI/QSPI flash or PSRAM devices. Also provides a serial interface for programming and configuration of the external device.
//
// Registers:
//
//	0x000 32  DIRECT_CSR                                            Control and status for direct serial mode Direct serial mode allows the processor to send and receive raw serial frames, for programming, configuration and control of the external memory devices. Only SPI mode 0 (CPOL=0 CPHA=0) is supported.
//	0x004 32  DIRECT_TX                                             Transmit FIFO for direct mode
//	0x008 32  DIRECT_RX                                             Receive FIFO for direct mode
//	0x00C 32  M{TIMING,RFMT(FMT),RCMD(CMD),WFMT(FMT),WCMD(CMD)}[2]  Configuration register for memory address windows
//	0x034 32  ATRANS[8]                                             Configure address translation for XIP virtual addresses 0x000000 through 0x3fffff (a 4 MiB window starting at +0 MiB). Address translation allows a program image to be executed in place at multiple physical flash addresses (for example, a double-buffered flash image for over-the-air updates), without the overhead of position-independent code. At reset, the address translation registers are initialised to an identity mapping, so that they can be ignored if address translation is not required. Note that the XIP cache is fully virtually addressed, so a cache flush is required after changing the address translation.
//
// Import:
//
//	github.com/embeddedgo/pico/p/mmap
package qmi

const (
	EN          DIRECT_CSR = 0x01 << 0  //+ Enable direct mode. In direct mode, software controls the chip select lines, and can perform direct SPI transfers by pushing data to the DIRECT_TX FIFO, and popping the same amount of data from the DIRECT_RX FIFO. Memory-mapped accesses will generate bus errors when direct serial mode is enabled.
	BUSY        DIRECT_CSR = 0x01 << 1  //+ Direct mode busy flag. If 1, data is currently being shifted in/out (or would be if the interface were not stalled on the RX FIFO), and the chip select must not yet be deasserted. The busy flag will also be set to 1 if a memory-mapped transfer is still in progress when direct mode is enabled. Direct mode blocks new memory-mapped transfers, but can't halt a transfer that is already in progress. If there is a chance that memory-mapped transfers may be in progress, the busy flag should be polled for 0 before asserting the chip select. (In practice you will usually discover this timing condition through other means, because any subsequent memory-mapped transfers when direct mode is enabled will return bus errors, which are difficult to ignore.)
	ASSERT_CS0N DIRECT_CSR = 0x01 << 2  //+ When 1, assert (i.e. drive low) the CS0n chip select line. Note that this applies even when DIRECT_CSR_EN is 0.
	ASSERT_CS1N DIRECT_CSR = 0x01 << 3  //+ When 1, assert (i.e. drive low) the CS1n chip select line. Note that this applies even when DIRECT_CSR_EN is 0.
	AUTO_CS0N   DIRECT_CSR = 0x01 << 6  //+ When 1, automatically assert the CS0n chip select line whenever the BUSY flag is set.
	AUTO_CS1N   DIRECT_CSR = 0x01 << 7  //+ When 1, automatically assert the CS1n chip select line whenever the BUSY flag is set.
	TXFULL      DIRECT_CSR = 0x01 << 10 //+ When 1, the DIRECT_TX FIFO is currently full. If the processor tries to write more data, that data will be ignored.
	TXEMPTY     DIRECT_CSR = 0x01 << 11 //+ When 1, the DIRECT_TX FIFO is currently empty. Unless the processor pushes more data, transmission will stop and BUSY will go low once the current 8-bit serial frame completes.
	TXLEVEL     DIRECT_CSR = 0x07 << 12 //+ Current level of DIRECT_TX FIFO
	RXEMPTY     DIRECT_CSR = 0x01 << 16 //+ When 1, the DIRECT_RX FIFO is currently empty. If the processor attempts to read more data, the FIFO state is not affected, but the value returned to the processor is undefined.
	RXFULL      DIRECT_CSR = 0x01 << 17 //+ When 1, the DIRECT_RX FIFO is currently full. The serial interface will be stalled until data is popped; the interface will not begin a new serial frame when the DIRECT_TX FIFO is empty or the DIRECT_RX FIFO is full.
	RXLEVEL     DIRECT_CSR = 0x07 << 18 //+ Current level of DIRECT_RX FIFO
	DCLKDIV     DIRECT_CSR = 0xFF << 22 //+ Clock divisor for direct serial mode. Divisors of 1..255 are encoded directly, and the maximum divisor of 256 is encoded by a value of CLKDIV=0. The clock divisor can be changed on-the-fly by software, without halting or otherwise coordinating with the serial interface. The serial interface will sample the latest clock divisor each time it begins the transmission of a new byte.
	DRXDELAY    DIRECT_CSR = 0x03 << 30 //+ Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.)
)

const (
	ENn          = 0
	BUSYn        = 1
	ASSERT_CS0Nn = 2
	ASSERT_CS1Nn = 3
	AUTO_CS0Nn   = 6
	AUTO_CS1Nn   = 7
	TXFULLn      = 10
	TXEMPTYn     = 11
	TXLEVELn     = 12
	RXEMPTYn     = 16
	RXFULLn      = 17
	RXLEVELn     = 18
	DCLKDIVn     = 22
	DRXDELAYn    = 30
)

const (
	DATA   DIRECT_TX = 0xFFFF << 0 //+ Data pushed here will be clocked out falling edges of SCK (or before the very first rising edge of SCK, if this is the first pulse). For each byte clocked out, the interface will simultaneously sample one byte, on rising edges of SCK, and push this to the DIRECT_RX FIFO. For 16-bit data, the least-significant byte is transmitted first.
	IWIDTH DIRECT_TX = 0x03 << 16  //+ Configure whether this FIFO record is transferred with single/dual/quad interface width (0/1/2). Different widths can be mixed freely.
	S      DIRECT_TX = 0x00 << 16  //  Single width
	D      DIRECT_TX = 0x01 << 16  //  Dual width
	Q      DIRECT_TX = 0x02 << 16  //  Quad width
	DWIDTH DIRECT_TX = 0x01 << 18  //+ Data width. If 0, hardware will transmit the 8 LSBs of the DIRECT_TX DATA field, and return an 8-bit value in the 8 LSBs of DIRECT_RX. If 1, the full 16-bit width is used. 8-bit and 16-bit transfers can be mixed freely.
	OE     DIRECT_TX = 0x01 << 19  //+ Output enable (active-high). For single width (SPI), this field is ignored, and SD0 is always set to output, with SD1 always set to input. For dual and quad width (DSPI/QSPI), this sets whether the relevant SDx pads are set to output whilst transferring this FIFO record. In this case the command/address should have OE set, and the data transfer should have OE set or clear depending on the direction of the transfer.
	NOPUSH DIRECT_TX = 0x01 << 20  //+ Inhibit the RX FIFO push that would correspond to this TX FIFO entry. Useful to avoid garbage appearing in the RX FIFO when pushing the command at the beginning of a SPI transfer.
)

const (
	DATAn   = 0
	IWIDTHn = 16
	DWIDTHn = 18
	OEn     = 19
	NOPUSHn = 20
)

const (
	CLKDIV       TIMING = 0xFF << 0  //+ Clock divisor. Odd and even divisors are supported. Defines the SCK clock period in units of 1 system clock cycle. Divisors 1..255 are encoded directly, and a divisor of 256 is encoded with a value of CLKDIV=0. The clock divisor can be changed on-the-fly, even when the QMI is currently accessing memory in this address window. All other parameters must only be changed when the QMI is idle. If software is increasing CLKDIV in anticipation of an increase in the system clock frequency, a dummy access to either memory window (and appropriate processor barriers/fences) must be inserted after the Mx_TIMING write to ensure the SCK divisor change is in effect _before_ the system clock is changed.
	RXDELAY      TIMING = 0x07 << 8  //+ Delay the read data sample timing, in units of one half of a system clock cycle. (Not necessarily half of an SCK cycle.) An RXDELAY of 0 means the sample is captured at the SDI input registers simultaneously with the rising edge of SCK launched from the SCK output register. At higher SCK frequencies, RXDELAY may need to be increased to account for the round trip delay of the pads, and the clock-to-Q delay of the QSPI memory device.
	MIN_DESELECT TIMING = 0x1F << 12 //+ After this window's chip select is deasserted, it remains deasserted for half an SCK cycle (rounded up to an integer number of system clock cycles), plus MIN_DESELECT additional system clock cycles, before the QMI reasserts either chip select pin. Nonzero values may be required for PSRAM devices which enforce a longer minimum CS deselect time, so that they can perform internal DRAM refresh cycles whilst deselected.
	MAX_SELECT   TIMING = 0x3F << 17 //+ Enforce a maximum assertion duration for this window's chip select, in units of 64 system clock cycles. If 0, the QMI is permitted to keep the chip select asserted indefinitely when servicing sequential memory accesses (see COOLDOWN). This feature is required to meet timing constraints of PSRAM devices, which specify a maximum chip select assertion so they can perform DRAM refresh cycles. See also MIN_DESELECT, which can enforce a minimum deselect time. If a memory access is in progress at the time MAX_SELECT is reached, the QMI will wait for the access to complete before deasserting the chip select. This additional time must be accounted for to calculate a safe MAX_SELECT value. In the worst case, this may be a fully-formed serial transfer, including command prefix and address, with a data payload as large as one cache line.
	SELECT_HOLD  TIMING = 0x03 << 23 //+ Add up to three additional system clock cycles of active hold between the last falling edge of SCK and the deassertion of this window's chip select. The default hold time is one system clock cycle. Note that flash datasheets usually give chip select active hold time from the last *rising* edge of SCK, and so even zero hold from the last falling edge would be safe. Note that this is a minimum hold time guaranteed by the QMI: the actual chip select active hold may be slightly longer for read transfers with low clock divisors and/or high sample delays. Specifically, if the point two cycles after the last RX data sample is later than the last SCK falling edge, then the hold time is measured from *this* point. Note also that, in case the final SCK pulse is masked to save energy (true for non-DTR reads when COOLDOWN is disabled or PAGE_BREAK is reached), all of QMI's timing logic behaves as though the clock pulse were still present. The SELECT_HOLD time is applied from the point where the last SCK falling edge would be if the clock pulse were not masked.
	SELECT_SETUP TIMING = 0x01 << 25 //+ Add up to one additional system clock cycle of setup between chip select assertion and the first rising edge of SCK. The default setup time is one half SCK period, which is usually sufficient except for very high SCK frequencies with some flash devices.
	PAGEBREAK    TIMING = 0x03 << 28 //+ When page break is enabled, chip select will automatically deassert when crossing certain power-of-2-aligned address boundaries. The next access will always begin a new read/write SPI burst, even if the address of the next access follows in sequence with the last access before the page boundary. Some flash and PSRAM devices forbid crossing page boundaries with a single read/write transfer, or restrict the operating frequency for transfers that do cross page a boundary. This option allows the QMI to safely support those devices. This field has no effect when COOLDOWN is disabled.
	PB_NONE      TIMING = 0x00 << 28 //  No page boundary is enforced
	PB_256       TIMING = 0x01 << 28 //  Break bursts crossing a 256-byte page boundary
	PB_1024      TIMING = 0x02 << 28 //  Break bursts crossing a 1024-byte quad-page boundary
	PB_4096      TIMING = 0x03 << 28 //  Break bursts crossing a 4096-byte sector boundary
	COOLDOWN     TIMING = 0x03 << 30 //+ Chip select cooldown period. When a memory transfer finishes, the chip select remains asserted for 64 x COOLDOWN system clock cycles, plus half an SCK clock period (rounded up for odd SCK divisors). After this cooldown expires, the chip select is always deasserted to save power. If the next memory access arrives within the cooldown period, the QMI may be able to append more SCK cycles to the currently ongoing SPI transfer, rather than starting a new transfer. This reduces access latency and increases bus throughput. Specifically, the next access must be in the same direction (read/write), access the same memory window (chip select 0/1), and follow sequentially the address of the last transfer. If any of these are false, the new access will first deassert the chip select, then begin a new transfer. If COOLDOWN is 0, the address alignment configured by PAGEBREAK has been reached, or the total chip select assertion limit MAX_SELECT has been reached, the cooldown period is skipped, and the chip select will always be deasserted one half SCK period after the transfer finishes.
)

const (
	CLKDIVn       = 0
	RXDELAYn      = 8
	MIN_DESELECTn = 12
	MAX_SELECTn   = 17
	SELECT_HOLDn  = 23
	SELECT_SETUPn = 25
	PAGEBREAKn    = 28
	COOLDOWNn     = 30
)

const (
	PREFIX_WIDTH FMT = 0x03 << 0  //+ The transfer width used for the command prefix, if any
	PREFIX_S     FMT = 0x00 << 0  //  Single width
	PREFIX_D     FMT = 0x01 << 0  //  Dual width
	PREFIX_Q     FMT = 0x02 << 0  //  Quad width
	ADDR_WIDTH   FMT = 0x03 << 2  //+ The transfer width used for the address. The address phase always transfers 24 bits in total.
	ADDR_S       FMT = 0x00 << 2  //  Single width
	ADDR_D       FMT = 0x01 << 2  //  Dual width
	ADDR_Q       FMT = 0x02 << 2  //  Quad width
	SUFFIX_WIDTH FMT = 0x03 << 4  //+ The width used for the post-address command suffix, if any
	SUFFIX_S     FMT = 0x00 << 4  //  Single width
	SUFFIX_D     FMT = 0x01 << 4  //  Dual width
	SUFFIX_Q     FMT = 0x02 << 4  //  Quad width
	DUMMY_WIDTH  FMT = 0x03 << 6  //+ The width used for the dummy phase, if any. If width is single, SD0/MOSI is held asserted low during the dummy phase, and SD1...SD3 are tristated. If width is dual/quad, all IOs are tristated during the dummy phase.
	DUMMY_S      FMT = 0x00 << 6  //  Single width
	DUMMY_D      FMT = 0x01 << 6  //  Dual width
	DUMMY_Q      FMT = 0x02 << 6  //  Quad width
	DATA_WIDTH   FMT = 0x03 << 8  //+ The width used for the data transfer
	DATA_S       FMT = 0x00 << 8  //  Single width
	DATA_D       FMT = 0x01 << 8  //  Dual width
	DATA_Q       FMT = 0x02 << 8  //  Quad width
	PREFIX_LEN   FMT = 0x01 << 12 //+ Length of command prefix, in units of 8 bits. (i.e. 2 cycles for quad width, 4 for dual, 8 for single)
	PREF_NONE    FMT = 0x00 << 12 //  No prefix
	PREF_8       FMT = 0x01 << 12 //  8-bit prefix
	SUFFIX_LEN   FMT = 0x03 << 14 //+ Length of post-address command suffix, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single) Only values of 0 and 8 bits are supported.
	SUFF_NONE    FMT = 0x00 << 14 //  No suffix
	SUFF_8       FMT = 0x02 << 14 //  8-bit suffix
	DUMMY_LEN    FMT = 0x07 << 16 //+ Length of dummy phase between command suffix and data phase, in units of 4 bits. (i.e. 1 cycle for quad width, 2 for dual, 4 for single)
	DUMM_NONE    FMT = 0x00 << 16 //  No dummy phase
	DUMM_4       FMT = 0x01 << 16 //  4 dummy bits
	DUMM_8       FMT = 0x02 << 16 //  8 dummy bits
	DUMM_12      FMT = 0x03 << 16 //  12 dummy bits
	DUMM_16      FMT = 0x04 << 16 //  16 dummy bits
	DUMM_20      FMT = 0x05 << 16 //  20 dummy bits
	DUMM_24      FMT = 0x06 << 16 //  24 dummy bits
	DUMM_28      FMT = 0x07 << 16 //  28 dummy bits
	DTR          FMT = 0x01 << 28 //+ Enable double transfer rate (DTR) for read commands: address, suffix and read data phases are active on both edges of SCK. SDO data is launched centre-aligned on each SCK edge, and SDI data is captured on the SCK edge that follows its launch. DTR is implemented by halving the clock rate; SCK has a period of 2 x CLK_DIV throughout the transfer. The prefix and dummy phases are still single transfer rate. If the suffix is quad-width, it must be 0 or 8 bits in length, to ensure an even number of SCK edges.
)

const (
	PREFIX_WIDTHn = 0
	ADDR_WIDTHn   = 2
	SUFFIX_WIDTHn = 4
	DUMMY_WIDTHn  = 6
	DATA_WIDTHn   = 8
	PREFIX_LENn   = 12
	SUFFIX_LENn   = 14
	DUMMY_LENn    = 16
	DTRn          = 28
)

const (
	PREFIX CMD = 0xFF << 0 //+ The command prefix bits to prepend on each new transfer, if Mx_RFMT_PREFIX_LEN is nonzero.
	SUFFIX CMD = 0xFF << 8 //+ The command suffix bits following the address, if Mx_RFMT_SUFFIX_LEN is nonzero.
)

const (
	PREFIXn = 0
	SUFFIXn = 8
)

const (
	BASE ATRANS = 0xFFF << 0  //+ Physical address base for this virtual address range, in units of 4 kiB (one flash sector). Taking a 24-bit virtual address, firstly bits 23:22 (the two MSBs) are masked to zero, and then BASE is added to bits 23:12 (the upper 12 bits) to form the physical address. Translation wraps on a 16 MiB boundary.
	SIZE ATRANS = 0x7FF << 16 //+ Translation aperture size for this virtual address range, in units of 4 kiB (one flash sector). Bits 21:12 of the virtual address are compared to SIZE. Offsets greater than SIZE return a bus error, and do not cause a QSPI access.
)

const (
	BASEn = 0
	SIZEn = 16
)
